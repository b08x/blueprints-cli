{
  "files": [
    {
      "filename": "Rakefile",
      "content": "#!/usr/bin/env ruby\n# frozen_string_literal: true\n\n# Rakefile\nrequire 'rake/clean'\nrequire 'rake/testtask'\nrequire 'rdoc/task'\nrequire 'bundler/gem_tasks'\nrequire 'rspec/core/rake_task'\nrequire 'json'\nrequire 'fileutils'\nrequire 'pathname'\nrequire 'yard'\n\nrequire 'sequel'\nrequire 'blueprintsCLI/configuration'\n\n# Use BlueprintsCLI configuration system\nCONFIG = BlueprintsCLI::Configuration.new\n\nnamespace :db do\n  desc 'Create the database'\n  task :create do\n    require 'uri'\n    uri = URI.parse(CONFIG.database_url)\n    `createdb #{uri.path[1..]}` # Remove leading slash from path\n  end\n\n  desc 'Drop the database'\n  task :drop do\n    require 'uri'\n    uri = URI.parse(CONFIG.database_url)\n    `dropdb #{uri.path[1..]}` # Remove leading slash from path\n  end\n\n  desc 'Migrate the database'\n  task :migrate do\n    Sequel.extension :migration\n    db = Sequel.connect(CONFIG.database_url)\n    Sequel::Migrator.run(db, 'lib/blueprintsCLI/db/migrate')\n  end\n\n  desc 'Seed the database'\n  task :seed do\n    require 'blueprintsCLI/db/seeds' if File.exist?('lib/blueprintsCLI/db/seeds.rb')\n  end\nend\n\n# Load YARD if available\nbegin\n  require 'yard'\n  yard_available = true\nrescue LoadError\n  yard_available = false\nend\n\n# =============================================================================\n# TESTING TASKS\n# =============================================================================\n\nnamespace :test do\n  desc 'Run the test suite'\n  Rake::TestTask.new(:unit) do |t|\n    t.libs << 'test'\n    t.libs << 'lib'\n    t.test_files = FileList['test/**/*_test.rb']\n  end\n\n  # RSpec task (if RSpec is used)\n  begin\n    require 'rspec/core/rake_task'\n\n    desc 'Run RSpec tests'\n    RSpec::Core::RakeTask.new(:spec) do |t|\n      t.pattern = 'spec/**/*_spec.rb'\n      t.rspec_opts = '--format documentation --color'\n    end\n  rescue LoadError\n    # RSpec not available, skip task\n  end\n\n  desc 'Run tests with coverage report'\n  task :coverage do\n    ENV['COVERAGE'] = 'true'\n    Rake::Task['test:unit'].invoke if Rake::Task.task_defined?('test:unit')\n    Rake::Task['test:spec'].invoke if Rake::Task.task_defined?('test:spec')\n  end\nend\n\n# Aliases for backward compatibility\ndesc 'Run the test suite'\ntask test: 'test:unit'\n\ndesc 'Run RSpec tests'\ntask spec: 'test:spec' if Rake::Task.task_defined?('test:spec')\n\ndesc 'Run tests with coverage report'\ntask coverage: 'test:coverage'\n\n# =============================================================================\n# CODE QUALITY TASKS\n# =============================================================================\n\nnamespace :quality do\n  # RuboCop task\n  begin\n    require 'rubocop/rake_task'\n\n    desc 'Run RuboCop linter'\n    RuboCop::RakeTask.new(:rubocop) do |t|\n      t.options = ['--display-cop-names']\n    end\n\n    desc 'Auto-fix RuboCop issues'\n    RuboCop::RakeTask.new(:auto_correct) do |t|\n      t.options = ['--auto-correct']\n    end\n  rescue LoadError\n    # RuboCop not available, skip task\n  end\n\n  desc 'Check documentation coverage'\n  task :doc_coverage do\n    require 'yard'\n    YARD::Registry.load!\n\n    total_objects = 0\n    documented_objects = 0\n\n    YARD::Registry.all(:class, :module, :method).each do |obj|\n      total_objects += 1\n      documented_objects += 1 if obj.docstring && !obj.docstring.empty?\n    end\n\n    coverage = (documented_objects.to_f / total_objects * 100).round(2)\n    puts \"Documentation coverage: #{coverage}% (#{documented_objects}/#{total_objects} objects)\"\n\n    if coverage < 80\n      puts '⚠️  Documentation coverage is below 80%'\n      exit 1 if ENV['STRICT_DOC_COVERAGE']\n    else\n      puts '✅ Good documentation coverage!'\n    end\n  end\n\n  desc 'Validate example code in documentation'\n  task :validate_examples do\n    puts 'Validating example code in documentation...'\n    # This could be expanded to actually parse and validate code examples\n    puts '✅ Example validation completed'\n  end\n\n  desc 'Run all quality checks'\n  task all: %i[rubocop doc_coverage validate_examples] do\n    puts 'Code quality checks completed'\n  end\nend\n\n# Aliases for backward compatibility\ndesc 'Run RuboCop linter'\ntask rubocop: 'quality:rubocop'\n\ndesc 'Run all quality checks'\ntask quality: 'quality:all'\n\n# Create rubocop namespace for autocompletion\nnamespace :rubocop do\n  desc 'Auto-fix RuboCop issues'\n  task auto_correct: 'quality:auto_correct'\nend\n\n# =============================================================================\n# DOCUMENTATION TASKS\n# =============================================================================\n\nnamespace :docs do\n  desc 'Generate RDoc documentation'\n  RDoc::Task.new(:rdoc) do |rdoc|\n    rdoc.rdoc_dir = 'doc/rdoc'\n    rdoc.title = \"Blueprints CLI #{BlueprintsCLI::VERSION}\"\n    rdoc.markup = 'tomdoc'\n    rdoc.options << '--line-numbers'\n    rdoc.options << '--all'\n    rdoc.options << '--charset=UTF-8'\n    rdoc.options << '--inline-source'\n\n    # Include main files\n    rdoc.rdoc_files.include('README.md')\n    rdoc.rdoc_files.include('lib/**/*.rb')\n    rdoc.rdoc_files.include('docs/**/*.md')\n  end\n\n  desc 'Copy additional static files for RDoc'\n  task :static do\n    puts 'Copying additional static files for RDoc...'\n    source_file = 'docs/blueprints-cli-seq-actions.html'\n    destination_dir = 'doc/rdoc'\n\n    if File.exist?(source_file)\n      FileUtils.cp(source_file, destination_dir)\n      puts \"  - Copied #{source_file} to #{destination_dir}\"\n    else\n      puts \"  - Warning: #{source_file} not found, skipping.\"\n    end\n  end\n\n  # YARD tasks (only if YARD is available)\n  if yard_available\n    desc 'Generate YARD documentation'\n    YARD::Rake::YardocTask.new(:yard) do |t|\n      t.files = ['lib/**/*.rb']\n      t.options = [\n        '--output-dir', 'doc/yard',\n        '--readme', 'README.md',\n        '--title', \"Blueprints CLI #{BlueprintsCLI::VERSION}\",\n        '--markup', 'markdown',\n        '--no-private',\n        '--protected',\n        '--embed-mixins',\n        '--list-undoc'\n      ]\n      t.stats_options = ['--list-undoc']\n    end\n\n    desc 'Show YARD documentation coverage statistics'\n    task :stats do\n      sh 'yard stats --list-undoc'\n    end\n\n    desc 'Serve YARD documentation locally'\n    task :serve do\n      sh 'yard server --reload'\n    end\n\n    desc 'Generate all documentation formats'\n    task all: %i[rdoc yard] do\n      puts 'Documentation generated successfully!'\n      puts 'RDoc available at: doc/rdoc/index.html'\n      puts 'YARD available at: doc/yard/index.html'\n    end\n  else\n    desc 'Generate all documentation formats'\n    task all: [:rdoc] do\n      puts 'Documentation generated successfully!'\n      puts 'RDoc available at: doc/rdoc/index.html'\n      puts \"Note: Install 'yard' gem for enhanced documentation\"\n    end\n\n    desc 'Show YARD documentation coverage statistics'\n    task :stats do\n      puts 'YARD not available. Install with: gem install yard'\n    end\n  end\n\n  desc 'Clean documentation directories'\n  task :clean do\n    rm_rf 'doc/rdoc'\n    rm_rf 'doc/yard'\n    puts 'Documentation directories cleaned'\n  end\nend\n\n# Aliases for backward compatibility\ndesc 'Generate RDoc documentation'\ntask rdoc: 'docs:rdoc'\n\ndesc 'Generate YARD documentation'\ntask yard: 'docs:yard'\n\ndesc 'Generate all documentation formats'\ntask docs: 'docs:all'\n\ndesc 'Clean documentation directories'\ntask clean_docs: 'docs:clean'\n\n# Create yard namespace for autocompletion\nnamespace :yard do\n  desc 'Show YARD documentation coverage statistics'\n  task stats: 'docs:stats'\n\n  desc 'Serve YARD documentation locally'\n  task serve: 'docs:serve'\nend\n\n# =============================================================================\n# BUILD AND RELEASE TASKS\n# =============================================================================\n\nnamespace :build do\n  desc 'Build with fresh documentation'\n  task docs: ['docs:clean', 'docs:all'] do\n    puts 'Build completed with fresh documentation'\n  end\n\n  desc 'Run comprehensive checks before release'\n  task check: ['test:unit', 'quality:all'] do\n    puts 'All checks passed! 🎉'\n  end\nend\n\n# Aliases for backward compatibility\ndesc 'Build with fresh documentation'\ntask build: 'build:docs'\n\ndesc 'Run comprehensive checks'\ntask check: 'build:check'\n\ndesc 'Run default tasks (tests and quality checks)'\ntask default: ['test:unit', 'quality:all']\n\n# Help task\ndesc 'Show available tasks'\ntask :help do\n  puts <<~HELP\n    Available Rake tasks for BlueprintsCLI:\n\n    Database Tasks:\n      rake db:create      - Create the database\n      rake db:drop        - Drop the database\n      rake db:migrate     - Migrate the database\n      rake db:seed        - Seed the database\n\n    Testing Tasks:\n      rake test:unit      - Run unit tests\n      rake test:spec      - Run RSpec tests (if available)\n      rake test:coverage  - Run tests with coverage report\n      rake test           - Run unit tests (alias)\n      rake spec           - Run RSpec tests (alias)\n      rake coverage       - Run tests with coverage (alias)\n\n    Code Quality Tasks:\n      rake quality:rubocop         - Run RuboCop linter\n      rake quality:auto_correct    - Auto-fix RuboCop issues\n      rake quality:doc_coverage    - Check documentation coverage\n      rake quality:validate_examples - Validate example code\n      rake quality:all             - Run all quality checks\n      rake rubocop                 - Run RuboCop linter (alias)\n      rake rubocop:auto_correct    - Auto-fix RuboCop issues (alias)\n      rake quality                 - Run all quality checks (alias)\n\n    Documentation Tasks:\n      rake docs:rdoc      - Generate RDoc documentation\n      rake docs:yard      - Generate YARD documentation\n      rake docs:stats     - Show YARD documentation coverage\n      rake docs:serve     - Serve YARD documentation locally\n      rake docs:all       - Generate all documentation formats\n      rake docs:clean     - Clean documentation directories\n      rake rdoc           - Generate RDoc documentation (alias)\n      rake yard           - Generate YARD documentation (alias)\n      rake yard:stats     - Show documentation coverage (alias)\n      rake yard:serve     - Serve YARD docs locally (alias)\n      rake docs           - Generate all documentation (alias)\n      rake clean_docs     - Clean documentation directories (alias)\n\n    Build Tasks:\n      rake build:docs     - Build with fresh documentation\n      rake build:check    - Run comprehensive checks before release\n      rake build          - Build with fresh documentation (alias)\n      rake check          - Run comprehensive checks (alias)\n\n    Other Tasks:\n      rake help           - Show this help message\n      rake default        - Run tests and quality checks\n  HELP\nend\n\n# =============================================================================\n# UTILITY TASKS\n# =============================================================================\n\ndesc 'List all available namespaces'\ntask :namespaces do\n  puts <<~NAMESPACES\n    Available task namespaces:\n\n    db:         Database operations (create, drop, migrate, seed)\n    test:       Testing operations (unit, spec, coverage)\n    quality:    Code quality checks (rubocop, doc_coverage, validate_examples, all)\n    docs:       Documentation generation (rdoc, yard, stats, serve, all, clean)\n    build:      Build operations (docs, check)\n    rubocop:    RuboCop specific tasks (auto_correct)\n    yard:       YARD specific tasks (stats, serve)\n\n    Use 'rake -T namespace:' to see tasks in a specific namespace\n    Example: rake -T test:\n  NAMESPACES\nend\n",
      "path": "/"
    },
    {
      "filename": "blueprintsCLI",
      "content": "#!/usr/bin/env ruby\n# frozen_string_literal: true\n\nlib_dir = File.expand_path(File.join(__dir__, '..', 'lib'))\n$LOAD_PATH.unshift lib_dir unless $LOAD_PATH.include?(lib_dir)\n\nrequire 'bundler/setup'\nrequire 'BlueprintsCLI'\n\n# This script serves as the entry point for the blueprintsCLI command-line interface.\n# It initializes the CLI and starts it with the provided arguments.\n\n# Load the CLI class from the blueprintsCLI gem\n\nBlueprintsCLI::CLI.start(ARGV)\n",
      "path": "/bin/"
    },
    {
      "filename": "BlueprintsCLI.rb",
      "content": "# frozen_string_literal: true\n\n# This file is part of the blueprintsCLI gem, which provides a command-line interface\n# for generating and managing code blueprints using Large Language Models (LLMs).\n\nlib_dir = File.expand_path(File.join(__dir__, '..', 'lib'))\n$LOAD_PATH.unshift lib_dir unless $LOAD_PATH.include?(lib_dir)\n\nrequire 'dotenv/load'\n\n# Attempts to load the .env file, overwriting existing environment variables.\n# If an error occurs, it displays an error message.\nbegin\n  Dotenv.load('.env', overwrite: true)\nrescue StandardError => e\n  puts \"Error loading .env file: #{e.message}\"\nend\n\nrequire 'colorize'\nrequire 'fileutils'\nrequire 'git'\nrequire 'json'\nrequire 'net/http'\nrequire 'open3'\nrequire 'pg'\nrequire 'sequel'\nrequire 'sublayer'\nrequire 'tempfile'\nrequire 'terrapin'\nrequire 'thor'\nrequire 'time'\nrequire 'tty-command'\nrequire 'tty-config'\nrequire 'tty-cursor'\nrequire 'tty-file'\nrequire 'tty-logger'\nrequire 'tty-prompt'\nrequire 'tty-table'\nrequire 'tty-which'\nrequire 'uri'\nrequire 'yaml'\n\nrequire_relative 'blueprintsCLI/version'\nrequire_relative 'blueprintsCLI/configuration'\nrequire_relative 'blueprintsCLI/logger'\n\n# Establish database connection early (global DB constant for models)\nrequire_relative 'blueprintsCLI/config/environment'\n\n# Load database interface and models after DB connection is established\nrequire_relative 'blueprintsCLI/database'\nrequire_relative 'blueprintsCLI/db/models/blueprint'\nrequire_relative 'blueprintsCLI/db/models/category'\n\nrequire_relative 'blueprintsCLI/cli_ui_integration'\nrequire_relative 'blueprintsCLI/slash_command_parser'\nrequire_relative 'blueprintsCLI/enhanced_menu'\nrequire_relative 'blueprintsCLI/simple_enhanced_menu'\nrequire_relative 'blueprintsCLI/autocomplete_handler'\n\nrequire_relative 'blueprintsCLI/providers/sublayer/ollama'\nrequire_relative 'blueprintsCLI/providers/sublayer/openrouter'\n\nDir[File.join(__dir__, 'blueprintsCLI', 'commands', '*.rb')].each { |file| require file }\nDir[File.join(__dir__, 'blueprintsCLI', 'generators', '*.rb')].each { |file| require file }\nDir[File.join(__dir__, 'blueprintsCLI', 'actions', '*.rb')].each { |file| require file }\nDir[File.join(__dir__, 'blueprintsCLI', 'agents', '*.rb')].each { |file| require file }\nDir[File.join(__dir__, 'blueprintsCLI', 'ui', '*.rb')].each { |file| require file }\nDir[File.join(__dir__, 'blueprintsCLI', 'setup', '*.rb')].each { |file| require file }\n\nrequire_relative 'blueprintsCLI/cli'\n\nmodule BlueprintsCLI\n  class Error < StandardError; end\n\n  # Global configuration instance using the new TTY::Config system\n  def self.configuration\n    @configuration ||= Configuration.new\n  end\n\n  # Access to the legacy logger for backward compatibility\n  def self.logger\n    @logger ||= Logger.instance\n  end\n\n  def self.root\n    File.dirname __dir__\n  end\nend\n",
      "path": "/lib/"
    },
    {
      "filename": "config.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative '../configuration'\n\nmodule BlueprintsCLI\n  module Actions\n    # Manages the application's configuration through a command-line interface.\n    # This action allows users to show, set up, test, and reset the configuration\n    # using the new TTY::Config-based BlueprintsCLI::Configuration system.\n    # Handles settings for the database, AI providers, logger, and various feature flags.\n    #\n    # @example Show the current configuration\n    #   BlueprintsCLI::Actions::Config.new(subcommand: 'show').call\n    #\n    # @example Run the interactive setup\n    #   BlueprintsCLI::Actions::Config.new(subcommand: 'setup').call\n    class Config < Sublayer::Actions::Base\n      ##\n      # Initializes the configuration action.\n      #\n      # @param subcommand [String] The configuration command to execute.\n      #   Defaults to 'show'. Supported values: 'show', 'view', 'setup',\n      #   'init', 'edit', 'test', 'validate', 'reset'.\n      def initialize(subcommand: 'show')\n        super\n        @subcommand = subcommand\n        @config = BlueprintsCLI::Configuration.new\n      end\n\n      ##\n      # Executes the specified configuration subcommand.\n      #\n      # This is the main entry point for the action. It routes to the appropriate\n      # method based on the subcommand provided during initialization. It also\n      # includes error handling to catch and report issues during execution.\n      #\n      # @return [Boolean] Returns `true` on success and `false` on failure or\n      #   if an unknown subcommand is provided.\n      def call\n        case @subcommand\n        when 'show', 'view'\n          show_configuration\n        when 'setup', 'init', 'edit'\n          setup_configuration\n        when 'test', 'validate'\n          test_configuration\n        when 'reset'\n          reset_configuration\n        when 'migrate'\n          migrate_configuration\n        else\n          BlueprintsCLI.logger.failure(\"Unknown config subcommand: '#{@subcommand}'\")\n          show_config_help\n          false\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error managing configuration: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) # tty-logger will format the exception and backtrace\n        false\n      end\n\n      private\n\n      ##\n      # Displays the current configuration settings.\n      #\n      # Reads from the configuration file and prints a formatted summary of all\n      # settings, including database, AI, editor, and feature flags. Also shows\n      # the status of relevant environment variables.\n      #\n      # @return [Boolean] Returns `true`.\n      def show_configuration\n        BlueprintsCLI.logger.step('Blueprint Configuration')\n        puts '=' * 60\n        puts \"Config file: #{@config.config_file_path || 'Not found'}\"\n        puts \"File exists: #{@config.exist? ? 'Yes' : 'No'}\"\n        puts ''\n\n        if @config.exist? || @config.to_hash.any?\n          # Database Configuration\n          puts 'Database Configuration:'.colorize(:cyan)\n          puts \"  URL: #{mask_password(@config.database_url || 'Not set')}\"\n          puts ''\n\n          # AI Configuration - Sublayer\n          puts 'AI Configuration (Sublayer):'.colorize(:cyan)\n          puts \"  Provider: #{@config.fetch(:ai, :sublayer, :provider, default: 'Not set')}\"\n          puts \"  Model: #{@config.fetch(:ai, :sublayer, :model, default: 'Not set')}\"\n          sublayer_provider = @config.fetch(:ai, :sublayer, :provider, default: '').downcase\n          api_key_status = @config.ai_api_key(sublayer_provider) ? 'Set' : 'Not set'\n          puts \"  API Key: #{api_key_status}\"\n          puts \"  Embedding Model: #{@config.fetch(:ai, :embedding_model, default: 'Not set')}\"\n          puts ''\n\n          # AI Configuration - Ruby LLM\n          puts 'AI Configuration (Ruby LLM):'.colorize(:cyan)\n          ruby_llm_config = @config.ruby_llm_config\n          if ruby_llm_config.any?\n            ruby_llm_config.each do |key, value|\n              next if key.to_s.end_with?('_api_key')\n\n              puts \"  #{key}: #{value}\"\n            end\n            puts \"  Available API Keys: #{ruby_llm_config.keys.select do |k|\n              k.to_s.end_with?('_api_key')\n            end.join(', ')}\"\n          else\n            puts '  No Ruby LLM configuration found'\n          end\n          puts ''\n\n          # Editor Configuration\n          puts 'Editor Configuration:'.colorize(:cyan)\n          puts \"  Editor: #{@config.fetch(:blueprints, :editor, default: 'Not set')}\"\n          puts \"  Auto-save: #{@config.fetch(:blueprints, :auto_save_edits, default: 'Not set')}\"\n          puts ''\n\n          # Feature Flags\n          puts 'Feature Flags:'.colorize(:cyan)\n          puts \"  Auto-description: #{@config.fetch(:blueprints, :features, :auto_description,\n                                                    default: 'Not set')}\"\n          puts \"  Auto-categorization: #{@config.fetch(:blueprints, :features, :auto_categorize,\n                                                       default: 'Not set')}\"\n          puts \"  Improvement analysis: #{@config.fetch(:blueprints, :features, :improvement_analysis,\n                                                        default: 'Not set')}\"\n          puts ''\n\n          # Logger Configuration\n          puts 'Logger Configuration:'.colorize(:cyan)\n          puts \"  Level: #{@config.fetch(:logger, :level, default: 'Not set')}\"\n          puts \"  File logging: #{@config.fetch(:logger, :file_logging, default: 'Not set')}\"\n          puts \"  File path: #{@config.fetch(:logger, :file_path, default: 'Not set')}\"\n          puts ''\n\n          # Search Configuration\n          puts 'Search Configuration:'.colorize(:cyan)\n          puts \"  Default limit: #{@config.fetch(:blueprints, :search, :default_limit,\n                                                 default: 'Not set')}\"\n          puts \"  Semantic search: #{@config.fetch(:blueprints, :search, :semantic_search,\n                                                   default: 'Not set')}\"\n          puts ''\n\n          # Performance Configuration\n          puts 'Performance Configuration:'.colorize(:cyan)\n          puts \"  Batch size: #{@config.fetch(:blueprints, :performance, :batch_size,\n                                              default: 'Not set')}\"\n          puts \"  Connection pool size: #{@config.fetch(:blueprints, :performance, :connection_pool_size,\n                                                        default: 'Not set')}\"\n        else\n          BlueprintsCLI.logger.failure('No configuration found')\n          BlueprintsCLI.logger.tip(\"Run 'blueprint config setup' to create configuration\")\n        end\n\n        puts '=' * 60\n        puts ''\n\n        # Show environment variables\n        show_environment_variables\n\n        true\n      end\n\n      ##\n      # Runs an interactive setup process for configuration.\n      #\n      # Prompts the user for all necessary configuration values, such as database\n      # URL, AI provider/model, and editor preferences. It then saves the\n      # resulting configuration to the YAML file.\n      #\n      # @return [Boolean] Returns `true` if the configuration is saved\n      #   successfully, `false` otherwise.\n      def setup_configuration\n        BlueprintsCLI.logger.step('Blueprint Configuration Setup')\n        puts '=' * 50\n        puts ''\n\n        config = load_configuration || {}\n\n        # Database configuration\n        puts '📊 Database Configuration'.colorize(:cyan)\n        current_db = config.dig('database', 'url') || BlueprintsCLI.configuration.database_url\n        db_url = prompt_for_input('Database URL', current_db)\n\n        config['database'] = { 'url' => db_url }\n\n        # AI configuration\n        puts \"\\n🤖 AI Configuration\".colorize(:cyan)\n        current_provider = config.dig('ai', 'provider') || 'gemini'\n        provider = prompt_for_choice('AI Provider', %w[gemini openai], current_provider)\n\n        current_model = config.dig('ai',\n                                   'model') || (provider == 'gemini' ? 'text-embedding-004' : 'text-embedding-3-small')\n        model = prompt_for_input('AI Model', current_model)\n\n        puts '💡 Set API key via environment variable:'.colorize(:yellow)\n        puts '   export GEMINI_API_KEY=your_key_here' if provider == 'gemini'\n        puts '   export OPENAI_API_KEY=your_key_here' if provider == 'openai'\n\n        config['ai'] = {\n          'provider' => provider,\n          'model' => model\n        }\n\n        # Editor configuration\n        puts \"\\n✏️  Editor Configuration\".colorize(:cyan)\n        current_editor = @config.fetch(:blueprints, :editor,\n                                       default: ENV['EDITOR'] || ENV['VISUAL'] || 'vim')\n        editor = prompt_for_input('Preferred editor', current_editor)\n        @config.set(:blueprints, :editor, value: editor)\n\n        current_auto_save = @config.fetch(:blueprints, :auto_save_edits, default: false)\n        auto_save = prompt_for_boolean('Auto-save edits', current_auto_save)\n        @config.set(:blueprints, :auto_save_edits, value: auto_save)\n\n        # Feature flags\n        puts \"\\n🎛️  Feature Configuration\".colorize(:cyan)\n        current_auto_desc = @config.fetch(:blueprints, :features, :auto_description, default: true)\n        auto_desc = prompt_for_boolean('Auto-generate descriptions', current_auto_desc)\n        @config.set(:blueprints, :features, :auto_description, value: auto_desc)\n\n        current_auto_cat = @config.fetch(:blueprints, :features, :auto_categorize, default: true)\n        auto_cat = prompt_for_boolean('Auto-generate categories', current_auto_cat)\n        @config.set(:blueprints, :features, :auto_categorize, value: auto_cat)\n\n        current_improvement = @config.fetch(:blueprints, :features, :improvement_analysis,\n                                            default: true)\n        improvement = prompt_for_boolean('Enable AI improvement analysis', current_improvement)\n        @config.set(:blueprints, :features, :improvement_analysis, value: improvement)\n\n        # Logger configuration\n        puts \"\\n📝 Logger Configuration\".colorize(:cyan)\n        current_level = @config.fetch(:logger, :level, default: 'info')\n        log_level = prompt_for_choice('Log level', %w[debug info warn error fatal], current_level)\n        @config.set(:logger, :level, value: log_level)\n\n        current_file_logging = @config.fetch(:logger, :file_logging, default: false)\n        file_logging = prompt_for_boolean('Enable file logging', current_file_logging)\n        @config.set(:logger, :file_logging, value: file_logging)\n\n        if file_logging\n          current_file_path = @config.fetch(:logger, :file_path,\n                                            default: @config.send(:default_log_path))\n          file_path = prompt_for_input('Log file path', current_file_path)\n          @config.set(:logger, :file_path, value: file_path)\n        end\n\n        # Save configuration\n        puts \"\\n💾 Saving Configuration\".colorize(:blue)\n        save_success = @config.write(force: true, create: true)\n\n        if save_success\n          BlueprintsCLI.logger.success('Configuration saved successfully!',\n                                       file: @config.config_file_path)\n          BlueprintsCLI.logger.tip(\"Run 'blueprint config test' to validate the configuration\")\n        else\n          BlueprintsCLI.logger.failure('Failed to save configuration')\n        end\n\n        save_success\n      end\n\n      ##\n      # Tests the validity and connectivity of the current configuration.\n      #\n      # Validates configuration structure and tests connectivity to database,\n      # AI providers, and editor availability.\n      #\n      # @return [Boolean] Returns `true` if all tests pass, `false` otherwise.\n      def test_configuration\n        BlueprintsCLI.logger.step('Testing Blueprint Configuration')\n        puts '=' * 50\n\n        all_tests_passed = true\n\n        # Test configuration validation\n        puts \"\\n📋 Validating configuration structure...\".colorize(:cyan)\n        begin\n          @config.validate!\n          BlueprintsCLI.logger.success('Configuration structure is valid')\n        rescue BlueprintsCLI::Configuration::ValidationError => e\n          BlueprintsCLI.logger.failure(\"Configuration validation failed: #{e.message}\")\n          all_tests_passed = false\n        end\n\n        # Test database connection\n        puts \"\\n📊 Testing database connection...\".colorize(:cyan)\n        db_success = test_database_connection\n        all_tests_passed &&= db_success\n\n        # Test AI API connections\n        puts \"\\n🤖 Testing AI API connections...\".colorize(:cyan)\n        ai_success = test_ai_connections\n        all_tests_passed &&= ai_success\n\n        # Test editor\n        puts \"\\n✏️  Testing editor availability...\".colorize(:cyan)\n        editor_success = test_editor\n        all_tests_passed &&= editor_success\n\n        # Test logger configuration\n        puts \"\\n📝 Testing logger configuration...\".colorize(:cyan)\n        logger_success = test_logger_config\n        all_tests_passed &&= logger_success\n\n        puts \"\\n\" + ('=' * 50)\n        if all_tests_passed\n          BlueprintsCLI.logger.success('All configuration tests passed!')\n        else\n          BlueprintsCLI.logger.failure('Some configuration tests failed')\n          BlueprintsCLI.logger.tip(\"Run 'blueprint config setup' to fix issues\")\n        end\n\n        all_tests_passed\n      end\n\n      ##\n      # Deletes the configuration file, resetting to defaults.\n      #\n      # Prompts the user for confirmation before deleting the configuration file.\n      #\n      # @return [Boolean] Returns `true` if the file is deleted or if it didn't\n      #   exist initially. Returns `false` if the user cancels the operation.\n      def reset_configuration\n        config_file = @config.config_file_path\n\n        if config_file && File.exist?(config_file)\n          print '⚠️  This will delete the existing configuration. Continue? (y/N): '\n          response = STDIN.gets.chomp.downcase\n\n          if %w[y yes].include?(response)\n            File.delete(config_file)\n            BlueprintsCLI.logger.success('Configuration reset successfully')\n            BlueprintsCLI.logger.tip(\"Run 'blueprint config setup' to create new configuration\")\n            true\n          else\n            BlueprintsCLI.logger.warn('Reset cancelled')\n            false\n          end\n        else\n          BlueprintsCLI.logger.info('No configuration file found to reset')\n          true\n        end\n      end\n\n      ##\n      # Migrate existing configuration files to new format\n      #\n      # @return [Boolean] Returns `true` if migration succeeded\n      def migrate_configuration\n        BlueprintsCLI.logger.step('Migrating Configuration Files')\n        puts '=' * 50\n        puts ''\n\n        puts 'ℹ️  Migration is no longer needed - using unified configuration system'\n\n        true\n      end\n\n      ##\n      # Displays help text for the configuration command.\n      # @return [nil]\n      def show_config_help\n        puts <<~HELP\n          Blueprint Configuration Commands:\n\n          blueprint config show      Show current configuration\n          blueprint config setup     Interactive configuration setup#{'  '}\n          blueprint config test      Test configuration connectivity and validation\n          blueprint config migrate   Migrate old configuration files to new format\n          blueprint config reset     Reset configuration to defaults\n\n          Configuration is managed by TTY::Config and stored in:\n          #{@config.config_file_path || '~/.config/BlueprintsCLI/config.yml'}\n        HELP\n      end\n\n\n      ##\n      # Displays the status of relevant environment variables.\n      # @return [void]\n      def show_environment_variables\n        puts '🌍 Environment Variables:'.colorize(:blue)\n\n        env_vars = {\n          'GEMINI_API_KEY' => ENV.fetch('GEMINI_API_KEY', nil),\n          'GOOGLE_API_KEY' => ENV.fetch('GOOGLE_API_KEY', nil),\n          'OPENAI_API_KEY' => ENV.fetch('OPENAI_API_KEY', nil),\n          'ANTHROPIC_API_KEY' => ENV.fetch('ANTHROPIC_API_KEY', nil),\n          'DEEPSEEK_API_KEY' => ENV.fetch('DEEPSEEK_API_KEY', nil),\n          'BLUEPRINT_DATABASE_URL' => ENV.fetch('BLUEPRINT_DATABASE_URL', nil),\n          'DATABASE_URL' => ENV.fetch('DATABASE_URL', nil),\n          'BLUEPRINTS_DEBUG' => ENV.fetch('BLUEPRINTS_DEBUG', nil),\n          'DEBUG' => ENV.fetch('DEBUG', nil),\n          'EDITOR' => ENV.fetch('EDITOR', nil),\n          'VISUAL' => ENV.fetch('VISUAL', nil)\n        }\n\n        env_vars.each do |key, value|\n          status = if value\n                     key.include?('KEY') ? 'Set (hidden)' : value\n                   else\n                     'Not set'\n                   end\n          puts \"  #{key}: #{status}\"\n        end\n        puts ''\n      end\n\n      ##\n      # Tests the database connection using the URL from the configuration.\n      #\n      # @return [Boolean] `true` if the connection is successful, `false` otherwise.\n      def test_database_connection\n        require 'sequel'\n        db_url = @config.database_url\n\n        if db_url.nil? || db_url.empty?\n          BlueprintsCLI.logger.failure('No database URL configured')\n          return false\n        end\n\n        db = Sequel.connect(db_url)\n        db.test_connection\n        BlueprintsCLI.logger.success('Database connection successful')\n        true\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Database connection failed: #{e.message}\")\n        false\n      end\n\n      ##\n      # Tests the AI provider connections by checking for API keys.\n      #\n      # Tests both Sublayer and Ruby LLM configurations.\n      #\n      # @return [Boolean] `true` if at least one API key is found, `false` otherwise.\n      def test_ai_connections\n        success_count = 0\n        total_tests = 0\n\n        # Test Sublayer configuration\n        sublayer_provider = @config.fetch(:ai, :sublayer, :provider, default: '').downcase\n        unless sublayer_provider.empty?\n          total_tests += 1\n          api_key = @config.ai_api_key(sublayer_provider)\n          if api_key\n            BlueprintsCLI.logger.success(\"Sublayer AI API key found for #{sublayer_provider}\")\n            success_count += 1\n          else\n            BlueprintsCLI.logger.failure(\"Sublayer AI API key not found for #{sublayer_provider}\")\n          end\n        end\n\n        # Test Ruby LLM configuration\n        ruby_llm_config = @config.ruby_llm_config\n        api_keys = ruby_llm_config.select { |k, v| k.to_s.end_with?('_api_key') && v }\n\n        if api_keys.any?\n          api_keys.each do |key, _|\n            provider = key.to_s.gsub('_api_key', '')\n            BlueprintsCLI.logger.success(\"Ruby LLM API key found for #{provider}\")\n            success_count += 1\n            total_tests += 1\n          end\n        else\n          BlueprintsCLI.logger.warn('No Ruby LLM API keys configured')\n        end\n\n        if total_tests == 0\n          BlueprintsCLI.logger.warn('No AI providers configured')\n          false\n        else\n          success_count > 0\n        end\n      end\n\n      ##\n      # Tests if the configured editor is available in the system's PATH.\n      #\n      # @return [Boolean] `true` if the editor command is found, `false` otherwise.\n      def test_editor\n        editor = @config.fetch(:blueprints, :editor, default: 'vim')\n\n        if editor.nil? || editor.empty?\n          BlueprintsCLI.logger.failure('No editor configured')\n          return false\n        end\n\n        if system(\"which #{editor} > /dev/null 2>&1\")\n          BlueprintsCLI.logger.success(\"Editor '#{editor}' found\")\n          true\n        else\n          BlueprintsCLI.logger.failure(\"Editor '#{editor}' not found\")\n          false\n        end\n      end\n\n      ##\n      # Tests the logger configuration.\n      #\n      # @return [Boolean] `true` if logger config is valid, `false` otherwise.\n      def test_logger_config\n        level = @config.fetch(:logger, :level, default: 'info')\n        valid_levels = %w[debug info warn error fatal]\n\n        unless valid_levels.include?(level.to_s.downcase)\n          BlueprintsCLI.logger.failure(\"Invalid logger level: #{level}\")\n          return false\n        end\n\n        if @config.fetch(:logger, :file_logging, default: false)\n          file_path = @config.fetch(:logger, :file_path)\n          if file_path.nil? || file_path.empty?\n            BlueprintsCLI.logger.failure('File logging enabled but no file path configured')\n            return false\n          end\n\n          # Check if directory is writable\n          dir = File.dirname(File.expand_path(file_path))\n          unless File.directory?(dir) || File.writable?(File.dirname(dir))\n            BlueprintsCLI.logger.failure(\"Log directory not writable: #{dir}\")\n            return false\n          end\n        end\n\n        BlueprintsCLI.logger.success('Logger configuration is valid')\n        true\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Logger configuration test failed: #{e.message}\")\n        false\n      end\n\n      ##\n      # Prompts the user for text input via STDIN.\n      #\n      # @param prompt [String] The message to display to the user.\n      # @param default [String, nil] The default value to use if the user enters nothing.\n      # @return [String] The user's input or the default value.\n      def prompt_for_input(prompt, default = nil)\n        print \"#{prompt}\"\n        print \" [#{default}]\" if default\n        print ': '\n\n        input = STDIN.gets.chomp\n        input.empty? ? default : input\n      end\n\n      ##\n      # Prompts the user to select from a list of choices.\n      #\n      # @param prompt [String] The message to display to the user.\n      # @param choices [Array<String>] A list of available options.\n      # @param default [String, nil] The default choice if the user enters nothing.\n      # @return [String] The user's selection or the default value.\n      def prompt_for_choice(prompt, choices, default = nil)\n        puts \"#{prompt} (#{choices.join('/')})\"\n        print default ? \"[#{default}]: \" : ': '\n\n        input = STDIN.gets.chomp\n        input.empty? ? default : input\n      end\n\n      ##\n      # Prompts the user for a boolean (yes/no) response.\n      #\n      # @param prompt [String] The message to display to the user.\n      # @param default [Boolean, nil] The default value (`true`, `false`, or `nil`)\n      #   to use if the user enters nothing.\n      # @return [Boolean, nil] Returns `true` for 'y', `false` for 'n', or the\n      #   default value for any other input.\n      def prompt_for_boolean(prompt, default = nil)\n        default_text = case default\n                       when true then ' [Y/n]'\n                       when false then ' [y/N]'\n                       else ' [y/n]'\n                       end\n\n        print \"#{prompt}#{default_text}: \"\n        input = STDIN.gets.chomp.downcase\n\n        case input\n        when 'y', 'yes', 'true'\n          true\n        when 'n', 'no', 'false'\n          false\n        else\n          default\n        end\n      end\n\n      ##\n      # Masks the password portion of a database URL for safe display.\n      #\n      # @param url [String] The database URL to process.\n      # @return [String] The URL with the password replaced by '***'.\n      def mask_password(url)\n        return url unless url.include?(':') && url.include?('@')\n\n        url.gsub(/:[^:@]*@/, ':***@')\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "delete.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\n\nmodule BlueprintsCLI\n  module Actions\n    # Handles the deletion of blueprints from the system with interactive confirmation.\n    #\n    # This action provides both direct deletion through ID specification and\n    # interactive selection from available blueprints. It includes safety\n    # mechanisms like confirmation dialogs and code previews to prevent\n    # accidental deletions.\n    #\n    # @example Delete a blueprint by ID\n    #   action = BlueprintsCLI::Actions::Delete.new(id: 123)\n    #   action.call\n    #\n    # @example Interactive blueprint deletion\n    #   action = BlueprintsCLI::Actions::Delete.new\n    #   action.call # Will prompt for interactive selection\n    class Delete < Sublayer::Actions::Base\n      # Initializes a new Delete\n      #\n      # @param id [Integer, nil] The ID of the blueprint to delete (optional)\n      # @param force [Boolean] Whether to skip confirmation prompts (default: false)\n      def initialize(id: nil, force: false)\n        @id = id\n        @force = force\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      # Executes the blueprint deletion process\n      #\n      # When no ID is provided, initiates interactive selection. Shows\n      # blueprint details and requests confirmation before deletion unless\n      # force flag is true.\n      #\n      # @return [Boolean] true if deletion was successful, false otherwise\n      #\n      # @raise [StandardError] If there's an error during the deletion process\n      #\n      # @example Successful deletion\n      #   action = BlueprintsCLI::Actions::Delete.new(id: 123)\n      #   action.call # => true\n      #\n      # @example Failed deletion\n      #   action = BlueprintsCLI::Actions::Delete.new(id: 999)\n      #   action.call # => false (blueprint not found)\n      def call\n        # If no ID provided, show interactive selection\n        if @id.nil?\n          @id = select_blueprint_interactively\n          return false unless @id\n        end\n\n        # Fetch the blueprint to delete\n        blueprint = @db.get_blueprint(@id)\n        unless blueprint\n          BlueprintsCLI.logger.failure(\"Blueprint #{@id} not found\")\n          return false\n        end\n\n        # Show blueprint details and confirm deletion\n        return false if !@force && !confirm_deletion?(blueprint)\n\n        # Perform the deletion\n        BlueprintsCLI.logger.step('Deleting blueprint...')\n\n        if @db.delete_blueprint(@id)\n          BlueprintsCLI.logger.success(\"Blueprint '#{blueprint[:name]}' (ID: #{@id}) deleted successfully\")\n          true\n        else\n          BlueprintsCLI.logger.failure('Failed to delete blueprint')\n          false\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error deleting blueprint: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      # Presents an interactive menu to select a blueprint for deletion\n      #\n      # Displays a numbered list of available blueprints with their\n      # basic information and allows the user to select one by number.\n      #\n      # @return [Integer, nil] The ID of the selected blueprint or nil if cancelled\n      #\n      # @example\n      #   select_blueprint_interactively\n      #   # Shows menu and returns selected blueprint ID or nil\n      def select_blueprint_interactively\n        puts '🔍 Loading blueprints for selection...'.colorize(:blue)\n\n        blueprints = @db.list_blueprints(limit: 50)\n\n        if blueprints.empty?\n          puts '❌ No blueprints found'.colorize(:red)\n          return nil\n        end\n\n        puts \"\\nSelect a blueprint to delete:\"\n        puts '=' * 60\n\n        blueprints.each_with_index do |blueprint, index|\n          categories = blueprint[:categories].map { |c| c[:title] }.join(', ')\n          puts \"#{index + 1}. #{blueprint[:name]} (ID: #{blueprint[:id]})\"\n          puts \"   Description: #{blueprint[:description]}\"\n          puts \"   Categories: #{categories}\" unless categories.empty?\n          puts \"   Created: #{blueprint[:created_at]}\"\n          puts ''\n        end\n\n        print \"Enter the number of the blueprint to delete (1-#{blueprints.length}), or 'q' to quit: \"\n        response = $stdin.gets.chomp\n\n        if response.downcase == 'q'\n          puts '❌ Operation cancelled'.colorize(:yellow)\n          return nil\n        end\n\n        index = response.to_i - 1\n        if index >= 0 && index < blueprints.length\n          blueprints[index][:id]\n        else\n          puts '❌ Invalid selection'.colorize(:red)\n          nil\n        end\n      end\n\n      # Requests confirmation before deleting a blueprint\n      #\n      # Displays detailed information about the blueprint including a code preview\n      # and warns about the irreversible nature of the deletion.\n      #\n      # @param blueprint [Hash] The blueprint to be deleted\n      # @return [Boolean] true if deletion is confirmed, false otherwise\n      #\n      # @example\n      #   blueprint = { id: 123, name: \"Example\", code: \"puts 'hello'\" }\n      #   confirm_deletion?(blueprint)\n      #   # Shows confirmation dialog and returns true/false based on user input\n      def confirm_deletion?(blueprint)\n        categories = blueprint[:categories].map { |c| c[:title] }.join(', ')\n        # Show first few lines of code as preview\n        code_lines = blueprint[:code].lines\n        code_preview = code_lines.first(5).each_with_index.map do |line, i|\n          \"  #{i + 1}: #{line.chomp}\"\n        end.join(\"\\n\")\n        code_preview += \"\\n  ...\" if code_lines.length > 5\n\n        # Create content for the warning box\n        content = <<~CONTENT\n        ID: #{blueprint[:id]}\n        Name: #{blueprint[:name]}\n        Description: #{blueprint[:description]}\n        Categories: #{categories.empty? ? 'None' : categories}\n        Created: #{blueprint[:created_at]}\n        Updated: #{blueprint[:updated_at]}\n        Code length: #{blueprint[:code].length} characters\n\n        Code preview (first 5 lines):\n#{code_preview}\n\n        ⚠️  WARNING: This action cannot be undone!\n        The blueprint and all its metadata will be permanently deleted.\n        CONTENT\n\n        # Display the warning box with red border\n        warning_box = TTY::Box.frame(\n          content,\n          title: { top_left: '🗑️ Deletion Confirmation' },\n          style: { border: { fg: :red } },\n          padding: 1\n        )\n        puts \"\\n#{warning_box}\"\n\n        print 'Are you sure you want to delete this blueprint? (y/N): '\n        response = $stdin.gets.chomp.downcase\n\n        if %w[y yes].include?(response)\n          puts '✅ Deletion confirmed'.colorize(:green)\n          true\n        else\n          puts '❌ Deletion cancelled'.colorize(:yellow)\n          false\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "edit.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire 'tty-editor'\nrequire_relative '../ui/preview_boxes'\n\nmodule BlueprintsCLI\n  module Actions\n    # Facilitates the interactive editing of an existing blueprint.\n    #\n    # This action provides a complete workflow for modifying a blueprint's code.\n    # It fetches the blueprint by its ID, opens its code in the user's\n    # preferred command-line editor (e.g., vim, nano), and waits for changes.\n    #\n    # Upon saving, it confirms the changes with the user and then performs a\n    # \"delete-and-resubmit\" operation. This ensures that the modified code\n    # gets new embeddings and a fresh AI-generated description, keeping the\n    # search index up-to-date.\n    class Edit < Sublayer::Actions::Base\n      # Initializes the action with the ID of the blueprint to be edited.\n      #\n      # @param id [String, Integer] The unique identifier of the blueprint to edit.\n      def initialize(id:)\n        @id = id\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      # Executes the blueprint editing workflow.\n      #\n      # This method orchestrates the entire process:\n      # 1. Fetches the blueprint from the database.\n      # 2. Creates a temporary file with the blueprint's code.\n      # 3. Launches the user's configured editor to modify the file.\n      # 4. If changes are detected, it prompts the user for confirmation.\n      # 5. If confirmed, it deletes the original blueprint and creates a new one\n      #    with the modified code.\n      #\n      # @return [Boolean] Returns `true` if the edit was successful or if no\n      #   changes were made. Returns `false` if the blueprint is not found,\n      #   the editor fails, or the user cancels the operation.\n      def call\n        # Step 1: Fetch the current blueprint\n        blueprint = @db.get_blueprint(@id)\n        unless blueprint\n          BlueprintsCLI.logger.failure(\"Blueprint #{@id} not found\")\n          return false\n        end\n\n        puts \"✏️  Editing blueprint: #{blueprint[:name]}\".colorize(:blue)\n        puts \"Original description: #{blueprint[:description]}\"\n        if blueprint[:categories].any?\n          puts \"Categories: #{blueprint[:categories].map do |c|\n            c[:title]\n          end.join(', ')}\"\n        end\n\n        # Step 2: Open editor with current code\n        temp_file = create_temp_file(blueprint)\n\n        begin\n          # Step 3: Launch editor\n          editor_success = launch_editor(temp_file)\n          unless editor_success\n            BlueprintsCLI.logger.failure('Editor failed or was cancelled')\n            return false\n          end\n\n          # Step 4: Read modified content\n          modified_code = File.read(temp_file)\n\n          # Step 5: Check if content actually changed\n          if modified_code.strip == blueprint[:code].strip\n            puts 'ℹ️  No changes detected'.colorize(:blue)\n            return true\n          end\n\n          puts '✅ Changes detected'.colorize(:green)\n\n          # Step 6: Confirm the edit operation\n          unless confirm_edit_operation(blueprint, modified_code)\n            puts '❌ Edit operation cancelled'.colorize(:yellow)\n            return false\n          end\n\n          # Step 7: Execute delete-and-resubmit workflow\n          perform_delete_and_resubmit(blueprint, modified_code)\n        ensure\n          # Clean up temporary file\n          File.delete(temp_file) if File.exist?(temp_file)\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error during edit operation: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      # Creates a temporary file containing the blueprint's code.\n      #\n      # It uses `detect_file_extension` to give the file the appropriate\n      # extension, which helps editors with syntax highlighting.\n      #\n      # @param blueprint [Hash] The blueprint data hash.\n      # @return [String] The path to the created temporary file.\n      # @private\n      def create_temp_file(blueprint)\n        # Detect file extension based on code content\n        extension = detect_file_extension(blueprint[:code])\n\n        # Create safe filename\n        safe_name = blueprint[:name].gsub(/[^a-zA-Z0-9_-]/, '_').downcase\n        temp_file = Tempfile.new([\"blueprint_#{@id}_#{safe_name}\", extension])\n        temp_file.write(blueprint[:code])\n        temp_file.flush\n        temp_file.path\n      end\n\n      # Detects the appropriate file extension for a given code snippet.\n      #\n      # Uses simple regex matching to infer the programming language and\n      # returns a corresponding file extension. Defaults to '.txt'.\n      #\n      # @param code [String] The source code of the blueprint.\n      # @return [String] The inferred file extension (e.g., '.rb', '.js').\n      # @private\n      def detect_file_extension(code)\n        case code\n        when /class\\s+\\w+.*<.*ApplicationRecord/m, /def\\s+\\w+.*end/m, /require ['\"].*['\"]/m\n          '.rb'\n        when /function\\s+\\w+\\s*\\(/m, /const\\s+\\w+\\s*=/m, /import\\s+.*from/m\n          '.js'\n        when /def\\s+\\w+\\s*\\(/m, /import\\s+\\w+/m, /from\\s+\\w+\\s+import/m\n          '.py'\n        when /#include\\s*<.*>/m, /int\\s+main\\s*\\(/m\n          '.c'\n        when /public\\s+class\\s+\\w+/m, /import\\s+java\\./m\n          '.java'\n        when /fn\\s+\\w+\\s*\\(/m, /use\\s+std::/m\n          '.rs'\n        when /func\\s+\\w+\\s*\\(/m, /package\\s+main/m\n          '.go'\n        else\n          '.txt'\n        end\n      end\n\n      # Launches the configured system editor to open the temporary file.\n      #\n      # @param temp_file [String] The path to the file to be opened.\n      # @return [Boolean] The success status of the editor operation.\n      # @private\n      def launch_editor(temp_file)\n        # Get editor preference from config or environment\n        editor = get_editor_preference\n\n        puts \"🔧 Opening #{editor} with blueprint code...\".colorize(:cyan)\n        puts '💡 Save and exit when done editing'.colorize(:cyan)\n\n        # Launch editor safely using TTY::Editor\n        TTY::Editor.open(temp_file, command: editor)\n      end\n\n      # Determines the user's preferred editor using the unified configuration system.\n      #\n      # @return [String] The name of the editor command.\n      # @private\n      def get_editor_preference\n        BlueprintsCLI.configuration.fetch(:blueprints, :editor)\n      end\n\n      # Prompts the user to confirm the destructive edit operation.\n      #\n      # It displays a warning and a preview of the changes before asking for\n      # user input.\n      #\n      # @param original_blueprint [Hash] The original blueprint data.\n      # @param modified_code [String] The code after being edited by the user.\n      # @return [Boolean] `true` if the user confirms, `false` otherwise.\n      # @private\n      def confirm_edit_operation(original_blueprint, modified_code)\n        # Create content for the confirmation box\n        content = <<~CONTENT\n          Original blueprint: #{original_blueprint[:name]} (ID: #{@id})\n          Original code length: #{original_blueprint[:code].length} characters\n          Modified code length: #{modified_code.length} characters\n\n          ⚠️  WARNING: This will:\n             1. DELETE the existing blueprint (including embeddings)\n             2. CREATE a new blueprint with the modified code\n             3. Generate NEW embeddings for better search\n        CONTENT\n\n        # Display the confirmation box with yellow border\n        confirmation_box = TTY::Box.frame(\n          content,\n          title: { top_left: '🔄 Edit Confirmation' },\n          style: { border: { fg: :yellow } },\n          padding: 1\n        )\n        puts \"\\n#{confirmation_box}\"\n\n        # Show a preview of changes\n        show_change_preview(original_blueprint[:code], modified_code)\n\n        print 'Continue with edit operation? (y/N): '\n        response = $stdin.gets.chomp.downcase\n        %w[y yes].include?(response)\n      end\n\n      # Displays a simple preview of the code changes.\n      #\n      # Shows the first few lines of the original and modified code to give the\n      # user context for the changes they are about to confirm.\n      #\n      # @param original_code [String] The original, unmodified code.\n      # @param modified_code [String] The new, modified code.\n      # @return [void]\n      # @private\n      def show_change_preview(original_code, modified_code)\n        # Show first few lines to give context\n        original_lines = original_code.lines\n        modified_lines = modified_code.lines\n\n        # Build original code preview\n        original_preview = original_lines.first(5).each_with_index.map do |line, i|\n          \"#{i + 1}: #{line.chomp}\"\n        end.join(\"\\n\")\n        original_preview += \"\\n...\" if original_lines.length > 5\n\n        # Build modified code preview\n        modified_preview = modified_lines.first(5).each_with_index.map do |line, i|\n          \"#{i + 1}: #{line.chomp}\"\n        end.join(\"\\n\")\n        modified_preview += \"\\n...\" if modified_lines.length > 5\n\n        # Create side-by-side preview boxes with plain text (syntax highlighting removed)\n        original_box = UI::PreviewBoxes.code_box(\n          original_preview,\n          title: '📜 Original Code'\n        )\n\n        modified_box = UI::PreviewBoxes.code_box(\n          modified_preview,\n          title: '✏️ Modified Code'\n        )\n\n        # Display boxes side by side (simplified version)\n        puts original_box\n        puts modified_box\n\n        # Show line count change if applicable\n        if original_lines.length != modified_lines.length\n          change_info = TTY::Box.frame(\n            \"Line count changed: #{original_lines.length} → #{modified_lines.length}\",\n            title: { top_left: '📊 Changes Summary' },\n            style: { border: { fg: :yellow } },\n            padding: 1,\n            align: :center\n          )\n          puts change_info\n        end\n\n        puts ''\n      end\n\n      # Executes the core update logic by deleting the old blueprint and\n      # submitting a new one.\n      #\n      # This method reuses `Submit` to handle the creation of the\n      # new blueprint, ensuring consistency. It preserves the original name and\n      # categories but triggers AI regeneration of the description to match the\n      # new code.\n      #\n      # @param original_blueprint [Hash] The original blueprint data.\n      # @param modified_code [String] The new, modified code.\n      # @return [Boolean] `true` on success, `false` on failure.\n      # @private\n      def perform_delete_and_resubmit(original_blueprint, modified_code)\n        puts '🔄 Starting delete-and-resubmit workflow...'.colorize(:blue)\n\n        # Store original metadata for rollback\n        original_data = {\n          name: original_blueprint[:name],\n          description: original_blueprint[:description],\n          categories: original_blueprint[:categories].map { |c| c[:title] }\n        }\n\n        # Step 1: Delete the existing blueprint\n        puts '🗑️  Deleting original blueprint...'.colorize(:yellow)\n        delete_success = @db.delete_blueprint(@id)\n\n        unless delete_success\n          puts '❌ Failed to delete original blueprint. Aborting edit.'.colorize(:red)\n          return false\n        end\n\n        puts '✅ Original blueprint deleted'.colorize(:green)\n\n        # Step 2: Submit the modified code as a new blueprint\n        puts '📝 Creating new blueprint with modified code...'.colorize(:yellow)\n\n        submit_action = BlueprintsCLI::Actions::Submit.new(\n          code: modified_code,\n          name: original_data[:name], # Keep original name initially\n          description: nil, # Let AI regenerate description for modified code\n          categories: original_data[:categories], # Keep original categories initially\n          auto_describe: true,\n          auto_categorize: false # Keep original categories unless user wants new ones\n        )\n\n        new_blueprint_success = submit_action.call\n\n        if new_blueprint_success\n          puts '✅ Edit operation completed successfully!'.colorize(:green)\n          puts '💡 The blueprint now has fresh embeddings for improved search'.colorize(:cyan)\n          true\n        else\n          puts '❌ Failed to create new blueprint'.colorize(:red)\n          puts '⚠️  Original blueprint has been deleted and cannot be restored'.colorize(:red)\n          puts '💡 You may need to manually recreate the blueprint'.colorize(:yellow)\n          false\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "export.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Export handles the export of blueprints from the database to files.\n    #\n    # This action allows developers to export blueprints with or without metadata,\n    # automatically generating appropriate file paths and handling file conflicts.\n    #\n    # Example:\n    #   action = BlueprintsCLI::Actions::Export.new(id: 123, include_metadata: true)\n    #   action.call\n    class Export < Sublayer::Actions::Base\n      ##\n      # Initializes a new Export.\n      #\n      # @param id [Integer] The ID of the blueprint to export\n      # @param output_path [String, nil] The path where the blueprint should be exported.\n      #   If nil, a path will be automatically generated.\n      # @param include_metadata [Boolean] Whether to include blueprint metadata in the exported file\n      # @return [Export] a new instance of Export\n      #\n      # @example Exporting a blueprint with metadata\n      #   action = BlueprintsCLI::Actions::Export.new(\n      #     id: 123,\n      #     include_metadata: true\n      #   )\n      def initialize(id:, output_path: nil, include_metadata: false)\n        @id = id\n        @output_path = output_path\n        @include_metadata = include_metadata\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      ##\n      # Executes the blueprint export process.\n      #\n      # This method retrieves the blueprint from the database, generates an output path\n      # if one wasn't provided, checks for file conflicts, and exports the blueprint\n      # to the specified file.\n      #\n      # @return [Boolean] true if the export was successful, false otherwise\n      #\n      # @example Basic export\n      #   action = BlueprintsCLI::Actions::Export.new(id: 123)\n      #   action.call #=> true\n      def call\n        puts \"📤 Exporting blueprint #{@id}...\".colorize(:blue)\n\n        blueprint = @db.get_blueprint(@id)\n        unless blueprint\n          BlueprintsCLI.logger.failure(\"Blueprint #{@id} not found\")\n          return false\n        end\n\n        # Generate output path if not provided\n        @output_path ||= generate_output_path(blueprint)\n\n        # Check if file already exists\n        if File.exist?(@output_path) && !confirm_overwrite\n          puts '❌ Export cancelled'.colorize(:yellow)\n          return false\n        end\n\n        # Export the blueprint\n        export_success = export_blueprint(blueprint)\n\n        if export_success\n          puts \"✅ Blueprint exported to: #{@output_path}\".colorize(:green)\n          show_export_summary(blueprint)\n          true\n        else\n          puts '❌ Failed to export blueprint'.colorize(:red)\n          false\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error exporting blueprint: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      ##\n      # Generates a safe output path for the blueprint file.\n      #\n      # Creates a filename based on the blueprint name and ID, with an appropriate\n      # extension based on the code content. If the file already exists, appends\n      # a number to make it unique.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [String] A unique, safe file path for the blueprint\n      #\n      # @example Generating a path\n      #   generate_output_path(blueprint: {name: \"My Blueprint\", id: 123, code: \"def hello\\nend\"})\n      #   #=> \"my_blueprint_123.rb\"\n      def generate_output_path(blueprint)\n        # Create safe filename from blueprint name\n        safe_name = (blueprint[:name] || 'blueprint').gsub(/[^a-zA-Z0-9_-]/, '_').downcase\n        extension = detect_file_extension(blueprint[:code])\n\n        base_filename = \"#{safe_name}_#{@id}#{extension}\"\n\n        # Check if file exists and add number suffix if needed\n        counter = 1\n        output_path = base_filename\n\n        while File.exist?(output_path)\n          name_part = File.basename(base_filename, extension)\n          output_path = \"#{name_part}_#{counter}#{extension}\"\n          counter += 1\n        end\n\n        output_path\n      end\n\n      ##\n      # Detects the appropriate file extension based on the code content.\n      #\n      # Uses pattern matching to determine the programming language of the code\n      # and returns the appropriate file extension.\n      #\n      # @param code [String] The blueprint code content\n      # @return [String] The appropriate file extension\n      #\n      # @example Detecting Ruby code\n      #   detect_file_extension(\"def hello\\nend\") #=> \".rb\"\n      #\n      # @example Detecting JavaScript code\n      #   detect_file_extension(\"function hello() {\\n}\") #=> \".js\"\n      def detect_file_extension(code)\n        case code\n        when /class\\s+\\w+.*<.*ApplicationRecord/m, /def\\s+\\w+.*end/m, /require ['\"].*['\"]/m\n          '.rb'\n        when /function\\s+\\w+\\s*\\(/m, /const\\s+\\w+\\s*=/m, /import\\s+.*from/m\n          '.js'\n        when /def\\s+\\w+\\s*\\(/m, /import\\s+\\w+/m, /from\\s+\\w+\\s+import/m\n          '.py'\n        when /#include\\s*<.*>/m, /int\\s+main\\s*\\(/m\n          '.c'\n        when /public\\s+class\\s+\\w+/m, /import\\s+java\\./m\n          '.java'\n        when /fn\\s+\\w+\\s*\\(/m, /use\\s+std::/m\n          '.rs'\n        when /func\\s+\\w+\\s*\\(/m, /package\\s+main/m\n          '.go'\n        when /<\\?php/m, /namespace\\s+\\w+/m\n          '.php'\n        when /<!DOCTYPE html/mi, /<html/mi\n          '.html'\n        when /^#!/m\n          '' # Script files often have no extension\n        else\n          '.txt'\n        end\n      end\n\n      ##\n      # Prompts the user to confirm overwriting an existing file.\n      #\n      # @return [Boolean] true if the user confirms overwriting, false otherwise\n      #\n      # @example Confirming overwrite\n      #   confirm_overwrite #=> Prompts user and returns true if they respond \"y\" or \"yes\"\n      def confirm_overwrite\n        print \"⚠️  File '#{@output_path}' already exists. Overwrite? (y/N): \"\n        response = STDIN.gets.chomp.downcase\n        %w[y yes].include?(response)\n      end\n\n      ##\n      # Exports the blueprint content to a file.\n      #\n      # Creates the necessary directories and writes the blueprint content to the file.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [Boolean] true if the export was successful, false otherwise\n      #\n      # @example Exporting a blueprint\n      #   export_blueprint(blueprint: {id: 123, code: \"def hello\\nend\"}) #=> true\n      def export_blueprint(blueprint)\n        content = build_export_content(blueprint)\n\n        begin\n          # Ensure directory exists\n          dir = File.dirname(@output_path)\n          FileUtils.mkdir_p(dir) unless Dir.exist?(dir)\n\n          # Write the file\n          File.write(@output_path, content)\n          true\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Failed to write file: #{e.message}\")\n          false\n        end\n      end\n\n      ##\n      # Builds the content to be exported based on the include_metadata flag.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [String] The content to be exported\n      #\n      # @example Building content with metadata\n      #   build_export_content(blueprint: {id: 123, code: \"def hello\\nend\"}) #=> String with metadata\n      def build_export_content(blueprint)\n        if @include_metadata\n          build_content_with_metadata(blueprint)\n        else\n          blueprint[:code]\n        end\n      end\n\n      ##\n      # Builds the content with metadata as comments.\n      #\n      # Adds blueprint metadata as comments at the top of the file, using the\n      # appropriate comment style for the file type.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [String] The content with metadata\n      #\n      # @example Building content with metadata\n      #   build_content_with_metadata(blueprint: {id: 123, code: \"def hello\\nend\"})\n      #   #=> String with metadata comments followed by code\n      def build_content_with_metadata(blueprint)\n        content = []\n\n        # Add metadata as comments based on file type\n        comment_style = get_comment_style(@output_path)\n\n        content << format_comment('Blueprint Export', comment_style)\n        content << format_comment('=' * 50, comment_style)\n        content << format_comment(\"ID: #{blueprint[:id]}\", comment_style)\n        content << format_comment(\"Name: #{blueprint[:name]}\", comment_style)\n        content << format_comment(\"Description: #{blueprint[:description]}\", comment_style)\n\n        if blueprint[:categories] && blueprint[:categories].any?\n          category_names = blueprint[:categories].map { |cat| cat[:title] }\n          content << format_comment(\"Categories: #{category_names.join(', ')}\", comment_style)\n        end\n\n        content << format_comment(\"Exported: #{Time.now}\", comment_style)\n        content << format_comment('=' * 50, comment_style)\n        content << ''\n        content << blueprint[:code]\n\n        content.join(\"\\n\")\n      end\n\n      ##\n      # Determines the comment style based on the file extension.\n      #\n      # @param filename [String] The filename\n      # @return [String] The appropriate comment style\n      #\n      # @example Getting comment style for Ruby file\n      #   get_comment_style(\"example.rb\") #=> \"#\"\n      #\n      # @example Getting comment style for JavaScript file\n      #   get_comment_style(\"example.js\") #=> \"//\"\n      def get_comment_style(filename)\n        case File.extname(filename).downcase\n        when '.rb', '.py', '.sh'\n          '#'\n        when '.js', '.java', '.c', '.cpp', '.cs', '.go', '.rs', '.php'\n          '//'\n        when '.html', '.xml'\n          '<!--'\n        when '.css'\n          '/*'\n        else\n          '#'\n        end\n      end\n\n      ##\n      # Formats a comment based on the comment style.\n      #\n      # @param text [String] The comment text\n      # @param style [String] The comment style\n      # @return [String] The formatted comment\n      #\n      # @example Formatting a Ruby comment\n      #   format_comment(\"Hello\", \"#\") #=> \"# Hello\"\n      #\n      # @example Formatting an HTML comment\n      #   format_comment(\"Hello\", \"<!--\") #=> \"<!-- Hello -->\"\n      def format_comment(text, style)\n        case style\n        when '<!--'\n          \"<!-- #{text} -->\"\n        when '/*'\n          \"/* #{text} */\"\n        else\n          \"#{style} #{text}\"\n        end\n      end\n\n      ##\n      # Displays a summary of the export.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [void]\n      #\n      # @example Showing export summary\n      #   show_export_summary(blueprint: {id: 123, name: \"Example\"})\n      #   #=> Outputs a summary to the console\n      def show_export_summary(blueprint)\n        puts \"\\n📋 Export Summary:\".colorize(:blue)\n        puts \"   Blueprint: #{blueprint[:name]} (ID: #{@id})\"\n        puts \"   File: #{@output_path}\"\n        puts \"   Size: #{File.size(@output_path)} bytes\"\n        puts \"   Format: #{@include_metadata ? 'Code with metadata' : 'Code only'}\"\n\n        if blueprint[:categories] && blueprint[:categories].any?\n          category_names = blueprint[:categories].map { |cat| cat[:title] }\n          puts \"   Categories: #{category_names.join(', ')}\"\n        end\n\n        puts ''\n        puts '💡 Tip: Use --include-metadata flag to export with blueprint information'.colorize(:cyan)\n        puts ''\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "generate.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-file'\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Generate handles natural language to code generation using existing blueprints\n    # as context via vector similarity search. It creates files in an output directory\n    # using tty-file for safe file operations.\n    #\n    # @example Basic usage:\n    #   action = Generate.new(\n    #     prompt: \"Create a Ruby web server using Sinatra\",\n    #     output_dir: \"./generated\",\n    #     limit: 5\n    #   )\n    #   action.call\n    class Generate < Sublayer::Actions::Base\n      ##\n      # Initializes a new Generate action with the provided prompt and options.\n      #\n      # @param prompt [String] The natural language description of code to generate\n      # @param output_dir [String] The output directory for generated files (default: \"./generated\")\n      # @param limit [Integer] The number of similar blueprints to use as context (default: 5)\n      # @param force [Boolean] Whether to overwrite existing files (default: false)\n      # @return [Generate] A new instance of Generate.\n      def initialize(prompt:, output_dir: './generated', limit: 5, force: false)\n        @prompt = prompt\n        @output_dir = File.expand_path(output_dir)\n        @limit = limit\n        @force = force\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      ##\n      # Executes the code generation process. This includes searching for relevant\n      # blueprints, generating code using AI, and creating output files.\n      #\n      # @return [Hash] Results including success status, generated files, and metadata\n      def call\n        BlueprintsCLI.logger.step('Starting code generation process...')\n\n        # Search for relevant blueprints using vector similarity\n        relevant_blueprints = search_relevant_blueprints\n\n        if relevant_blueprints.empty?\n          BlueprintsCLI.logger.warn('No relevant blueprints found for context')\n          return { success: false, error: 'No relevant blueprints found' }\n        end\n\n        BlueprintsCLI.logger.info(\"Found #{relevant_blueprints.length} relevant blueprints for context\")\n\n        # Generate code using AI with blueprint context\n        generation_result = generate_code_with_context(relevant_blueprints)\n\n        return generation_result unless generation_result[:success]\n\n        # Create output files\n        file_results = create_output_files(generation_result[:files])\n\n        {\n          success: true,\n          prompt: @prompt,\n          output_dir: @output_dir,\n          relevant_blueprints: relevant_blueprints.map { |bp| bp[:id] },\n          generated_files: file_results,\n          metadata: generation_result[:metadata]\n        }\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error during code generation: #{e.message}\")\n        { success: false, error: e.message }\n      end\n\n      private\n\n      ##\n      # Searches for blueprints relevant to the generation prompt using vector similarity\n      #\n      # @return [Array<Hash>] Array of relevant blueprint records\n      def search_relevant_blueprints\n        BlueprintsCLI.logger.info('Searching for relevant blueprints...')\n\n        results = @db.search_blueprints(query: @prompt, limit: @limit)\n\n        results.each do |blueprint|\n          BlueprintsCLI.logger.debug(\"Found blueprint: #{blueprint[:name]} (distance: #{blueprint[:distance]})\")\n        end\n\n        results\n      end\n\n      # Generates code using AI with relevant blueprints as context\n      #\n      # @param relevant_blueprints [Array<Hash>] The blueprints to use as context\n      # @return [Hash] Generation result with files and metadata\n      def generate_code_with_context(relevant_blueprints)\n        BlueprintsCLI.logger.info('Generating code with AI...')\n\n        context = build_blueprint_context(relevant_blueprints)\n        generation_prompt = build_generation_prompt(context)\n\n        begin\n          generated_content = generate_with_ai(generation_prompt)\n          files = parse_generated_content(generated_content)\n\n          {\n            success: true,\n            files: files,\n            metadata: {\n              generation_prompt: generation_prompt,\n              context_blueprints: relevant_blueprints.length,\n              timestamp: Time.now\n            }\n          }\n        rescue RubyLLM::Error => e\n          BlueprintsCLI::Logger.ai_error(e)\n          { success: false, error: \"AI Generation Failed: #{e.message}\" }\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"An unexpected error occurred during AI generation: #{e.message}\")\n          { success: false, error: e.message }\n        end\n      end\n\n      ##\n      # Builds context string from relevant blueprints\n      #\n      # @param blueprints [Array<Hash>] The relevant blueprints\n      # @return [String] Formatted context for AI\n      def build_blueprint_context(blueprints)\n        context_parts = []\n\n        blueprints.each_with_index do |blueprint, index|\n          context_parts << <<~CONTEXT\n            ## Blueprint #{index + 1}: #{blueprint[:name] || 'Untitled'}\n            **Description:** #{blueprint[:description] || 'No description'}\n            **Categories:** #{blueprint[:categories]&.map { |c| c[:title] }&.join(', ') || 'None'}\n\n            **Code:**\n            ```\n            #{blueprint[:code]}\n            ```\n\n          CONTEXT\n        end\n\n        context_parts.join(\"\\n\")\n      end\n\n      ##\n      # Builds the generation prompt for AI\n      #\n      # @param context [String] The blueprint context\n      # @return [String] Complete prompt for AI generation\n      def build_generation_prompt(context)\n        <<~PROMPT\n          You are a code generation assistant. Based on the user's request and the provided blueprint examples, generate appropriate code files.\n\n          ## User Request:\n          #{@prompt}\n\n          ## Available Blueprint Examples:\n          #{context}\n\n          ## Instructions:\n          1. Analyze the user's request and the provided blueprint examples\n          2. Generate appropriate code that fulfills the user's request\n          3. Use patterns and approaches from the relevant blueprints where applicable\n          4. Format your response as multiple files if needed\n          5. Include proper file headers, comments, and documentation\n          6. Suggest appropriate file names and extensions\n\n          ## Response Format:\n          Please structure your response as follows:\n\n          FILE: filename.ext\n          ```language\n          [file content here]\n          ```\n\n          FILE: another_file.ext\n          ```language\n          [another file content here]\n          ```\n\n          Provide complete, working code that addresses the user's request.\n        PROMPT\n      end\n\n      ##\n      # Parses generated content to extract individual files\n      #\n      # @param content [String] The AI-generated content\n      # @return [Array<Hash>] Array of file specifications\n      def parse_generated_content(content)\n        files = []\n        current_file = nil\n        current_content = []\n        in_code_block = false\n\n        content.lines.each do |line|\n          line = line.chomp\n\n          if line.start_with?('FILE: ')\n            # Save previous file if exists\n            if current_file\n              files << {\n                name: current_file,\n                content: current_content.join(\"\\n\"),\n                language: detect_language(current_file)\n              }\n            end\n\n            # Start new file\n            current_file = line.sub('FILE: ', '').strip\n            current_content = []\n            in_code_block = false\n          elsif line.start_with?('```')\n            in_code_block = !in_code_block\n          elsif in_code_block && current_file\n            current_content << line\n          end\n        end\n\n        # Save last file\n        if current_file\n          files << {\n            name: current_file,\n            content: current_content.join(\"\\n\"),\n            language: detect_language(current_file)\n          }\n        end\n\n        # If no files were parsed, treat the entire content as a single file\n        if files.empty?\n          files << {\n            name: guess_filename_from_prompt,\n            content: content,\n            language: 'text'\n          }\n        end\n\n        files\n      end\n\n      ##\n      # Detects programming language from filename\n      #\n      # @param filename [String] The filename\n      # @return [String] The detected language\n      def detect_language(filename)\n        ext = File.extname(filename).downcase\n\n        case ext\n        when '.rb' then 'ruby'\n        when '.py' then 'python'\n        when '.js' then 'javascript'\n        when '.ts' then 'typescript'\n        when '.java' then 'java'\n        when '.cpp', '.cc', '.cxx' then 'cpp'\n        when '.c' then 'c'\n        when '.go' then 'go'\n        when '.rs' then 'rust'\n        when '.php' then 'php'\n        when '.sh' then 'bash'\n        when '.sql' then 'sql'\n        when '.html' then 'html'\n        when '.css' then 'css'\n        when '.json' then 'json'\n        when '.yaml', '.yml' then 'yaml'\n        when '.xml' then 'xml'\n        when '.md' then 'markdown'\n        else 'text'\n        end\n      end\n\n      ##\n      # Guesses a filename from the prompt when no files are parsed\n      #\n      # @return [String] A default filename\n      def guess_filename_from_prompt\n        # Simple heuristic to guess file extension from prompt\n        prompt_lower = @prompt.downcase\n\n        if prompt_lower.include?('ruby') || prompt_lower.include?('.rb')\n          'generated_code.rb'\n        elsif prompt_lower.include?('python') || prompt_lower.include?('.py')\n          'generated_code.py'\n        elsif prompt_lower.include?('javascript') || prompt_lower.include?('.js')\n          'generated_code.js'\n        elsif prompt_lower.include?('typescript') || prompt_lower.include?('.ts')\n          'generated_code.ts'\n        elsif prompt_lower.include?('java')\n          'GeneratedCode.java'\n        elsif prompt_lower.include?('html')\n          'generated.html'\n        elsif prompt_lower.include?('css')\n          'generated.css'\n        else\n          'generated_code.txt'\n        end\n      end\n\n      ##\n      # Generates content using AI via RubyLLM\n      #\n      # @param prompt [String] The generation prompt\n      # @return [String] The generated content\n      def generate_with_ai(prompt)\n        require 'ruby_llm'\n\n        BlueprintsCLI.logger.debug(\"Starting AI generation with prompt length: #{prompt.length}\")\n\n        BlueprintsCLI.logger.debug('Creating configuration...')\n        config = BlueprintsCLI::Configuration.new\n        BlueprintsCLI.logger.debug('Configuration created successfully')\n\n        # Get AI configuration\n        BlueprintsCLI.logger.debug('Fetching AI provider...')\n        provider = config.fetch(:ai, :provider) || 'gemini'\n        BlueprintsCLI.logger.debug(\"Provider: #{provider}\")\n\n        BlueprintsCLI.logger.debug('Fetching AI model...')\n        model = config.fetch(:ai, :model) || 'gemini-2.0-flash'\n        BlueprintsCLI.logger.debug(\"Model: #{model}\")\n\n        BlueprintsCLI.logger.debug('Fetching API key...')\n        api_key = config.ai_api_key(provider)\n        BlueprintsCLI.logger.debug(\"API key present: #{!api_key.nil? && !api_key.empty?}\")\n\n        unless api_key\n          raise RubyLLM::ConfigurationError,\n                \"No API key found for #{provider}. Please configure your AI settings.\"\n        end\n\n        # Create RubyLLM client\n        llm_config = {\n          provider: provider.to_sym,\n          model: model,\n          api_key: api_key\n        }\n        BlueprintsCLI.logger.debug(\"LLM config prepared: #{llm_config.keys}\")\n\n        BlueprintsCLI.logger.debug('Creating RubyLLM chat client...')\n        chat = RubyLLM::Chat.new(model: llm_config[:model])\n        BlueprintsCLI.logger.debug('RubyLLM chat client created successfully')\n\n        # Generate content\n        BlueprintsCLI.logger.debug('Calling completion method...')\n        response = chat.with_temperature(0.3).ask(prompt)\n\n        chat.on_end_message do |message|\n          BlueprintsCLI.logger.debug('Completion method returned successfully')\n          # NOTE: message might be nil if an error occurred during the request\n          BlueprintsCLI.logger.debug(\"Used #{message.input_tokens + message.output_tokens} tokens\") if message&.output_tokens\n        end\n\n        BlueprintsCLI.logger.debug('Extracting content from response...')\n        content = response.content\n        BlueprintsCLI.logger.debug(\"Content extracted successfully, length: #{content.length}\")\n\n        content\n      end\n\n      ##\n      # Creates output files using tty-file\n      #\n      # @param files [Array<Hash>] The files to create\n      # @return [Array<Hash>] Results of file creation\n      def create_output_files(files)\n        BlueprintsCLI.logger.info(\"Creating #{files.length} output files in #{@output_dir}\")\n\n        file_results = []\n\n        files.each do |file_spec|\n          file_path = File.join(@output_dir, file_spec[:name])\n\n          begin\n            TTY::File.create_file(\n              file_path,\n              file_spec[:content],\n              force: @force,\n              verbose: true,\n              color: :green\n            )\n\n            file_results << {\n              name: file_spec[:name],\n              path: file_path,\n              success: true,\n              language: file_spec[:language]\n            }\n\n            BlueprintsCLI.logger.success(\"Created file: #{file_path}\")\n          rescue StandardError => e\n            file_results << {\n              name: file_spec[:name],\n              path: file_path,\n              success: false,\n              error: e.message\n            }\n\n            BlueprintsCLI.logger.failure(\"Failed to create file #{file_path}: #{e.message}\")\n          end\n        end\n\n        file_results\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "list.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire 'tty-cursor'\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Action class for listing and interacting with blueprints in the system.\n    #\n    # This class provides functionality to fetch, display, and interact with blueprints\n    # from the database. It supports multiple display formats and an interactive\n    # browsing mode for enhanced user experience.\n    #\n    # @example Basic usage (non-interactive table format)\n    #   BlueprintsCLI::Actions::List.new.call\n    #\n    # @example Interactive mode with summary format\n    #   BlueprintsCLI::Actions::List.new(\n    #     format: :summary,\n    #     interactive: true\n    #   ).call\n    class List < Sublayer::Actions::Base\n      ##\n      # Initializes a new List instance.\n      #\n      # @param format [Symbol] The display format for blueprints. Can be:\n      #   :table (default) - displays blueprints in a formatted table\n      #   :summary - shows a summary of blueprints with category statistics\n      #   :json - outputs blueprints as JSON\n      # @param interactive [Boolean] Whether to enable interactive mode with a browser interface\n      # @param limit [Integer] Maximum number of blueprints to fetch (default: 50)\n      # @return [List] a new instance of List\n      def initialize(format: :table, interactive: false, limit: 50)\n        @format = format\n        @interactive = interactive\n        @limit = limit\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      ##\n      # Executes the blueprint listing action.\n      #\n      # Fetches blueprints from the database and displays them according to the specified format.\n      # In interactive mode, provides a browser interface for navigating and managing blueprints.\n      #\n      # @return [Boolean] true if the operation succeeded, false if an error occurred\n      #\n      # @example Basic execution\n      #   action = BlueprintsCLI::Actions::List.new\n      #   action.call #=> true\n      def call\n        BlueprintsCLI.logger.step('Fetching blueprints...')\n\n        blueprints = @db.list_blueprints(limit: @limit)\n\n        if blueprints.empty?\n          BlueprintsCLI.logger.warn('No blueprints found')\n          return true\n        end\n\n        BlueprintsCLI.logger.success(\"Found #{blueprints.length} blueprints\")\n\n        if @interactive && tty_prompt_available?\n          interactive_blueprint_browser(blueprints)\n        else\n          display_blueprints(blueprints)\n        end\n\n        true\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error listing blueprints: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      ##\n      # Displays blueprints according to the specified format.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to display\n      # @return [void]\n      def display_blueprints(blueprints)\n        case @format\n        when :table\n          display_table(blueprints)\n        when :summary\n          display_summary(blueprints)\n        when :json\n          puts JSON.pretty_generate(blueprints)\n        else\n          display_table(blueprints)\n        end\n      end\n\n      ##\n      # Displays blueprints in a formatted table.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to display\n      # @return [void]\n      #\n      # @example Table format output\n      #   ========================================================================================================================\n      #   ID    Name                           Description                                          Categories\n      #   ========================================================================================================================\n      #   1     Sample Blueprint               This is a sample blueprint description               Category1, Category2\n      #   2     Another Blueprint              Description of another blueprint                       Category3\n      #   ========================================================================================================================\n      def display_table(blueprints)\n        # Display header using TTY::Box\n        header_box = TTY::Box.frame(\n          \"📚 Blueprint Collection\",\n          width: 120,\n          align: :center,\n          style: { border: { fg: :blue } }\n        )\n        puts \"\\n#{header_box}\"\n\n        printf \"%-5s %-30s %-50s %-25s\\n\", 'ID', 'Name', 'Description', 'Categories'\n        puts '=' * 120\n\n        blueprints.each do |blueprint|\n          name = truncate_text(blueprint[:name] || 'Untitled', 28)\n          description = truncate_text(blueprint[:description] || 'No description', 48)\n          categories = get_category_text(blueprint[:categories])\n\n          printf \"%-5s %-30s %-50s %-25s\\n\",\n                 blueprint[:id],\n                 name,\n                 description,\n                 categories\n        end\n        puts '=' * 120\n        puts ''\n      end\n\n      ##\n      # Displays a summary of the blueprint collection with statistics.\n      #\n      # Shows total count of blueprints, top categories, and most recent blueprints.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to summarize\n      # @return [void]\n      #\n      # @example Summary format output\n      #   📊 Blueprint Collection Summary\n      #   ===================================================\n      #   Total blueprints: 42\n      #\n      #   Top categories:\n      #     Web Development: 12 blueprints\n      #     Data Processing: 8 blueprints\n      #     Utilities: 5 blueprints\n      #\n      #   Most recent blueprints:\n      #     42: Latest Blueprint\n      #     41: Previous Blueprint\n      def display_summary(blueprints)\n        puts \"\\n📊 Blueprint Collection Summary\".colorize(:blue)\n        puts '=' * 50\n        puts \"Total blueprints: #{blueprints.length}\"\n\n        # Category analysis\n        all_categories = blueprints.flat_map { |b| b[:categories].map { |c| c[:name] } }\n        category_counts = all_categories.each_with_object(Hash.new(0)) do |cat, hash|\n          hash[cat] += 1\n        end\n\n        if category_counts.any?\n          puts \"\\nTop categories:\"\n          category_counts.sort_by { |_, count| -count }.first(5).each do |category, count|\n            puts \"  #{category}: #{count} blueprints\"\n          end\n        end\n\n        # Recent blueprints\n        puts \"\\nMost recent blueprints:\"\n        blueprints.first(5).each do |blueprint|\n          puts \"  #{blueprint[:id]}: #{blueprint[:name]}\"\n        end\n        puts ''\n      end\n\n      ##\n      # Launches an interactive browser for navigating blueprints.\n      #\n      # Provides a menu-driven interface for selecting, searching, and managing blueprints.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to browse\n      # @return [void]\n      def interactive_blueprint_browser(blueprints)\n        return unless tty_prompt_available?\n\n        prompt = TTY::Prompt.new\n        first_iteration = true\n\n        loop do\n          # Only clear screen on first iteration, add spacing on subsequent ones\n          if first_iteration\n            clear_screen_smart\n            first_iteration = false\n          else\n            add_spacing(2)\n          end\n          \n          display_browser_header(blueprints)\n          choices = build_browser_choices(blueprints)\n          selected = prompt.select('Select a blueprint or action:', choices, per_page: 15)\n\n          break if handle_browser_selection(selected, blueprints, prompt)\n        end\n      end\n\n      ##\n      # Displays the browser header with blueprint count.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints being browsed\n      # @return [void]\n      def display_browser_header(blueprints)\n        puts '=' * 80\n        puts '📚 Blueprint Browser'.colorize(:blue)\n        puts \"Found #{blueprints.length} blueprints\"\n        puts '=' * 80\n      end\n\n      ##\n      # Builds the choices array for the blueprint browser prompt.\n      #\n      # Combines blueprint choices with action options.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to browse\n      # @return [Array<Hash>] Complete choices array for the prompt\n      def build_browser_choices(blueprints)\n        choices = prepare_blueprint_choices(blueprints)\n\n        # Add action options\n        choices << { name: '🔍 Search blueprints'.colorize(:blue), value: :search }\n        choices << { name: '📊 Show summary'.colorize(:yellow), value: :summary }\n        choices << { name: '➕ Submit new blueprint'.colorize(:green), value: :submit }\n        choices << { name: '🚪 Exit'.colorize(:red), value: :exit }\n\n        choices\n      end\n\n      ##\n      # Handles the user's selection from the browser menu.\n      #\n      # Routes to appropriate handlers based on the selection type.\n      #\n      # @param selected [Hash, Symbol] The user's selection from the prompt\n      # @param blueprints [Array<Hash>] The collection of blueprints (passed by reference for updates)\n      # @param prompt [TTY::Prompt] The prompt instance for user interaction\n      # @return [Boolean] Returns true if the browser should exit, false to continue\n      def handle_browser_selection(selected, blueprints, prompt)\n        case selected\n        when Hash\n          # A blueprint was selected\n          handle_selected_blueprint(selected, prompt)\n          false\n        when :search\n          handle_search_action(prompt)\n          false\n        when :summary\n          display_summary(blueprints)\n          prompt.keypress('Press any key to continue...')\n          false\n        when :submit\n          submission_success = handle_submit_action(prompt)\n          # Refresh blueprints if submission was successful\n          if submission_success\n            blueprints.replace(refresh_blueprint_list)\n          end\n          false\n        when :exit\n          puts '👋 Goodbye!'.colorize(:green)\n          true\n        else\n          false\n        end\n      end\n\n      ##\n      # Refreshes the blueprint list from the database.\n      #\n      # @return [Array<Hash>] Updated collection of blueprints\n      def refresh_blueprint_list\n        @db.list_blueprints(limit: @limit)\n      end\n\n      ##\n      # Prepares blueprint choices for the interactive prompt.\n      #\n      # Formats blueprint information for display in the selection menu.\n      #\n      # @param blueprints [Array<Hash>] The collection of blueprints to format\n      # @return [Array<Hash>] Formatted choices for the prompt\n      def prepare_blueprint_choices(blueprints)\n        blueprints.map do |blueprint|\n          name = truncate_text(blueprint[:name] || 'Untitled', 40)\n          description = truncate_text(blueprint[:description] || 'No description', 50)\n          categories = get_category_text(blueprint[:categories], 20)\n\n          display_text = \"#{name.ljust(42)} | #{description.ljust(52)} | #{categories}\"\n\n          {\n            name: display_text,\n            value: blueprint\n          }\n        end\n      end\n\n      ##\n      # Handles actions for a selected blueprint in interactive mode.\n      #\n      # Provides options to view, edit, export, analyze, or copy the blueprint ID.\n      #\n      # @param blueprint [Hash] The selected blueprint\n      # @param prompt [TTY::Prompt] The prompt instance for user interaction\n      # @return [void]\n      def handle_selected_blueprint(blueprint, prompt)\n        actions = [\n          { name: '👁️  View details', value: :view },\n          { name: '✏️  Edit blueprint', value: :edit },\n          { name: '💾 Export code', value: :export },\n          { name: '🔍 View with AI analysis', value: :analyze },\n          { name: '📋 Copy ID', value: :copy_id },\n          { name: '↩️  Back to list', value: :back }\n        ]\n\n        action = prompt.select(\"What would you like to do with '#{blueprint[:name]}'?\", actions)\n\n        case action\n        when :view\n          BlueprintsCLI::Actions::View.new(\n            id: blueprint[:id],\n            format: :detailed\n          ).call\n          prompt.keypress('Press any key to continue...')\n        when :edit\n          BlueprintsCLI::Actions::Edit.new(\n            id: blueprint[:id]\n          ).call\n          prompt.keypress('Press any key to continue...')\n        when :export\n          filename = prompt.ask('💾 Export filename:', default: generate_export_filename(blueprint))\n          BlueprintsCLI::Actions::Export.new(\n            id: blueprint[:id],\n            output_path: filename\n          ).call\n          prompt.keypress('Press any key to continue...')\n        when :analyze\n          BlueprintsCLI::Actions::View.new(\n            id: blueprint[:id],\n            format: :detailed,\n            with_suggestions: true\n          ).call\n          prompt.keypress('Press any key to continue...')\n        when :copy_id\n          puts \"📋 Blueprint ID: #{blueprint[:id]}\".colorize(:green)\n          # Try to copy to clipboard if available\n          copy_to_clipboard(blueprint[:id].to_s)\n          prompt.keypress('Press any key to continue...')\n        when :back\n          # Return to blueprint list\n          nil\n        end\n      end\n\n      ##\n      # Handles the search action in interactive mode.\n      #\n      # Prompts the user for a search query and performs the search.\n      #\n      # @param prompt [TTY::Prompt] The prompt instance for user interaction\n      # @return [void]\n      def handle_search_action(prompt)\n        query = prompt.ask('🔍 Enter search query:', required: true)\n\n        BlueprintsCLI::Actions::Search.new(\n          query: query,\n          limit: 10\n        ).call\n\n        prompt.keypress('Press any key to continue...')\n      end\n\n      ##\n      # Handles the blueprint submission action in interactive mode.\n      #\n      # Provides options to submit a blueprint from a file or text input.\n      #\n      # @param prompt [TTY::Prompt] The prompt instance for user interaction\n      # @return [void]\n      def handle_submit_action(prompt)\n        submit_choice = prompt.select('Submit from:', [\n                                        { name: '📁 File', value: :file },\n                                        { name: '✏️  Text input', value: :text }\n                                      ])\n\n        success = false\n        if submit_choice == :file\n          file_path = prompt.ask('📁 Enter file path:')\n          if file_path && File.exist?(file_path)\n            code = File.read(file_path)\n            success = BlueprintsCLI::Actions::Submit.new(code: code).call\n          else\n            puts \"❌ File not found: #{file_path}\".colorize(:red)\n          end\n        else\n          code = prompt.multiline('✏️  Enter code (Ctrl+D to finish):')\n          if code && !code.join(\"\\n\").strip.empty?\n            success = BlueprintsCLI::Actions::Submit.new(code: code.join(\"\\n\")).call\n          end\n        end\n\n        prompt.keypress('Press any key to continue...')\n        \n        # Return success status to indicate if blueprints need to be refreshed\n        success\n      end\n\n      ##\n      # Generates a formatted string of category names from a blueprint's categories.\n      #\n      # @param categories [Array<Hash>, nil] The categories associated with a blueprint\n      # @param max_length [Integer] Maximum length for the resulting string (default: 23)\n      # @return [String] Formatted category text\n      #\n      # @example\n      #   get_category_text([{title: \"Web\"}, {title: \"Ruby\"}]) #=> \"Web, Ruby\"\n      def get_category_text(categories, max_length = 23)\n        return 'No categories' if categories.nil? || categories.empty?\n\n        category_names = categories.map { |cat| cat[:title] }\n        text = category_names.join(', ')\n        truncate_text(text, max_length)\n      end\n\n      ##\n      # Generates a filename for exporting a blueprint.\n      #\n      # Creates a filename based on the blueprint's name and ID, with an appropriate extension.\n      #\n      # @param blueprint [Hash] The blueprint to generate a filename for\n      # @return [String] Generated filename\n      #\n      # @example\n      #   generate_export_filename({name: \"Sample\", id: 42, code: \"class Sample...\"})\n      #   #=> \"sample_42.rb\"\n      def generate_export_filename(blueprint)\n        base_name = (blueprint[:name] || 'blueprint').gsub(/[^a-zA-Z0-9_-]/, '_').downcase\n        extension = detect_file_extension(blueprint[:code] || '')\n        \"#{base_name}_#{blueprint[:id]}#{extension}\"\n      end\n\n      ##\n      # Detects the appropriate file extension based on code content.\n      #\n      # @param code [String] The code content to analyze\n      # @return [String] Detected file extension\n      #\n      # @example\n      #   detect_file_extension(\"class Sample...\") #=> \".rb\"\n      #   detect_file_extension(\"function sample()\") #=> \".js\"\n      def detect_file_extension(code)\n        case code\n        when /class\\s+\\w+.*<.*ApplicationRecord/m, /def\\s+\\w+.*end/m\n          '.rb'\n        when /function\\s+\\w+\\s*\\(/m, /const\\s+\\w+\\s*=/m\n          '.js'\n        when /def\\s+\\w+\\s*\\(/m, /import\\s+\\w+/m\n          '.py'\n        when /#include\\s*<.*>/m, /int\\s+main\\s*\\(/m\n          '.c'\n        else\n          '.txt'\n        end\n      end\n\n      ##\n      # Attempts to copy text to the system clipboard.\n      #\n      # Tries multiple clipboard commands for cross-platform compatibility.\n      #\n      # @param text [String] The text to copy to clipboard\n      # @return [Boolean] true if copying succeeded, false otherwise\n      def copy_to_clipboard(text)\n        # Try different clipboard commands\n        commands = [\n          \"echo '#{text}' | pbcopy\", # macOS\n          \"echo '#{text}' | xclip -selection clipboard\", # Linux with xclip\n          \"echo '#{text}' | xsel -i -b\" # Linux with xsel\n        ]\n\n        commands.each do |cmd|\n          if system(cmd + ' 2>/dev/null')\n            puts '📋 Copied to clipboard!'.colorize(:green)\n            return true\n          end\n        end\n\n        puts '⚠️  Could not copy to clipboard (clipboard tool not available)'.colorize(:yellow)\n        false\n      end\n\n      ##\n      # Truncates text to a specified length, adding ellipsis if needed.\n      #\n      # @param text [String] The text to truncate\n      # @param length [Integer] Maximum length of the resulting string\n      # @return [String] Truncated text\n      #\n      # @example\n      #   truncate_text(\"This is a long text\", 10) #=> \"This is a...\"\n      def truncate_text(text, length)\n        return text if text.length <= length\n\n        text[0..length - 4] + '...'\n      end\n\n      ##\n      # Checks if TTY prompt is available for interactive mode.\n      #\n      # @return [Boolean] true if TTY::Prompt is defined and available\n      def tty_prompt_available?\n        defined?(TTY::Prompt)\n      end\n\n      ##\n      # Smart screen clearing that only clears when necessary\n      #\n      # @return [void]\n      def clear_screen_smart\n        print TTY::Cursor.clear_screen_down if defined?(TTY::Cursor)\n      end\n\n      ##\n      # Adds spacing without clearing the screen\n      #\n      # @param lines [Integer] number of lines to add (default: 2)\n      # @return [void]\n      def add_spacing(lines = 2)\n        puts \"\\n\" * lines\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "search.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Search provides search functionality for blueprints in the system.\n    # It supports both semantic vector-based search and traditional text search,\n    # allowing developers to find relevant blueprints based on their queries.\n    #\n    # This action is typically used when users need to locate specific blueprints\n    # by name, description, code content, or semantic similarity.\n    #\n    # @example Basic semantic search\n    #   action = Search.new(query: \"user authentication\")\n    #   action.call\n    #\n    # @example Text search with custom limit\n    #   action = Search.new(query: \"database connection\", semantic: false, limit: 5)\n    #   action.call\n    class Search < Sublayer::Actions::Base\n      ##\n      # Initializes a new Search with search parameters.\n      #\n      # @param [String] query The search term to look for in blueprints\n      # @param [Integer] limit The maximum number of results to return (default: 10)\n      # @param [Boolean] semantic Whether to use semantic search (default: true)\n      # @return [Search] A new instance of Search\n      def initialize(query:, limit: 10, semantic: true)\n        @query = query\n        @limit = limit\n        @semantic = semantic\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      ##\n      # Executes the blueprint search based on the configured parameters.\n      #\n      # This method coordinates the search process, displays results, and handles\n      # any errors that might occur during the search operation.\n      #\n      # @return [Boolean] true if the search completed successfully, false if an error occurred\n      def call\n        puts \"🔍 Searching for: '#{@query}'...\".colorize(:blue)\n\n        results = if @semantic\n                    semantic_search\n                  else\n                    text_search\n                  end\n\n        if results.empty?\n          puts \"📭 No blueprints found matching '#{@query}'\".colorize(:yellow)\n          return true\n        end\n\n        puts \"✅ Found #{results.length} matching blueprints\".colorize(:green)\n        display_search_results(results)\n\n        true\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error searching blueprints: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      ##\n      # Performs a semantic search using vector similarity.\n      #\n      # This method uses the database's vector similarity search capability\n      # to find blueprints that are semantically similar to the query.\n      #\n      # @return [Array<Hash>] An array of blueprint hashes with similarity scores\n      def semantic_search\n        # Use vector similarity search for semantic matching\n        @db.search_blueprints(query: @query, limit: @limit)\n      end\n\n      ##\n      # Performs a traditional text-based search across blueprint fields.\n      #\n      # This method searches for the query terms in blueprint names, descriptions,\n      # code content, and categories. It implements a simple relevance scoring\n      # system to rank results.\n      #\n      # @return [Array<Hash>] An array of matching blueprint hashes\n      def text_search\n        # Fallback to simple text search in name, description, and code\n        blueprints = @db.list_blueprints(limit: 1000) # Get more for filtering\n\n        query_words = @query.downcase.split(/\\s+/)\n\n        results = blueprints.select do |blueprint|\n          searchable_text = [\n            blueprint[:name],\n            blueprint[:description],\n            blueprint[:code],\n            blueprint[:categories].map { |c| c[:title] }.join(' ')\n          ].compact.join(' ').downcase\n\n          # Check if all query words are present\n          query_words.all? { |word| searchable_text.include?(word) }\n        end\n\n        # Sort by relevance (simple scoring)\n        results.sort_by do |blueprint|\n          score = calculate_text_relevance(blueprint, query_words)\n          -score # Negative for descending order\n        end.first(@limit)\n      end\n\n      ##\n      # Calculates a relevance score for a blueprint based on query word matches.\n      #\n      # This method assigns different weights to matches in different fields:\n      # - Name matches: 10 points\n      # - Description matches: 5 points\n      # - Code matches: 1 point\n      #\n      # @param [Hash] blueprint The blueprint to score\n      # @param [Array<String>] query_words The query terms to match against\n      # @return [Integer] The calculated relevance score\n      def calculate_text_relevance(blueprint, query_words)\n        score = 0\n\n        # Higher weight for matches in name and description\n        name_text = (blueprint[:name] || '').downcase\n        desc_text = (blueprint[:description] || '').downcase\n        code_text = blueprint[:code].downcase\n\n        query_words.each do |word|\n          score += 10 if name_text.include?(word)\n          score += 5 if desc_text.include?(word)\n          score += 1 if code_text.include?(word)\n        end\n\n        score\n      end\n\n      ##\n      # Displays the search results in a formatted table.\n      #\n      # This method handles both semantic search results (with similarity scores)\n      # and traditional text search results, formatting them appropriately\n      # for console display.\n      #\n      # @param [Array<Hash>] results The search results to display\n      def display_search_results(results)\n        # Display header using TTY::Box\n        header_box = TTY::Box.frame(\n          \"🔍 Search Results for: '#{@query}'\",\n          width: 120,\n          align: :center,\n          style: { border: { fg: :blue } }\n        )\n        puts \"\\n#{header_box}\"\n\n        if @semantic && results.first && results.first.key?(:distance)\n          # Show similarity scores for semantic search\n          printf \"%-5s %-30s %-40s %-20s %-10s\\n\", 'ID', 'Name', 'Description', 'Categories',\n                 'Score'\n          puts '-' * 120\n\n          results.each do |blueprint|\n            name = truncate_text(blueprint[:name] || 'Untitled', 28)\n            description = truncate_text(blueprint[:description] || 'No description', 38)\n            categories = get_category_text(blueprint[:categories])\n            similarity = calculate_similarity_percentage(blueprint[:distance])\n\n            printf \"%-5s %-30s %-40s %-20s %-10s\\n\",\n                   blueprint[:id],\n                   name,\n                   description,\n                   categories,\n                   \"#{similarity}%\"\n          end\n        else\n          # Standard display for text search\n          printf \"%-5s %-35s %-50s %-25s\\n\", 'ID', 'Name', 'Description', 'Categories'\n          puts '-' * 120\n\n          results.each do |blueprint|\n            name = truncate_text(blueprint[:name] || 'Untitled', 33)\n            description = truncate_text(blueprint[:description] || 'No description', 48)\n            categories = get_category_text(blueprint[:categories])\n\n            printf \"%-5s %-35s %-50s %-25s\\n\",\n                   blueprint[:id],\n                   name,\n                   description,\n                   categories\n          end\n        end\n\n        puts '=' * 120\n        puts ''\n\n        # Show usage hints\n        show_usage_hints(results)\n      end\n\n      ##\n      # Converts a similarity distance to a percentage.\n      #\n      # Lower distance values indicate higher similarity, so this method\n      # converts the distance to a more intuitive percentage score.\n      #\n      # @param [Float] distance The similarity distance from the semantic search\n      # @return [Float] The similarity percentage (0-100)\n      def calculate_similarity_percentage(distance)\n        # Convert distance to percentage (lower distance = higher similarity)\n        # This is a rough approximation - adjust based on your embedding space\n        similarity = [100 - (distance * 100), 0].max\n        similarity.round(1)\n      end\n\n      ##\n      # Formats category information for display.\n      #\n      # @param [Array<Hash>, nil] categories The categories to format\n      # @return [String] A formatted string of category names\n      def get_category_text(categories)\n        return 'None' if categories.nil? || categories.empty?\n\n        category_names = categories.map { |cat| cat[:title] }\n        text = category_names.join(', ')\n        truncate_text(text, 23)\n      end\n\n      ##\n      # Displays helpful usage hints after search results.\n      #\n      # @param [Array<Hash>] results The search results that were displayed\n      def show_usage_hints(results)\n        puts '💡 Next steps:'.colorize(:cyan)\n        puts '   blueprint view <id>           View full blueprint details'\n        puts '   blueprint view <id> --analyze Get AI analysis and suggestions'\n        puts '   blueprint edit <id>           Edit a blueprint'\n        puts '   blueprint export <id>         Export blueprint code'\n\n        if results.any?\n          sample_id = results.first[:id]\n          puts \"\\n📋 Example: blueprint view #{sample_id}\".colorize(:yellow)\n        end\n        puts ''\n      end\n\n      ##\n      # Truncates text to fit within a specified length.\n      #\n      # @param [String] text The text to truncate\n      # @param [Integer] length The maximum length of the text\n      # @return [String] The truncated text with ellipsis if shortened\n      def truncate_text(text, length)\n        return text if text.length <= length\n\n        text[0..length - 4] + '...'\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "submit.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Submit handles the submission of blueprints to the database.\n    # It provides functionality to generate missing metadata, validate the blueprint data,\n    # and store the blueprint in the database. This class is useful for automating the\n    # process of submitting blueprints with minimal initial information, as it can\n    # auto-generate names, descriptions, and categories.\n    #\n    # @example Basic usage:\n    #   action = Submit.new(code: \"puts 'Hello, World!'\")\n    #   action.call\n    class Submit < Sublayer::Actions::Base\n      ##\n      # Initializes a new Submit with the provided code and optional metadata.\n      #\n      # @param code [String] The code content of the blueprint. This is the only required parameter.\n      # @param name [String, nil] The name of the blueprint. If not provided, it will be auto-generated.\n      # @param description [String, nil] The description of the blueprint. If not provided and auto_describe is true, it will be auto-generated.\n      # @param categories [Array, nil] The categories of the blueprint. If not provided and auto_categorize is true, they will be auto-generated.\n      # @param filename [String, nil] The original filename for type detection.\n      # @param auto_describe [Boolean] Whether to auto-generate the description if not provided. Defaults to true.\n      # @param auto_categorize [Boolean] Whether to auto-generate the categories if not provided. Defaults to true.\n      # @return [Submit] A new instance of Submit.\n      def initialize(code:, name: nil, description: nil, categories: nil, filename: nil,\n                     auto_describe: true, auto_categorize: true)\n        @code = code\n        @name = name\n        @description = description\n        @categories = categories || []\n        @filename = filename\n        @auto_describe = auto_describe\n        @auto_categorize = auto_categorize\n        @db = BlueprintsCLI::BlueprintDatabase.new\n\n        # Detect types based on filename using Blueprint model method\n        @types = Blueprint.detect_types(@filename)\n      end\n\n      ##\n      # Executes the blueprint submission process. This includes generating missing metadata,\n      # validating the blueprint data, and creating the blueprint in the database.\n      #\n      # @return [Boolean] true if the blueprint was successfully created, false otherwise.\n      # @raise [StandardError] If an error occurs during the submission process.\n      def call\n        BlueprintsCLI.logger.step('Processing blueprint submission...')\n\n        # Generate missing metadata using AI\n        generate_missing_metadata\n\n        # Validate required fields\n        return false unless validate_blueprint_data\n\n        # Create the blueprint in database\n        blueprint = @db.create_blueprint(\n          code: @code,\n          name: @name,\n          description: @description,\n          categories: @categories,\n          language: @types[:language],\n          file_type: @types[:file_type],\n          blueprint_type: @types[:blueprint_type],\n          parser_type: @types[:parser_type]\n        )\n\n        if blueprint\n          BlueprintsCLI.logger.success('Blueprint created successfully!')\n          display_blueprint_summary(blueprint)\n          true\n        else\n          BlueprintsCLI.logger.failure('Failed to create blueprint')\n          false\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error submitting blueprint: #{e.message}\")\n        BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      ##\n      # Generates missing metadata for the blueprint, including name, description, and categories.\n      #\n      # @return [void]\n      def generate_missing_metadata\n        # Generate name if not provided\n        if @name.nil? || @name.strip.empty?\n          BlueprintsCLI.logger.info('Generating blueprint name...')\n          @name = BlueprintsCLI::Generators::Name.new(\n            code: @code,\n            description: @description\n          ).generate\n          puts \"   Generated name: #{@name}\".colorize(:cyan)\n        end\n\n        # Generate description if not provided and auto_describe is enabled\n        if (@description.nil? || @description.strip.empty?) && @auto_describe\n          puts '📖 Generating blueprint description...'.colorize(:yellow)\n          @description = BlueprintsCLI::Generators::Description.new(\n            code: @code\n          ).generate\n          puts \"   Generated description: #{truncate_text(@description, 80)}\".colorize(:cyan)\n        end\n\n        # Generate categories if not provided and auto_categorize is enabled\n        return unless @categories.empty? && @auto_categorize\n\n        puts '🏷️  Generating blueprint categories...'.colorize(:yellow)\n        @categories = BlueprintsCLI::Generators::Category.new(\n          code: @code,\n          description: @description\n        ).generate\n        puts \"   Generated categories: #{@categories.join(', ')}\".colorize(:cyan)\n      end\n\n      ##\n      # Validates the blueprint data to ensure all required fields are present and valid.\n      #\n      # @return [Boolean] true if the blueprint data is valid, false otherwise.\n      def validate_blueprint_data\n        errors = []\n\n        errors << 'Code cannot be empty' if @code.nil? || @code.strip.empty?\n\n        errors << 'Name is required (auto-generation failed)' if @name.nil? || @name.strip.empty?\n\n        if @description.nil? || @description.strip.empty?\n          if @auto_describe\n            errors << 'Description generation failed'\n          else\n            puts '⚠️  Warning: No description provided'.colorize(:yellow)\n          end\n        end\n\n        if errors.any?\n          BlueprintsCLI.logger.failure('Validation errors:')\n          errors.each { |error| BlueprintsCLI.logger.error(\"   - #{error}\") }\n          return false\n        end\n\n        true\n      end\n\n      ##\n      # Displays a summary of the created blueprint.\n      #\n      # @param blueprint [Hash] The blueprint data to display.\n      # @return [void]\n      def display_blueprint_summary(blueprint)\n        puts \"\\n\" + '=' * 60\n        puts '📋 Blueprint Summary'.colorize(:blue)\n        puts '=' * 60\n        puts \"ID: #{blueprint[:id]}\"\n        puts \"Name: #{blueprint[:name]}\"\n        puts \"Description: #{blueprint[:description]}\"\n        puts \"Language: #{@types[:language]}\"\n        puts \"File Type: #{@types[:file_type]}\"\n        puts \"Blueprint Type: #{@types[:blueprint_type]}\"\n        puts \"Parser Type: #{@types[:parser_type]}\"\n\n        if blueprint[:categories] && blueprint[:categories].any?\n          category_names = blueprint[:categories].map { |cat| cat[:title] }\n          puts \"Categories: #{category_names.join(', ')}\"\n        end\n\n        puts \"Code length: #{@code.length} characters\"\n        puts \"Created: #{blueprint[:created_at]}\"\n        puts '=' * 60\n        puts ''\n      end\n\n      ##\n      # Truncates the given text to the specified length.\n      #\n      # @param text [String] The text to truncate.\n      # @param length [Integer] The maximum length of the text.\n      # @return [String] The truncated text.\n      def truncate_text(text, length)\n        return text if text.length <= length\n\n        text[0..length - 4] + '...'\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "view.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire_relative '../ui/preview_boxes'\nrequire_relative '../ui/two_column_viewer'\nrequire_relative '../ui/cli_ui_viewer'\n\nmodule BlueprintsCLI\n  module Actions\n    ##\n    # Action class for viewing blueprint details with various output formats.\n    #\n    # This class provides functionality to fetch and display blueprints from the database\n    # with options for different output formats and AI-generated suggestions.\n    #\n    # Primary usage scenarios:\n    # - Viewing detailed blueprint information\n    # - Getting a quick summary of a blueprint\n    # - Retrieving just the code portion of a blueprint\n    # - Obtaining blueprint data in JSON format\n    # - Getting AI-powered suggestions for blueprint improvements\n    class View < Sublayer::Actions::Base\n      ##\n      # Initializes a new View instance.\n      #\n      # @param id [Integer] The ID of the blueprint to view\n      # @param format [Symbol] The output format (:detailed, :json, :code_only, or :summary)\n      # @param with_suggestions [Boolean] Whether to generate AI suggestions for the blueprint\n      # @return [View] A new instance of View\n      #\n      # @example Basic initialization\n      #   action = View.new(id: 123, format: :detailed)\n      #\n      # @example With AI suggestions\n      #   action = View.new(id: 123, format: :detailed, with_suggestions: true)\n      def initialize(id:, format: :detailed, with_suggestions: false)\n        @id = id\n        @format = format\n        @with_suggestions = with_suggestions\n        @db = BlueprintsCLI::BlueprintDatabase.new\n      end\n\n      ##\n      # Executes the blueprint viewing action.\n      #\n      # Fetches the blueprint from the database, optionally generates AI suggestions,\n      # and displays the blueprint according to the specified format.\n      #\n      # @return [Boolean] true if the operation succeeded, false otherwise\n      #\n      # @example Basic usage\n      #   action = View.new(id: 123)\n      #   action.call # => true\n      #\n      # @example With error handling\n      #   action = View.new(id: 999) # Non-existent ID\n      #   action.call # => false\n      def call\n        puts \"🔍 Fetching blueprint #{@id}...\".colorize(:blue)\n\n        blueprint = @db.get_blueprint(@id)\n        unless blueprint\n          BlueprintsCLI.logger.failure(\"Blueprint #{@id} not found\")\n          return false\n        end\n\n        # Generate AI suggestions if requested\n        if @with_suggestions\n          puts '🤖 Generating AI analysis...'.colorize(:yellow)\n          begin\n            blueprint[:ai_suggestions] = generate_suggestions(blueprint)\n          rescue StandardError => e\n            BlueprintsCLI.logger.warn(\"AI suggestions failed: #{e.message}\")\n            puts \"⚠️  AI analysis unavailable: #{e.message}\".colorize(:yellow)\n            blueprint[:ai_suggestions] = nil\n          end\n        end\n\n        case @format\n        when :detailed\n          display_detailed(blueprint)\n        when :interactive\n          display_interactive(blueprint)\n        when :json\n          puts JSON.pretty_generate(blueprint)\n        when :code_only\n          puts blueprint[:code]\n        when :summary\n          display_summary(blueprint)\n        end\n\n        true\n      rescue StandardError => e\n        BlueprintsCLI.logger.failure(\"Error viewing blueprint: #{e.message}\")\n        BlueprintsCLI.logger.error(\"Stack trace: #{e.backtrace.join(\"\\n\")}\")\n        false\n      end\n\n      private\n\n      ##\n      # Displays a detailed view of the blueprint.\n      #\n      # Uses a pager if available for better readability of long content.\n      #\n      # @param blueprint [Hash] The blueprint data to display\n      # @return [void]\n      #\n      # @example Internal usage\n      #   display_detailed(blueprint_data)\n      def display_detailed(blueprint)\n        content = build_detailed_content(blueprint)\n\n        if tty_pager_available?\n          TTY::Pager.page(content)\n        else\n          puts content\n        end\n      end\n\n      ##\n      # Displays an interactive view of the blueprint using CLI::UI.\n      #\n      # Shows metadata and details in organized sections with scrollable code,\n      # and a slash menu for actions like edit, preview improvements, generate docs.\n      #\n      # @param blueprint [Hash] The blueprint data to display\n      # @return [void]\n      #\n      # @example Internal usage\n      #   display_interactive(blueprint_data)\n      def display_interactive(blueprint)\n        viewer = BlueprintsCLI::UI::CLIUIViewer.new(\n          blueprint,\n          with_suggestions: @with_suggestions\n        )\n        viewer.display\n      end\n\n      ##\n      # Builds the detailed content for a blueprint.\n      #\n      # Constructs a comprehensive view of the blueprint including metadata,\n      # description, AI suggestions (if available), and the actual code.\n      #\n      # @param blueprint [Hash] The blueprint data to format\n      # @return [String] The formatted content ready for display\n      #\n      # @example Internal usage\n      #   content = build_detailed_content(blueprint_data)\n      def build_detailed_content(blueprint)\n        content_parts = []\n\n        # Metadata Box\n        metadata_content = build_metadata_content(blueprint)\n        metadata_box = TTY::Box.frame(\n          metadata_content,\n          title: { top_left: '📋 Blueprint Details' },\n          style: { border: { fg: :blue } },\n          padding: 1\n        )\n        content_parts << metadata_box\n\n        # Description Box\n        description_content = blueprint[:description] || 'No description available'\n        description_box = TTY::Box.frame(\n          description_content,\n          title: { top_left: '📝 Description' },\n          style: { border: { fg: :cyan } },\n          width: 120,\n          padding: 1\n        )\n        content_parts << description_box\n\n        # AI Suggestions Box (if available)\n        if blueprint[:ai_suggestions]\n          suggestions_content = build_suggestions_content(blueprint[:ai_suggestions])\n          suggestions_box = TTY::Box.frame(\n            suggestions_content,\n            title: { top_left: '🤖 AI Analysis & Suggestions' },\n            style: { border: { fg: :magenta } },\n            width: 140,\n            padding: 1\n          )\n          content_parts << suggestions_box\n        end\n\n        # Code Box with plain text (syntax highlighting removed due to readability issues)\n        code_box = UI::PreviewBoxes.code_box(\n          blueprint[:code],\n          title: '💻 Blueprint Code'\n        )\n        content_parts << code_box\n\n        content_parts.join(\"\\n\\n\")\n      end\n\n      ##\n      # Builds metadata content for the metadata box.\n      #\n      # @param blueprint [Hash] The blueprint data\n      # @return [String] Formatted metadata content\n      def build_metadata_content(blueprint)\n        metadata_lines = []\n        metadata_lines << \"ID: #{blueprint[:id]}\"\n        metadata_lines << \"Name: #{blueprint[:name]}\"\n        metadata_lines << \"Created: #{blueprint[:created_at]}\"\n        metadata_lines << \"Updated: #{blueprint[:updated_at]}\"\n\n        # Categories\n        if blueprint[:categories] && blueprint[:categories].any?\n          category_names = blueprint[:categories].map { |cat| cat[:title] }\n          metadata_lines << \"Categories: #{category_names.join(', ')}\"\n        else\n          metadata_lines << 'Categories: None'\n        end\n\n        metadata_lines.join(\"\\n\")\n      end\n\n      ##\n      # Builds AI suggestions content for the suggestions box.\n      #\n      # @param suggestions [Hash] The AI suggestions data\n      # @return [String] Formatted suggestions content\n      def build_suggestions_content(suggestions)\n        content_lines = []\n\n        if suggestions[:improvements]\n          content_lines << '💡 Improvements:'\n          suggestions[:improvements].each do |improvement|\n            # Wrap long improvement text to fit in box (130 chars for width 140 box)\n            wrapped_improvement = wrap_text(improvement, 130)\n            # Indent continuation lines\n            wrapped_lines = wrapped_improvement.split(\"\\n\")\n            content_lines << \"  • #{wrapped_lines.first}\"\n            wrapped_lines[1..].each { |line| content_lines << \"    #{line}\" }\n          end\n          content_lines << ''\n        end\n\n        if suggestions[:quality_assessment]\n          content_lines << '📊 Quality Assessment:'\n          wrapped_assessment = wrap_text(suggestions[:quality_assessment], 130)\n          content_lines << wrapped_assessment\n        end\n\n        content_lines.join(\"\\n\")\n      end\n\n      ##\n      # Displays a summary view of the blueprint.\n      #\n      # Shows key information about the blueprint in a condensed format.\n      #\n      # @param blueprint [Hash] The blueprint data to summarize\n      # @return [void]\n      #\n      # @example Internal usage\n      #   display_summary(blueprint_data)\n      def display_summary(blueprint)\n        puts \"\\n📋 Blueprint Summary\".colorize(:blue)\n        puts '=' * 50\n        puts \"ID: #{blueprint[:id]}\"\n        puts \"Name: #{blueprint[:name]}\"\n        puts \"Description: #{truncate_text(blueprint[:description] || 'No description', 60)}\"\n\n        if blueprint[:categories] && blueprint[:categories].any?\n          category_names = blueprint[:categories].map { |cat| cat[:title] }\n          puts \"Categories: #{category_names.join(', ')}\"\n        end\n\n        puts \"Code length: #{blueprint[:code].length} characters\"\n        puts \"Created: #{blueprint[:created_at]}\"\n        puts '=' * 50\n        puts ''\n      end\n\n      ##\n      # Generates AI-powered suggestions for blueprint improvements.\n      #\n      # Uses the Improvement to analyze the blueprint code\n      # and description, then returns improvement suggestions.\n      #\n      # @param blueprint [Hash] The blueprint data to analyze\n      # @return [Hash] A hash containing AI suggestions including improvements and quality assessment\n      #\n      # @example Internal usage\n      #   suggestions = generate_suggestions(blueprint_data)\n      #   # => { improvements: [...], quality_assessment: \"...\" }\n      def generate_suggestions(blueprint)\n        suggestions = {}\n\n        begin\n          # Generate improvement suggestions\n          improvements = BlueprintsCLI::Generators::Improvement.new(\n            code: blueprint[:code],\n            description: blueprint[:description]\n          ).generate\n\n          suggestions[:improvements] = improvements if improvements\n        rescue StandardError => e\n          BlueprintsCLI.logger.warn(\"Could not generate AI suggestions: #{e.message}\")\n        end\n\n        suggestions\n      end\n\n      ##\n      # Truncates text to a specified length.\n      #\n      # Adds ellipsis to the end if the text is longer than the specified length.\n      #\n      # @param text [String] The text to truncate\n      # @param length [Integer] The maximum length of the text\n      # @return [String] The truncated text\n      #\n      # @example Basic usage\n      #   truncate_text(\"This is a long text that needs truncation\", 20)\n      #   # => \"This is a long text...\"\n      def truncate_text(text, length)\n        return text if text.length <= length\n\n        text[0..length - 4] + '...'\n      end\n\n      ##\n      # Checks if TTY pager is available.\n      #\n      # @return [Boolean] true if TTY::Pager is defined and available, false otherwise\n      #\n      # Simple text wrapping helper\n      #\n      # @param text [String] Text to wrap\n      # @param width [Integer] Maximum line width\n      # @return [String] Wrapped text\n      def wrap_text(text, width = 80)\n        text.gsub(/(.{1,#{width}})(\\s+|$)/, \"\\\\1\\n\").strip\n      end\n\n      # @example Internal usage\n      #   if tty_pager_available?\n      #     TTY::Pager.page(content)\n      #   else\n      #     puts content\n      #   end\n      def tty_pager_available?\n        defined?(TTY::Pager)\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/actions/"
    },
    {
      "filename": "example_agent.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Agents\n    class ExampleAgent < Sublayer::Agents::Base\n      trigger_on_files_changed { [\"example_file.txt\"] }\n\n      goal_condition { @goal_reached }\n\n      check_status do\n        @status_checked = true\n      end\n\n      step do\n        @step_taken = true\n        @goal_reached = true\n        puts \"Example agent step executed\"\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/agents/"
    },
    {
      "filename": "autocomplete_handler.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  # AutocompleteHandler provides intelligent autocomplete suggestions\n  # for slash commands, blueprint IDs, file paths, and configuration keys\n  class AutocompleteHandler\n    def initialize\n      @blueprint_cache = {}\n      @config_keys_cache = nil\n      @cache_timestamp = nil\n    end\n\n    # Get completions for the given input\n    def completions_for(input)\n      return [] if input.nil? || input.empty?\n\n      if input.start_with?('/')\n        slash_command_completions(input)\n      else\n        general_completions(input)\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.debug(\"Autocomplete error: #{e.message}\")\n      []\n    end\n\n    private\n\n    def slash_command_completions(input)\n      parser = SlashCommandParser.new(input)\n\n      # Get base command completions from parser\n      base_completions = parser.completions\n\n      # Enhance with dynamic completions based on context\n      enhanced_completions = []\n\n      case parser.command\n      when 'blueprint'\n        enhanced_completions.concat(blueprint_specific_completions(parser))\n      when 'config'\n        enhanced_completions.concat(config_specific_completions(parser))\n      when 'docs'\n        enhanced_completions.concat(docs_specific_completions(parser))\n      end\n\n      # Combine and deduplicate\n      (base_completions + enhanced_completions).uniq.sort\n    end\n\n    def blueprint_specific_completions(parser)\n      completions = []\n\n      case parser.subcommand\n      when 'view', 'edit', 'delete', 'export'\n        # Complete with blueprint IDs\n        completions.concat(blueprint_id_completions(parser.input))\n      when 'submit'\n        # Complete with file paths\n        completions.concat(file_path_completions(parser.input))\n      when 'search'\n        # Complete with previous search terms or popular queries\n        completions.concat(search_term_completions(parser.input))\n      when 'list'\n        # Complete with format options\n        completions.push(\n          '/blueprint list --format=table',\n          '/blueprint list --format=json',\n          '/blueprint list --format=summary'\n        )\n      end\n\n      completions\n    end\n\n    def config_specific_completions(parser)\n      completions = []\n\n      case parser.subcommand\n      when 'show', 'edit'\n        # Complete with configuration keys\n        completions.concat(config_key_completions(parser.input))\n      end\n\n      completions\n    end\n\n    def docs_specific_completions(parser)\n      completions = []\n\n      case parser.subcommand\n      when 'generate'\n        # Complete with Ruby file paths\n        completions.concat(ruby_file_completions(parser.input))\n      end\n\n      completions\n    end\n\n    def blueprint_id_completions(input)\n      blueprint_ids = cached_blueprint_ids\n      prefix = extract_id_prefix(input)\n\n      if prefix.empty?\n        blueprint_ids.first(10).map { |id| \"#{input.split.first(2).join(' ')} #{id}\" }\n      else\n        matching_ids = blueprint_ids.select { |id| id.to_s.start_with?(prefix) }\n        matching_ids.first(5).map { |id| input.gsub(/\\d*$/, id.to_s) }\n      end\n    end\n\n    def file_path_completions(input)\n      # Extract the partial path from the input\n      parts = input.split\n      return [] if parts.size < 3\n\n      partial_path = parts[2..].join(' ')\n      directory = File.dirname(partial_path)\n      filename_prefix = File.basename(partial_path)\n\n      begin\n        dir_to_scan = directory == '.' ? Dir.pwd : directory\n        return [] unless Dir.exist?(dir_to_scan)\n\n        entries = Dir.entries(dir_to_scan)\n                     .reject { |entry| entry.start_with?('.') }\n                     .select { |entry| entry.start_with?(filename_prefix) }\n                     .first(10)\n\n        base_command = parts[0..1].join(' ')\n        entries.map do |entry|\n          full_path = File.join(directory, entry)\n          \"#{base_command} #{full_path}\"\n        end\n      rescue StandardError\n        []\n      end\n    end\n\n    def search_term_completions(input)\n      # Could be enhanced with popular search terms from analytics\n      common_terms = %w[ruby rails javascript python react node api rest graphql database]\n      parts = input.split\n\n      return [] if parts.size < 2\n\n      partial_term = parts.last\n      base_command = parts[0..-2].join(' ')\n\n      matching_terms = common_terms.select { |term| term.start_with?(partial_term.downcase) }\n      matching_terms.first(5).map { |term| \"#{base_command} #{term}\" }\n    end\n\n    def config_key_completions(input)\n      config_keys = cached_config_keys\n      parts = input.split\n\n      return [] if parts.size < 3\n\n      partial_key = parts.last\n      base_command = parts[0..-2].join(' ')\n\n      matching_keys = config_keys.select { |key| key.start_with?(partial_key) }\n      matching_keys.first(5).map { |key| \"#{base_command} #{key}\" }\n    end\n\n    def ruby_file_completions(input)\n      parts = input.split\n      return [] if parts.size < 3\n\n      partial_path = parts[2..].join(' ')\n      directory = File.dirname(partial_path)\n      filename_prefix = File.basename(partial_path)\n\n      begin\n        dir_to_scan = directory == '.' ? Dir.pwd : directory\n        return [] unless Dir.exist?(dir_to_scan)\n\n        ruby_files = Dir.entries(dir_to_scan)\n                        .select { |entry| entry.end_with?('.rb') }\n                        .select { |entry| entry.start_with?(filename_prefix) }\n                        .first(10)\n\n        base_command = parts[0..1].join(' ')\n        ruby_files.map do |file|\n          full_path = File.join(directory, file)\n          \"#{base_command} #{full_path}\"\n        end\n      rescue StandardError\n        []\n      end\n    end\n\n    def general_completions(input)\n      # For non-slash commands, provide general suggestions\n      suggestions = []\n\n      # Suggest slash commands if input could be part of one\n      suggestions << '/' if input.length == 1 && '/'.start_with?(input)\n\n      # Suggest common actions\n      common_actions = %w[search list help config setup]\n      matching_actions = common_actions.select { |action| action.start_with?(input.downcase) }\n      suggestions.concat(matching_actions)\n\n      suggestions\n    end\n\n    def cached_blueprint_ids\n      return @blueprint_cache[:ids] if cache_valid?\n\n      begin\n        # Fetch blueprint IDs from database\n        require_relative 'database'\n        db = BlueprintsCLI::Database.new\n\n        if db.connected?\n          ids = db.all_blueprints.map { |bp| bp[:id] }.sort\n          @blueprint_cache = { ids: ids, timestamp: Time.now }\n          ids\n        else\n          []\n        end\n      rescue StandardError => e\n        BlueprintsCLI.logger.debug(\"Failed to fetch blueprint IDs: #{e.message}\")\n        []\n      end\n    end\n\n    def cached_config_keys\n      return @config_keys_cache if @config_keys_cache\n\n      # Get available configuration keys\n      config_keys = %w[\n        logger.level\n        logger.file_logging\n        logger.file_path\n        ai.sublayer.provider\n        ai.sublayer.model\n        ai.rubyllm.default_model\n        database.url\n        editor.default\n        ui.colors\n        features.auto_description\n        features.auto_categorize\n      ]\n\n      @config_keys_cache = config_keys\n      config_keys\n    end\n\n    def cache_valid?\n      @blueprint_cache[:timestamp] &&\n        (Time.now - @blueprint_cache[:timestamp]) < 60 # Cache for 60 seconds\n    end\n\n    def extract_id_prefix(input)\n      # Extract the partial ID from the end of the input\n      parts = input.split\n      return '' if parts.size < 3\n\n      last_part = parts.last\n      last_part.match?(/^\\d/) ? last_part : ''\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "cli.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  # BlueprintsCLI::CLI is the main command line interface for BlueprintsCLI.\n  # It extends Thor to provide a command-line interface with various computer-related utilities.\n  # When no arguments are provided, it launches an interactive menu system.\n  #\n  # @example Basic usage with arguments\n  #   BlueprintsCLI::CLI.start(['command_name', 'arg1', 'arg2'])\n  # @example Interactive menu mode (no arguments)\n  #   BlueprintsCLI::CLI.start\n  class CLI < Thor\n    # Dynamically registers all available commands from BlueprintsCLI::Commands\n    # as Thor commands, excluding the base and menu commands.\n    #\n    # This is automatically executed when the class is loaded and sets up\n    # the command descriptions and method definitions for each available command.\n    excluded_commands = %i[BaseCommand MenuCommand]\n    valid_commands = BlueprintsCLI::Commands.constants.reject do |command_class|\n      excluded_commands.include?(command_class)\n    end\n\n    valid_commands.each do |command_class|\n      command = BlueprintsCLI::Commands.const_get(command_class)\n      desc command.command_name, command.description\n\n      # Add specific options for blueprint command\n      if command.command_name == 'blueprint'\n        option :interactive, type: :boolean, aliases: '-i',\n                             desc: 'Enable interactive multiline input for submit command'\n        option :auto_describe, type: :boolean, default: true,\n                               desc: 'Auto-generate description using AI'\n        option :auto_categorize, type: :boolean, default: true, desc: 'Auto-categorize using AI'\n        option :format, type: :string, desc: 'Output format (table, summary, json, etc.)'\n        option :analyze, type: :boolean, desc: 'Include AI analysis in view output'\n        option :limit, type: :numeric, desc: 'Limit number of results'\n        option :output, type: :string, desc: 'Output file path'\n        option :force, type: :boolean, desc: 'Force overwrite existing files'\n      end\n\n      define_method(command.command_name) do |*args|\n        command.new(options).execute(*args)\n      end\n    end\n\n    # Starts the CLI application with the given arguments.\n    #\n    # When no arguments are provided, launches an interactive menu system.\n    # Otherwise, processes the provided command line arguments.\n    #\n    # @param given_args [Array<String>] the command line arguments to process\n    # @return [void]\n    #\n    # @example Starting with arguments\n    #   BlueprintsCLI::CLI.start(['disk_usage', '/path/to/check'])\n    #\n    # @example Starting interactive menu\n    #   BlueprintsCLI::CLI.start\n    #\n    # @note Requires 'tty-prompt' gem for interactive menu functionality\n    # @note Set BlueprintsCLI_DEBUG=true environment variable for debug output\n    def self.start(given_args = ARGV)\n      # If no arguments provided, launch interactive menu\n      if given_args.empty?\n        # Check for enhanced menu option\n        config = BlueprintsCLI.configuration\n        enhanced_enabled = config.fetch(:ui, :enhanced_menu, default: true) ||\n                           config.fetch(:ui, :slash_commands, default: true) ||\n                           ENV['BLUEPRINTS_ENHANCED_MENU'] == 'true' ||\n                           ENV['BLUEPRINTS_SLASH_COMMANDS'] == 'true'\n\n        if enhanced_enabled\n          begin\n            BlueprintsCLI::SimpleEnhancedMenu.new.start\n          rescue StandardError => e\n            BlueprintsCLI.logger.failure(\"Enhanced menu failed: #{e.message}\")\n            # Fallback to traditional menu\n            fallback_to_traditional_menu\n          end\n        else\n          fallback_to_traditional_menu\n        end\n      else\n        super\n      end\n    end\n\n    def self.fallback_to_traditional_menu\n      require 'tty-prompt'\n      debug_mode = ENV['BlueprintsCLI_DEBUG'] == 'true'\n      BlueprintsCLI::Commands::MenuCommand.new(debug: debug_mode).start\n    rescue LoadError => e\n      BlueprintsCLI.logger.failure(\"TTY::Prompt not available. Please run: bundle install. #{e.message}\")\n      super\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "cli_ui_integration.rb",
      "content": "# frozen_string_literal: true\n\n# Load CLI-UI with a proper namespace\nbegin\n  require_relative '../cli/ui'\nrescue LoadError\n  # Fallback to the gem version if available\n  require 'cli/ui'\nend\n\nmodule BlueprintsCLI\n  # CLI-UI Integration module for BlueprintsCLI\n  # Provides enhanced interactive interface with autocomplete and visual improvements\n  module CLIUIIntegration\n    # Initialize CLI-UI with BlueprintsCLI-specific settings\n    def self.initialize!\n      # Configure color scheme to match BlueprintsCLI\n      ::CLI::UI.enable_color = $stdout.tty?\n      ::CLI::UI.enable_cursor = $stdout.tty? && ENV['CI'].nil?\n\n      # Set default frame style for consistent branding\n      ::CLI::UI.frame_style = :box\n\n      # Set up custom instruction colors to match BlueprintsCLI theme\n      ::CLI::UI::Prompt.instructions_color = :cyan\n    end\n\n    # Enhanced frame wrapper that integrates with BlueprintsCLI logger\n    def self.frame(text, color: :cyan, **options, &block)\n      ::CLI::UI.frame(text, color: color, **options, &block)\n    end\n\n    # Enhanced prompt wrapper with BlueprintsCLI integration\n    def self.ask(question, **options)\n      ::CLI::UI.ask(question, **options)\n    end\n\n    # Enhanced select with better visual styling\n    def self.select(question, options = nil, **kwargs, &)\n      if block_given?\n        ::CLI::UI.ask(question, **kwargs, &)\n      else\n        ::CLI::UI.ask(question, options: options, **kwargs)\n      end\n    end\n\n    # Confirm with BlueprintsCLI styling\n    def self.confirm(question, default: true)\n      ::CLI::UI.confirm(question, default: default)\n    end\n\n    # Display formatted text with CLI-UI formatting\n    def self.puts(text, **options)\n      ::CLI::UI.puts(text, **options)\n    end\n\n    # Display formatted text without frame prefix\n    def self.raw_puts(text)\n      ::CLI::UI.raw { puts text }\n    end\n\n    # Create a spinner with BlueprintsCLI styling\n    def self.spinner(title, ...)\n      ::CLI::UI.spinner(title, ...)\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "base_command.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Commands\n    ##\n    # BaseCommand serves as the abstract foundation for all command classes in BlueprintsCLI.\n    # It provides common functionality including command naming, logging capabilities,\n    # and establishes the interface that all concrete command classes must implement.\n    #\n    # Concrete command classes should inherit from BaseCommand and implement the +execute+ method\n    # to perform their specific operations while gaining access to standardized logging\n    # and command metadata functionality.\n    #\n    # @abstract Subclasses must implement {#execute} to be functional\n    class BaseCommand\n      ##\n      # Generates a standardized command name based on the class name.\n      #\n      # Derives the command name by taking the last part of the class name (after any\n      # namespace) and removing the trailing 'Command' if present, then downcasing the result.\n      #\n      # @return [String] the generated command name\n      # @example For a class named BlueprintsCLI::Commands::InstallCommand\n      #   command_name #=> \"install\"\n      def self.command_name\n        name.split('::').last.gsub(/Command$/, '').downcase\n      end\n\n      ##\n      # Provides a default description for the command.\n      #\n      # Generates a basic description using the command name. Subclasses should override\n      # this method to provide more specific information about what the command does.\n      #\n      # @return [String] the command description\n      # @example For a command named \"install\"\n      #   description #=> \"Description for install\"\n      def self.description\n        \"Description for #{command_name}\"\n      end\n\n      ##\n      # Initializes a new command instance.\n      #\n      # @param [Hash] options the configuration options for this command\n      def initialize(options)\n        @options = options\n      end\n\n      ##\n      # Executes the command's primary functionality.\n      #\n      # This method must be implemented by concrete command subclasses to perform\n      # their specific operations. The base implementation raises an error to enforce\n      # this requirement.\n      #\n      # @param [Array<Object>] args variable arguments that may be needed for command execution\n      # @raise [NotImplementedError] if the method is not overridden in a subclass\n      def execute(*args)\n        raise NotImplementedError, \"#{self.class} must implement #execute\"\n      end\n\n      protected\n\n      ##\n      # Provides access to the BlueprintsCLI logger instance with automatic context.\n      # The enhanced logger will automatically capture the calling class and method.\n      #\n      # @return [EnhancedLogger] the configured enhanced logger instance\n      def logger\n        @logger ||= create_context_logger\n      end\n\n      private\n\n      ##\n      # Creates a context-aware logger that includes class and method information.\n      #\n      # @return [EnhancedLogger] logger with context information\n      def create_context_logger\n        BlueprintsCLI.logger\n      end\n\n      ##\n      # Logs a success message.\n      #\n      # @param [String] message the success message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_success(message, **data)\n        BlueprintsCLI.logger.success(message, **data)\n      end\n\n      ##\n      # Logs a failure message.\n      #\n      # @param [String] message the failure message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_failure(message, **data)\n        BlueprintsCLI.logger.failure(message, **data)\n      end\n\n      ##\n      # Logs a warning message.\n      #\n      # @param [String] message the warning message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_warning(message, **data)\n        BlueprintsCLI.logger.warn(message, **data)\n      end\n\n      ##\n      # Logs a tip message.\n      #\n      # @param [String] message the tip message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_tip(message, **data)\n        BlueprintsCLI.logger.tip(message, **data)\n      end\n\n      ##\n      # Logs a step message, typically used for progress tracking.\n      #\n      # @param [String] message the step message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_step(message, **data)\n        BlueprintsCLI.logger.step(message, **data)\n      end\n\n      ##\n      # Logs an informational message.\n      #\n      # @param [String] message the informational message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_info(message, **data)\n        BlueprintsCLI.logger.info(message, **data)\n      end\n\n      ##\n      # Logs a debug message.\n      #\n      # @param [String] message the debug message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_debug(message, **data)\n        BlueprintsCLI.logger.debug(message, **data)\n      end\n\n      ##\n      # Logs an error message.\n      #\n      # @param [String] message the error message to log\n      # @param [Hash] data additional data to include with the log message\n      def log_error(message, **data)\n        BlueprintsCLI.logger.error(message, **data)\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "blueprint_command.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Commands\n    # BlueprintCommand provides a comprehensive interface for managing code blueprints\n    # with AI-enhanced capabilities. It allows developers to submit, organize,\n    # search, and manipulate code blueprints through a command-line interface.\n    #\n    # The command supports various subcommands for different operations and integrates\n    # with AI features for automatic description generation and categorization.\n    class BlueprintCommand < BaseCommand\n      # Returns a description of what the BlueprintCommand does\n      #\n      # @return [String] A description of the command's purpose\n      def self.description\n        'Manage code blueprints with AI-enhanced metadata and vector search capabilities'\n      end\n\n      # Initializes a new BlueprintCommand with the given options\n      #\n      # @param [Hash] options The options to configure the command\n      def initialize(options)\n        super\n        @subcommand = nil\n        @args = []\n      end\n\n      # Executes the blueprint command with the provided arguments\n      #\n      # @param [Array<String>] args The arguments to process\n      # @return [Boolean, nil] Returns false if the command fails, nil otherwise\n      def execute(*args)\n        @subcommand = args.shift\n        @args = args\n\n        case @subcommand\n        when 'submit'\n          handle_submit\n        when 'list'\n          handle_list\n        when 'browse'\n          handle_browse\n        when 'view'\n          handle_view\n        when 'edit'\n          handle_edit\n        when 'delete'\n          handle_delete\n        when 'search'\n          handle_search\n        when 'export'\n          handle_export\n        when 'generate'\n          handle_generate\n        when 'config'\n          handle_config\n        when 'help', nil\n          show_help\n        else\n          puts \"❌ Unknown subcommand: #{@subcommand}\".colorize(:red)\n          show_help\n          false\n        end\n      end\n\n      private\n\n      # Handles the submission of a new blueprint\n      #\n      # Accepts either a file path or direct code string as input.\n      # Supports automatic description and categorization through AI features.\n      # If no input is provided and --interactive flag is set, enters multiline input mode.\n      #\n      # @return [Boolean] Returns false if submission fails due to missing input\n      def handle_submit\n        input = @args.first\n\n        unless input\n          return handle_interactive_submit if @options['interactive']\n\n          puts '❌ Please provide a file path or code string'.colorize(:red)\n          puts 'Usage: blueprint submit <file_path_or_code>'\n          puts 'Or use: blueprint submit --interactive for multiline input'\n          return false\n\n        end\n\n        if File.exist?(input)\n          puts \"📁 Submitting blueprint from file: #{input}\".colorize(:blue)\n          code = File.read(input)\n          filename = File.basename(input)\n        else\n          puts '📝 Submitting blueprint from code string'.colorize(:blue)\n          code = input\n          filename = nil\n        end\n\n        BlueprintsCLI::Actions::Submit.new(\n          code: code,\n          filename: filename,\n          auto_describe: @options['auto_describe'] != false,\n          auto_categorize: @options['auto_categorize'] != false\n        ).call\n      end\n\n      # Handles interactive blueprint submission with multiline input support.\n      #\n      # @return [Boolean] Returns true if submission succeeds, false otherwise\n      def handle_interactive_submit\n        require 'tty-prompt'\n\n        prompt = TTY::Prompt.new\n\n        puts '📝 Interactive Blueprint Submission'\n        puts 'Enter your code below (press Ctrl+D when finished):'\n        puts\n\n        code_lines = prompt.multiline('', help: 'Press Ctrl+D to finish input')\n\n        if code_lines.nil? || code_lines.empty?\n          puts '❌ No code provided'.colorize(:red)\n          return false\n        end\n\n        code = code_lines.join(\"\\n\").strip\n\n        if code.empty?\n          puts '❌ No code provided'.colorize(:red)\n          return false\n        end\n\n        puts \"\\n📝 Submitting blueprint from interactive input\".colorize(:blue)\n\n        BlueprintsCLI::Actions::Submit.new(\n          code: code,\n          filename: nil,\n          auto_describe: @options['auto_describe'] != false,\n          auto_categorize: @options['auto_categorize'] != false\n        ).call\n      end\n\n      # Lists available blueprints with optional formatting\n      #\n      # @return [void] Outputs the list of blueprints to the console\n      def handle_list\n        format = (@options['format'] || 'table').to_sym\n        interactive = @options['interactive'] || false\n\n        BlueprintsCLI::Actions::List.new(\n          format: format,\n          interactive: interactive\n        ).call\n      end\n\n      # Provides an interactive browsing experience for blueprints\n      #\n      # @return [void] Initiates the interactive browsing session\n      def handle_browse\n        BlueprintsCLI::Actions::List.new(\n          interactive: true\n        ).call\n      end\n\n      # Views a specific blueprint with detailed information\n      #\n      # @param [String] id The ID of the blueprint to view\n      # @option options [Symbol] :format (:detailed) The output format\n      # @option options [Boolean] :analyze (false) Whether to include AI analysis\n      # @return [Boolean] Returns false if no ID is provided\n      def handle_view\n        id = @args.first\n\n        unless id\n          puts '❌ Please provide a blueprint ID'.colorize(:red)\n          puts 'Usage: blueprint view <id>'\n          return false\n        end\n\n        format = (@options['format'] || 'interactive').to_sym\n\n        # Ensure interactive is default for better UX unless explicitly specified\n        format = :interactive if format == :detailed && !@options['format']\n\n        BlueprintsCLI::Actions::View.new(\n          id: id.to_i,\n          format: format,\n          with_suggestions: @options['analyze'] || false\n        ).call\n      end\n\n      # Edits an existing blueprint\n      #\n      # @param [String] id The ID of the blueprint to edit\n      # @return [Boolean] Returns false if no ID is provided\n      def handle_edit\n        id = @args.first\n\n        unless id\n          puts '❌ Please provide a blueprint ID'.colorize(:red)\n          puts 'Usage: blueprint edit <id>'\n          return false\n        end\n\n        BlueprintsCLI::Actions::Edit.new(\n          id: id.to_i\n        ).call\n      end\n\n      # Deletes a blueprint with optional force flag\n      #\n      # @param [String] id The ID of the blueprint to delete\n      # @param [Boolean] force Whether to skip confirmation prompts\n      # @return [void] Initiates the delete action\n      def handle_delete\n        # Check for force flag in arguments\n        force = @args.include?('--force')\n\n        # Get ID (first non-flag argument)\n        id = @args.find { |arg| !arg.start_with?('--') }\n\n        # If no ID provided, will trigger interactive selection\n        BlueprintsCLI::Actions::Delete.new(\n          id: id&.to_i,\n          force: force\n        ).call\n      end\n\n      # Searches blueprints based on a query\n      #\n      # @param [String] query The search query\n      # @option options [Integer] :limit (10) The maximum number of results to return\n      # @return [Boolean] Returns false if no query is provided\n      def handle_search\n        query = @args.join(' ')\n\n        if query.empty?\n          puts '❌ Please provide a search query'.colorize(:red)\n          puts 'Usage: blueprint search <query>'\n          return false\n        end\n\n        BlueprintsCLI::Actions::Search.new(\n          query: query,\n          limit: @options['limit'] || 10\n        ).call\n      end\n\n      # Exports a blueprint to a file\n      #\n      # @param [String] id The ID of the blueprint to export\n      # @param [String] output_path The path to export the blueprint to\n      # @return [Boolean] Returns false if no ID is provided\n      def handle_export\n        id = @args.first\n        output_path = @args[1] || @options['output']\n\n        unless id\n          puts '❌ Please provide a blueprint ID'.colorize(:red)\n          puts 'Usage: blueprint export <id> [output_file]'\n          return false\n        end\n\n        BlueprintsCLI::Actions::Export.new(\n          id: id.to_i,\n          output_path: output_path\n        ).call\n      end\n\n      # Generates code based on natural language input using blueprint context\n      #\n      # @param [String] prompt The natural language description of code to generate\n      # @option options [String] :output_dir (\"./generated\") The output directory\n      # @option options [Integer] :limit (5) Number of blueprints to use as context\n      # @option options [Boolean] :force (false) Whether to overwrite existing files\n      # @return [Boolean] Returns false if no prompt is provided\n      def handle_generate\n        prompt = @args.join(' ')\n\n        if prompt.empty?\n          puts '❌ Please provide a description of what you want to generate'.colorize(:red)\n          puts 'Usage: blueprint generate <description>'\n          return false\n        end\n\n        output_dir = @options['output_dir'] || @options['output'] || './generated'\n        limit = (@options['limit'] || 5).to_i\n        force = @options['force'] || false\n\n        puts \"🚀 Generating code based on: #{prompt}\".colorize(:blue)\n        puts \"📁 Output directory: #{output_dir}\".colorize(:cyan)\n        puts \"🔍 Using #{limit} relevant blueprints as context\".colorize(:cyan)\n\n        result = BlueprintsCLI::Actions::Generate.new(\n          prompt: prompt,\n          output_dir: output_dir,\n          limit: limit,\n          force: force\n        ).call\n\n        if result[:success]\n          puts \"\\n✅ Code generation completed successfully!\".colorize(:green)\n          puts \"📊 Generated #{result[:generated_files].length} files\".colorize(:green)\n\n          result[:generated_files].each do |file_result|\n            if file_result[:success]\n              puts \"  ✅ #{file_result[:name]} (#{file_result[:language]})\".colorize(:green)\n            else\n              puts \"  ❌ #{file_result[:name]} - #{file_result[:error]}\".colorize(:red)\n            end\n          end\n\n          puts \"\\n📚 Used blueprints for context: #{result[:relevant_blueprints].join(', ')}\".colorize(:cyan) unless result[:relevant_blueprints].empty?\n        else\n          puts \"❌ Code generation failed: #{result[:error]}\".colorize(:red)\n          false\n        end\n      end\n\n      # Manages blueprint configuration\n      #\n      # @param [String] subcommand The configuration subcommand (default: 'show')\n      # @return [void] Initiates the configuration action\n      def handle_config\n        subcommand = @args.first || 'show'\n\n        BlueprintsCLI::Actions::Config.new(\n          subcommand: subcommand\n        ).call\n      end\n\n      # Displays help information for the blueprint command\n      #\n      # @return [void] Outputs help information to the console\n      def show_help\n        puts <<~HELP\n          Blueprint Management Commands:\n\n          📝 Content Management:\n            blueprint submit <file_or_code>     Submit a new blueprint\n            blueprint edit <id>                 Edit existing blueprint (delete + resubmit)\n            blueprint delete [id]               Delete blueprint (interactive if no ID)\n            blueprint export <id> [file]        Export blueprint code to file\n\n          📋 Browsing & Search:\n            blueprint list                      List all blueprints\n            blueprint browse                    Interactive blueprint browser\n            blueprint view <id>                 View specific blueprint\n            blueprint search <query>            Search blueprints by content\n\n          🤖 Code Generation:\n            blueprint generate <description>    Generate code from natural language\n\n          🔧 Configuration:\n            blueprint config [show|setup]      Manage configuration\n\n          Options:\n            --format FORMAT                     Output format (table, json, summary, detailed, interactive)\n            --interactive                       Interactive mode with prompts\n            --output FILE                       Output file path\n            --output_dir DIR                    Output directory for generated files\n            --analyze                          Include AI analysis and suggestions\n            --force                            Skip confirmation prompts (use with caution)\n            --limit N                          Number of blueprints to use as context (default: 5)\n            --auto_describe=false              Disable auto-description generation\n            --auto_categorize=false            Disable auto-categorization\n\n          Examples:\n            blueprint submit my_code.rb\n            blueprint submit 'puts \"hello world\"'\n            blueprint list --format summary\n            blueprint browse\n            blueprint view 123                         # Interactive two-column view (default)\n            blueprint view 123 --format detailed       # Traditional detailed view\n            blueprint view 123 --analyze               # Interactive view with AI suggestions\n            blueprint edit 123\n            blueprint delete 123\n            blueprint delete --force 123\n            blueprint delete                        # Interactive selection\n            blueprint search \"ruby class\"\n            blueprint export 123 my_blueprint.rb\n            blueprint generate \"Create a Ruby web server using Sinatra\"\n            blueprint generate \"Python data analysis script\" --output_dir ./analysis\n            blueprint generate \"React component for user login\" --limit 3 --force\n\n        HELP\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "config_command.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Commands\n    ##\n    # ConfigCommand handles all configuration management operations for BlueprintsCLI.\n    # This command provides a comprehensive interface for setting up, viewing,\n    # editing, validating, and resetting the application configuration.\n    #\n    # The command follows a subcommand pattern where the first argument determines\n    # the specific configuration operation to perform. This design allows for a\n    # clean separation of concerns and provides a user-friendly interface for\n    # configuration management.\n    #\n    # @example Setup new configuration\n    #   BlueprintsCLI::Commands::ConfigCommand.new({}).execute('setup')\n    #\n    # @example Show current configuration\n    #   BlueprintsCLI::Commands::ConfigCommand.new({}).execute('show')\n    class ConfigCommand < BaseCommand\n      ##\n      # Provides a description of what this command does, used in help text\n      #\n      # @return [String] A description of the command's purpose\n      def self.description\n        'Manage BlueprintsCLI configuration settings'\n      end\n\n      ##\n      # Initializes a new ConfigCommand instance\n      #\n      # @param [Hash] options The options to configure the command\n      def initialize(options)\n        super\n        @prompt = TTY::Prompt.new\n      end\n\n      ##\n      # Executes the configuration command with the provided arguments\n      #\n      # This method routes to the appropriate handler based on the subcommand provided.\n      # If no subcommand is provided, it defaults to the setup handler.\n      #\n      # @param [Array<String>] args The arguments to pass to the command\n      # @return [Boolean] true if the command executed successfully, false otherwise\n      #\n      # @example Execute with setup subcommand\n      #   command = ConfigCommand.new({})\n      #   command.execute(['setup'])\n      def execute(*args)\n        subcommand = args.shift\n\n        case subcommand\n        when 'setup', nil\n          handle_setup\n        when 'show'\n          handle_show\n        when 'edit'\n          handle_edit\n        when 'reset'\n          handle_reset\n        when 'validate'\n          handle_validate\n        when 'help'\n          show_help\n        else\n          puts \"❌ Unknown subcommand: #{subcommand}\".colorize(:red)\n          show_help\n          false\n        end\n      end\n\n      private\n\n      ##\n      # Handles the configuration setup process\n      #\n      # This method guides the user through an interactive setup process to configure\n      # BlueprintsCLI for their environment. It loads the configuration module and\n      # initiates the interactive setup procedure.\n      #\n      # @return [Boolean] true if setup was successful, false otherwise\n      #\n      # @example Run the setup handler\n      #   command = ConfigCommand.new({})\n      #   command.send(:handle_setup)\n      def handle_setup\n        puts '🔧 BlueprintsCLI Configuration Setup'.colorize(:blue)\n        puts '=' * 40\n\n        begin\n          require_relative '../configuration'\n          config = BlueprintsCLI::Configuration.new\n          success = config.interactive_setup\n\n          if success\n            puts '✅ Configuration setup completed successfully!'.colorize(:green)\n            true\n          else\n            puts '⚠️  Configuration setup completed with warnings.'.colorize(:yellow)\n            false\n          end\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error during configuration setup: #{e.message}\")\n          BlueprintsCLI.logger.debug(e) if ENV['DEBUG']\n          false\n        end\n      end\n\n      ##\n      # Displays the current configuration settings\n      #\n      # This method loads and displays the current configuration in a formatted way,\n      # showing each configuration section with its values. If no configuration is\n      # found, it informs the user and suggests running the setup command.\n      #\n      # @return [Boolean] true if the configuration was displayed successfully, false otherwise\n      #\n      # @example Show current configuration\n      #   command = ConfigCommand.new({})\n      #   command.send(:handle_show)\n      def handle_show\n        puts '📋 Current Configuration'.colorize(:blue)\n        puts '=' * 25\n\n        begin\n          require_relative '../configuration'\n          config = BlueprintsCLI::Configuration.new\n          config_hash = config.config.to_hash\n\n          if config_hash.empty?\n            puts \"⚠️  No configuration found. Run 'config setup' to create one.\".colorize(:yellow)\n            return false\n          end\n\n          display_config_section('Paths', config_hash['paths']) if config_hash['paths']\n          display_config_section('Display', config_hash['display']) if config_hash['display']\n          display_config_section('Restic', config_hash['restic']) if config_hash['restic']\n          display_config_section('Terminal', config_hash['terminal']) if config_hash['terminal']\n          display_config_section('Logger', config_hash['logger']) if config_hash['logger']\n\n          true\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error reading configuration: #{e.message}\")\n          false\n        end\n      end\n\n      ##\n      # Provides an interactive editor for modifying configuration sections\n      #\n      # This method allows users to select and edit specific configuration sections\n      # through an interactive menu. Users can choose to edit individual sections or\n      # run through the full setup process again.\n      #\n      # @return [Boolean] true if the configuration was edited successfully, false otherwise\n      #\n      # @example Edit configuration\n      #   command = ConfigCommand.new({})\n      #   command.send(:handle_edit)\n      def handle_edit\n        puts '✏️  Interactive Configuration Editor'.colorize(:blue)\n        puts '=' * 35\n\n        begin\n          require_relative '../configuration'\n          config = BlueprintsCLI::Configuration.new\n\n          section = @prompt.select('Which section would you like to edit?') do |menu|\n            menu.choice '📁 Paths (directories and repositories)', :paths\n            menu.choice '🎨 Display settings', :display\n            menu.choice '📦 Restic backup settings', :restic\n            menu.choice '💻 Terminal settings', :terminal\n            menu.choice '📝 Logger settings', :logger\n            menu.choice '🔄 Full setup (all sections)', :all\n            menu.choice '❌ Cancel', :cancel\n          end\n\n          return true if section == :cancel\n\n          case section\n          when :paths\n            config.send(:configure_paths)\n          when :display\n            config.send(:configure_display)\n          when :restic\n            config.send(:configure_restic)\n          when :terminal\n            config.send(:configure_terminals)\n          when :logger\n            config.send(:configure_logger)\n          when :all\n            config.interactive_setup\n          end\n\n          config.send(:save_config)\n          puts '✅ Configuration updated successfully!'.colorize(:green)\n          true\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error editing configuration: #{e.message}\")\n          false\n        end\n      end\n\n      ##\n      # Resets the configuration by deleting the configuration file\n      #\n      # This method prompts the user for confirmation before deleting the configuration\n      # file. If the file doesn't exist, it informs the user.\n      #\n      # @return [Boolean] true if the configuration was reset successfully or didn't exist, false otherwise\n      #\n      # @example Reset configuration\n      #   command = ConfigCommand.new({})\n      #   command.send(:handle_reset)\n      def handle_reset\n        puts '🔄 Reset Configuration'.colorize(:blue)\n        puts '=' * 22\n\n        config_file = File.expand_path('~/.config/BlueprintsCLI/config.yml')\n\n        if File.exist?(config_file)\n          confirmed = @prompt.yes?('⚠️  This will delete your current configuration. Are you sure?')\n          return false unless confirmed\n\n          begin\n            File.delete(config_file)\n            puts '✅ Configuration file deleted successfully.'.colorize(:green)\n            puts \"💡 Run 'config setup' to create a new configuration.\".colorize(:cyan)\n            true\n          rescue StandardError => e\n            BlueprintsCLI.logger.failure(\"Error deleting configuration file: #{e.message}\")\n            false\n          end\n        else\n          puts \"ℹ️  No configuration file found at #{config_file}\".colorize(:blue)\n          true\n        end\n      end\n\n      ##\n      # Validates the current configuration\n      #\n      # This method checks the validity of the current configuration, particularly\n      # focusing on verifying that required external tools and settings are available.\n      #\n      # @return [Boolean] true if the configuration is valid, false otherwise\n      #\n      # @example Validate configuration\n      #   command = ConfigCommand.new({})\n      #   command.send(:handle_validate)\n      def handle_validate\n        puts '🔍 Validating Configuration'.colorize(:blue)\n        puts '=' * 26\n\n        begin\n          require_relative '../configuration'\n          config = BlueprintsCLI::Configuration.new\n\n          # Test terminal command\n          puts '📡 Checking terminal availability...'.colorize(:cyan)\n          terminals_valid = config.send(:validate_terminal_command)\n\n          if terminals_valid\n            puts '✅ Configuration validation passed!'.colorize(:green)\n          else\n            puts '⚠️  Configuration validation completed with warnings.'.colorize(:yellow)\n          end\n\n          true\n        rescue TTY::Config::ValidationError => e\n          puts \"❌ Configuration validation failed: #{e.message}\".colorize(:red)\n          false\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error during validation: #{e.message}\")\n          false\n        end\n      end\n\n      ##\n      # Displays a configuration section with proper formatting\n      #\n      # This helper method formats and displays a configuration section with\n      # appropriate coloring and indentation based on the data type.\n      #\n      # @param [String] title The title of the section to display\n      # @param [Hash, Array, Object] data The configuration data to display\n      #\n      # @example Display a configuration section\n      #   command = ConfigCommand.new({})\n      #   command.send(:display_config_section, \"Paths\", { home: \"/home/user\" })\n      def display_config_section(title, data)\n        puts \"\\n#{title}:\".colorize(:cyan)\n        case data\n        when Hash\n          data.each do |key, value|\n            puts \"  #{key}: #{format_value(value)}\"\n          end\n        when Array\n          data.each_with_index do |item, i|\n            puts \"  #{i + 1}. #{format_value(item)}\"\n          end\n        else\n          puts \"  #{format_value(data)}\"\n        end\n      end\n\n      ##\n      # Formats a configuration value for display\n      #\n      # This helper method applies appropriate formatting and coloring to configuration\n      # values based on their type. Special handling is provided for command/args hashes.\n      #\n      # @param [Object] value The value to format\n      # @return [String] The formatted value with appropriate coloring\n      #\n      # @example Format a simple value\n      #   command = ConfigCommand.new({})\n      #   command.send(:format_value, \"/home/user\")\n      #\n      # @example Format a command hash\n      #   command = ConfigCommand.new({})\n      #   command.send(:format_value, { command: \"ls\", args: \"-la\" })\n      def format_value(value)\n        case value\n        when Hash\n          if value.key?('command') && value.key?('args')\n            \"#{value['command']} #{value['args']}\".colorize(:yellow)\n          else\n            value.inspect.colorize(:yellow)\n          end\n        when String\n          value.colorize(:yellow)\n        else\n          value.to_s.colorize(:yellow)\n        end\n      end\n\n      ##\n      # Displays help information for the configuration command\n      #\n      # This method outputs detailed help information including available subcommands,\n      # configuration sections, file information, examples, and tips.\n      #\n      # @example Show help\n      #   command = ConfigCommand.new({})\n      #   command.send(:show_help)\n      def show_help\n        puts <<~HELP\n          Configuration Management Commands:\n\n          🔧 Setup & Management:\n            config setup                         Interactive configuration setup (default)\n            config show                          Display current configuration\n            config edit                          Edit specific configuration sections\n            config reset                         Delete configuration file\n            config validate                      Validate configuration and check dependencies\n\n          📋 Configuration Sections:\n            • Paths: Home directory, restic mount point, repository paths\n            • Display: Time format and output preferences#{'  '}\n            • Restic: Backup mounting timeout and settings\n            • Terminal: Default terminal emulator command and arguments\n            • Logger: Log levels, file logging, and output preferences\n\n          💾 Configuration File:\n            Location: ~/.config/BlueprintsCLI/config.yml\n            Format: YAML with hierarchical sections\n\n          Examples:\n            config                               # Run interactive setup\n            config show                          # View current settings\n            config edit                          # Edit specific sections\n            config validate                      # Check configuration validity\n            config reset                         # Start fresh\n\n          💡 Tips:\n            • Use 'config setup' for first-time configuration\n            • Use 'config edit' to modify specific sections only\n            • Use 'config validate' to check if external tools are available\n\n        HELP\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "docs_command.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'base_command'\nrequire_relative '../services/yardoc_service'\n\nmodule BlueprintsCLI\n  module Commands\n    # Command to handle YARD documentation generation.\n    class DocsCommand < BaseCommand\n      # Provides a description of what this command does.\n      # @return [String] A description of the command's purpose.\n      def self.description\n        'Generate YARD documentation for Ruby files.'\n      end\n\n      # Initializes a new DocsCommand instance.\n      # @param [Hash] options The options to configure the command.\n      def initialize(options)\n        super\n        @prompt = TTY::Prompt.new\n      end\n\n      # Executes the docs command.\n      # @param [Array<String>] args The arguments to pass to the command.\n      def execute(*args)\n        subcommand = args.shift\n        case subcommand\n        when 'generate'\n          handle_generate(args.first)\n        when 'help', nil\n          show_help\n        else\n          puts \"Unknown subcommand: #{subcommand}\".colorize(:red)\n          show_help\n          false\n        end\n      end\n\n      private\n\n      def handle_generate(file_path)\n        if file_path.nil?\n          puts 'Please provide a file path.'.colorize(:red)\n          show_help\n          return false\n        end\n\n        absolute_path = File.expand_path(file_path)\n        service = BlueprintsCLI::Services::YardocService.new(absolute_path)\n        service.call\n      end\n\n      def show_help\n        puts <<~HELP\n          Usage: blueprintsCLI docs <subcommand> [options]\n\n          Subcommands:\n            generate <file_path>   - Generates YARD documentation for the specified file.\n            help                     - Shows this help message.\n        HELP\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "menu_command.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire 'tty-cursor'\nrequire 'tty-pager'\n\nmodule BlueprintsCLI\n  module Commands\n    # MenuCommand provides an interactive command menu system for BlueprintsCLI.\n    # It displays available commands, handles user input, and executes selected commands.\n    # This class serves as the main interactive interface when no specific command is provided.\n    #\n    # @example Basic Usage\n    #   BlueprintsCLI::Commands::MenuCommand.new.start\n    #\n    # @example With Debugging\n    #   BlueprintsCLI::Commands::MenuCommand.new(debug: true).start\n    class MenuCommand\n      # Initializes a new MenuCommand instance.\n      #\n      # @param debug [Boolean] whether to enable debug logging\n      # @option debug [Boolean] :debug (false) enables debug output if true\n      def initialize(debug: false)\n        @prompt = TTY::Prompt.new(input: $stdin, output: $stdout, enable_color: true,\n                                  interrupt: :exit)\n        @commands = available_commands\n        @debug = debug\n      end\n\n      # Starts the interactive menu loop.\n      # Displays the main menu, processes user selections, and executes the chosen commands.\n      # Continues running until the user selects the exit option.\n      #\n      # @return [void]\n      def start\n        # Check if we can use interactive mode\n        if interactive_mode_available?\n          start_interactive_mode\n        else\n          start_fallback_mode\n        end\n      end\n\n      # Check if interactive TTY mode is available\n      #\n      # @return [Boolean] true if interactive mode can work\n      def interactive_mode_available?\n        $stdin.tty? && $stdout.tty? && ENV.fetch('TERM', nil) && !ENV['CI']\n      rescue StandardError\n        false\n      end\n\n      # Start the normal interactive mode\n      #\n      # @return [void]\n      def start_interactive_mode\n        # Clear screen only once at the start\n        clear_screen_smart\n\n        loop do\n          choice = main_menu\n\n          # Debug logging\n          debug_log(\"Choice selected: #{choice.inspect} (#{choice.class})\")\n\n          case choice\n          when :exit\n            puts '👋 Goodbye!'.colorize(:green)\n            break\n          else\n            # All command names are strings, so handle them directly\n            debug_log(\"Handling command: #{choice}\")\n            result = handle_command(choice)\n            debug_log(\"Command result: #{result}\")\n            # If command handler returns :exit, break the loop\n            break if result == :exit\n          end\n        end\n      end\n\n      # Fallback mode for non-interactive environments\n      #\n      # @return [void]\n      def start_fallback_mode\n        puts '🚀 BlueprintsCLI - Non-interactive mode'.colorize(:cyan)\n        puts 'Available commands:'.colorize(:yellow)\n\n        @commands.each_with_index do |cmd, index|\n          puts \"  #{index + 1}. #{cmd[:name]} - #{cmd[:description]}\"\n        end\n        puts \"  #{@commands.length + 1}. logs - View application logs\"\n        puts \"  #{@commands.length + 2}. exit - Exit the application\"\n\n        print \"\\nEnter command number or name: \".colorize(:cyan)\n        $stdout.flush\n        input = $stdin.gets&.chomp\n\n        if input.nil? || input.empty?\n          puts 'No input received. Exiting.'.colorize(:yellow)\n          return\n        end\n\n        # Handle numeric input\n        if input.match?(/^\\d+$/)\n          choice_index = input.to_i - 1\n          if choice_index >= 0 && choice_index < @commands.length\n            choice = @commands[choice_index][:name]\n          elsif choice_index == @commands.length\n            choice = 'logs'\n          elsif choice_index == @commands.length + 1\n            choice = :exit\n          else\n            puts \"Invalid selection: #{input}\".colorize(:red)\n            return\n          end\n        else\n          # Handle text input\n          choice = input.downcase\n          choice = :exit if choice == 'exit'\n        end\n\n        case choice\n        when :exit\n          puts '👋 Goodbye!'.colorize(:green)\n        else\n          result = handle_command(choice)\n          puts \"Command completed with result: #{result}\".colorize(:green) if result != :continue\n        end\n      end\n\n      private\n\n      # Logs debug messages when debug mode is enabled.\n      #\n      # @param message [String] the debug message to log\n      # @return [void]\n      def debug_log(message)\n        puts \"🔍 DEBUG: #{message}\".colorize(:magenta) if @debug\n      end\n\n      # Smart screen clearing that only clears when necessary\n      #\n      # @return [void]\n      def clear_screen_smart\n        print TTY::Cursor.clear_screen_down\n      end\n\n      # Adds spacing without clearing the screen\n      #\n      # @param lines [Integer] number of lines to add (default: 2)\n      # @return [void]\n      def add_spacing(lines = 2)\n        puts \"\\n\" * lines\n      end\n\n      # Clears only the current line and moves cursor to beginning\n      #\n      # @return [void]\n      def clear_current_line\n        print TTY::Cursor.clear_line if defined?(TTY::Cursor)\n        print \"\\r\"\n      end\n\n      # Retrieves the list of available commands from the BlueprintsCLI::Commands module.\n      # Excludes base classes and the MenuCommand itself.\n      #\n      # @return [Array<Hash>] array of command hashes with name, description, and class\n      def available_commands\n        excluded_commands = %i[BaseCommand MenuCommand]\n        valid_commands = BlueprintsCLI::Commands.constants.reject do |command_class|\n          excluded_commands.include?(command_class)\n        end\n\n        valid_commands.map do |command_class|\n          command = BlueprintsCLI::Commands.const_get(command_class)\n          {\n            name: command.command_name,\n            description: command.description,\n            class: command\n          }\n        end\n      end\n\n      # Displays the main menu and captures user selection.\n      #\n      # @return [Symbol, String] the selected command name or :exit symbol\n      def main_menu\n        debug_log(\"Building main menu with commands: #{@commands.map { |cmd| cmd[:name] }}\")\n\n        # Add some spacing between iterations instead of clearing\n        add_spacing(2)\n\n        # Display the application banner using TTY::Box\n        banner = TTY::Box.frame(\n          \"🚀 BlueprintsCLI 🚀\\n\\nYour Blueprint Management Hub\",\n          padding: 1,\n          align: :center,\n          title: { top_left: 'v1.0' },\n          style: { border: { fg: :cyan } }\n        )\n        puts banner\n\n        begin\n          result = @prompt.select('Select a command:'.colorize(:cyan)) do |menu|\n            @commands.each do |cmd|\n              debug_log(\"Adding menu choice: '#{cmd[:name].capitalize} - #{cmd[:description]}' -> #{cmd[:name].inspect}\")\n              menu.choice \"#{cmd[:name].capitalize} - #{cmd[:description]}\", cmd[:name]\n            end\n            menu.choice '📋 View Logs', 'logs'\n            menu.choice 'Exit', :exit\n          end\n\n          debug_log(\"Menu selection returned: #{result.inspect}\")\n          result\n        rescue TTY::Reader::InputInterrupt, Interrupt\n          debug_log('User interrupted menu selection')\n          :exit\n        rescue StandardError => e\n          debug_log(\"Error in menu selection: #{e.message}\")\n          puts \"❌ Menu error: #{e.message}\".colorize(:red)\n          :exit\n        end\n      end\n\n      # Handles the execution of a selected command.\n      #\n      # @param command_name [String] the name of the command to execute\n      # @return [Symbol] :continue to keep the menu running, or :exit to stop\n      def handle_command(command_name)\n        debug_log(\"Looking for command: #{command_name.inspect}\")\n        debug_log(\"Available commands: #{@commands.map { |cmd| cmd[:name] }}\")\n\n        # Special handling for logs command which is not in the commands array\n        if command_name == 'logs'\n          debug_log('Executing logs command (special menu command)')\n          return handle_logs_command\n        end\n\n        command_info = @commands.find { |cmd| cmd[:name] == command_name }\n        debug_log(\"Command found: #{command_info ? 'YES' : 'NO'}\")\n\n        return :continue unless command_info\n\n        debug_log(\"Executing command handler for: #{command_name}\")\n        case command_name\n        when 'blueprint'\n          handle_blueprint_command\n        when 'config'\n          handle_config_command\n        when 'docs'\n          handle_docs_command\n        when 'setup'\n          handle_setup_command\n        when 'logs'\n          handle_logs_command\n        else\n          puts \"❌ Unknown command: #{command_name}\".colorize(:red)\n          :continue\n        end\n      end\n\n      # Handles the blueprint command submenu and operations.\n      #\n      # @return [Symbol] :continue to keep the menu running\n      def handle_blueprint_command\n        debug_log('Entering handle_blueprint_command')\n        subcommand = @prompt.select('📋 Blueprint - Choose operation:'.colorize(:blue)) do |menu|\n          menu.choice 'Submit new blueprint', 'submit'\n          menu.choice 'List all blueprints', 'list'\n          menu.choice 'Browse blueprints interactively', 'browse'\n          menu.choice 'View specific blueprint', 'view'\n          menu.choice 'Edit blueprint', 'edit'\n          menu.choice 'Delete blueprint', 'delete'\n          menu.choice 'Search blueprints', 'search'\n          menu.choice 'Export blueprint', 'export'\n          menu.choice '🤖 Generate code from description', 'generate'\n          menu.choice 'Configuration', 'config'\n          menu.choice 'Back to main menu', :back\n        end\n\n        return :continue if subcommand == :back\n\n        begin\n          case subcommand\n          when 'submit'\n            handle_blueprint_submit\n          when 'list'\n            handle_blueprint_list\n          when 'browse'\n            execute_blueprint_command('browse')\n          when 'view'\n            handle_blueprint_view\n          when 'edit'\n            handle_blueprint_edit\n          when 'delete'\n            handle_blueprint_delete\n          when 'search'\n            handle_blueprint_search\n          when 'export'\n            handle_blueprint_export\n          when 'generate'\n            handle_blueprint_generate\n          when 'config'\n            handle_blueprint_config\n          end\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error executing blueprint command: #{e.message}\")\n        end\n\n        :continue\n      end\n\n      # Executes a blueprint command with the given subcommand and arguments.\n      #\n      # @param subcommand [String] the blueprint subcommand to execute\n      # @param args [Array] additional arguments for the command\n      # @return [void]\n      def execute_blueprint_command(subcommand, *args)\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n        blueprint_command.execute(subcommand, *args)\n      end\n\n      # Handles the blueprint submission process.\n      # Prompts the user for input method and options, then executes the submit command.\n      #\n      # @return [void]\n      def handle_blueprint_submit\n        # Let user choose input method\n        input_method = @prompt.select('📝 How would you like to provide the code?') do |menu|\n          menu.choice 'File path', :file\n          menu.choice 'Single line input', :single_line\n          menu.choice 'Multi-line input (Ctrl+D to finish)', :multiline\n          menu.choice 'Open in editor', :editor\n        end\n\n        input = case input_method\n                when :file\n                  get_file_input\n                when :single_line\n                  get_single_line_input\n                when :multiline\n                  get_multiline_input\n                when :editor\n                  get_editor_input\n                end\n\n        return if input.nil? || input.empty?\n\n        auto_describe = @prompt.yes?('🤖 Auto-generate description?')\n        auto_categorize = @prompt.yes?('🏷️ Auto-categorize?')\n\n        args = [input]\n        options = {}\n        options['auto_describe'] = false unless auto_describe\n        options['auto_categorize'] = false unless auto_categorize\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(options)\n        blueprint_command.execute('submit', *args)\n      end\n\n      # Gets file path input from user\n      #\n      # @return [String, nil] File path or nil if cancelled\n      def get_file_input\n        @prompt.ask('📁 Enter file path:') do |q|\n          q.required true\n          q.validate(->(input) { File.exist?(input) }, 'File must exist')\n        end\n      end\n\n      # Gets single line code input from user\n      #\n      # @return [String, nil] Code string or nil if cancelled\n      def get_single_line_input\n        @prompt.ask('📝 Enter code:') do |q|\n          q.required true\n        end\n      end\n\n      # Gets multiline code input from user\n      #\n      # @return [String, nil] Joined code lines or nil if cancelled\n      def get_multiline_input\n        puts '📝 Enter your code (press Ctrl+D when finished):'\n        code_lines = @prompt.multiline('', help: 'Press Ctrl+D to finish input')\n\n        if code_lines && !code_lines.empty?\n          joined_code = code_lines.join(\"\\n\").strip\n          return joined_code.empty? ? nil : joined_code\n        end\n\n        nil\n      end\n\n      # Gets code input via external editor\n      #\n      # @return [String, nil] Editor content or nil if cancelled\n      def get_editor_input\n        require 'tty-editor'\n        require 'tempfile'\n\n        # Create a temporary file with appropriate extension\n        temp_file = Tempfile.new(['blueprint_', '.rb'])\n        temp_file.write(\"# Enter your code here\\n\")\n        temp_file.close\n\n        begin\n          # Get configured editor or use default\n          config = BlueprintsCLI::Configuration.new\n          editor = config.fetch(:editor, :command) || ENV['EDITOR'] || 'nano'\n\n          puts \"🖊️  Opening editor (#{editor})...\"\n\n          # Open the editor\n          if TTY::Editor.open(temp_file.path, command: editor)\n            content = File.read(temp_file.path).strip\n\n            # Remove the default comment if user didn't add anything else\n            if content == '# Enter your code here'\n              puts '❌ No code entered in editor'\n              return nil\n            end\n\n            # Remove the default comment line if it's still there\n            content = content.gsub(/^# Enter your code here\\n?/, '').strip\n\n            content.empty? ? nil : content\n          else\n            puts '❌ Editor session cancelled or failed'\n            nil\n          end\n        rescue StandardError => e\n          puts \"❌ Error opening editor: #{e.message}\"\n          nil\n        ensure\n          temp_file&.unlink\n        end\n      end\n\n      # Handles listing blueprints with various format options.\n      #\n      # @return [void]\n      def handle_blueprint_list\n        format = @prompt.select('📊 Choose format:') do |menu|\n          menu.choice 'Table', 'table'\n          menu.choice 'Summary', 'summary'\n          menu.choice 'JSON', 'json'\n        end\n\n        interactive = @prompt.yes?('🔄 Interactive mode?')\n\n        options = { 'format' => format }\n        options['interactive'] = true if interactive\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(options)\n        blueprint_command.execute('list')\n      end\n\n      # Handles viewing a specific blueprint with various format options.\n      #\n      # @return [void]\n      def handle_blueprint_view\n        id = @prompt.ask('🔍 Enter blueprint ID:')\n        return if id.nil? || id.empty?\n\n        format = @prompt.select('📊 Choose format:') do |menu|\n          menu.choice 'Detailed', 'detailed'\n          menu.choice 'Summary', 'summary'\n          menu.choice 'JSON', 'json'\n        end\n\n        analyze = @prompt.yes?('🧠 Include AI analysis?')\n\n        options = { 'format' => format }\n        options['analyze'] = true if analyze\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(options)\n        blueprint_command.execute('view', id)\n      end\n\n      # Handles editing a blueprint.\n      #\n      # @return [void]\n      def handle_blueprint_edit\n        id = @prompt.ask('✏️ Enter blueprint ID to edit:')\n        return if id.nil? || id.empty?\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n        blueprint_command.execute('edit', id)\n      end\n\n      # Handles deleting a blueprint with options for ID input or interactive selection.\n      #\n      # @return [void]\n      def handle_blueprint_delete\n        choice = @prompt.select('🗑️ How would you like to select the blueprint to delete?') do |menu|\n          menu.choice 'Enter blueprint ID', 'id'\n          menu.choice 'Select from list', 'interactive'\n        end\n\n        case choice\n        when 'id'\n          id = @prompt.ask('🗑️ Enter blueprint ID to delete:')\n          return if id.nil? || id.empty?\n\n          force = @prompt.yes?('⚠️ Skip confirmation? (Use with caution)')\n\n          args = [id]\n          args << '--force' if force\n\n          blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n          blueprint_command.execute('delete', *args)\n        when 'interactive'\n          blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n          blueprint_command.execute('delete')\n        end\n      end\n\n      # Handles searching blueprints with query and limit options.\n      #\n      # @return [void]\n      def handle_blueprint_search\n        query = @prompt.ask('🔍 Enter search query:')\n        return if query.nil? || query.empty?\n\n        limit = @prompt.ask('📊 Number of results (default 10):', default: '10')\n\n        options = { 'limit' => limit.to_i }\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(options)\n        blueprint_command.execute('search', query)\n      end\n\n      # Handles exporting a blueprint with optional output path.\n      #\n      # @return [void]\n      def handle_blueprint_export\n        id = @prompt.ask('📤 Enter blueprint ID to export:')\n        return if id.nil? || id.empty?\n\n        output_path = @prompt.ask('💾 Output file path (optional):')\n\n        args = [id]\n        args << output_path unless output_path.nil? || output_path.empty?\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n        blueprint_command.execute('export', *args)\n      end\n\n      # Handles code generation from natural language description.\n      #\n      # @return [void]\n      def handle_blueprint_generate\n        description = @prompt.ask('🤖 Describe what you want to generate:')\n        return if description.nil? || description.empty?\n\n        output_dir = @prompt.ask('📁 Output directory:', default: './generated')\n        limit = @prompt.ask('🔢 Number of blueprints to use as context:', default: '5').to_i\n        force = @prompt.yes?('⚡ Overwrite existing files?')\n\n        options = {\n          'output_dir' => output_dir,\n          'limit' => limit,\n          'force' => force\n        }\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(options)\n        blueprint_command.execute('generate', description)\n      end\n\n      # Handles blueprint configuration options.\n      #\n      # @return [void]\n      def handle_blueprint_config\n        subcommand = @prompt.select('⚙️ Configuration:') do |menu|\n          menu.choice 'Show current config', 'show'\n          menu.choice 'Setup configuration', 'setup'\n        end\n\n        blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n        blueprint_command.execute('config', subcommand)\n      end\n\n      # Handles configuration commands with various sub-options.\n      #\n      # @return [Symbol] :continue to keep the menu running\n      def handle_config_command\n        debug_log('Entering handle_config_command')\n\n        subcommand = @prompt.select('⚙️ Configuration - Choose operation:'.colorize(:blue)) do |menu|\n          menu.choice '🔧 Setup configuration', 'setup'\n          menu.choice '📋 Show current config', 'show'\n          menu.choice '✏️ Edit configuration', 'edit'\n          menu.choice '🔍 Validate configuration', 'validate'\n          menu.choice '🔄 Reset configuration', 'reset'\n          menu.choice '❓ Help', 'help'\n          menu.choice 'Back to main menu', :back\n        end\n\n        return :continue if subcommand == :back\n\n        begin\n          config_command = BlueprintsCLI::Commands::ConfigCommand.new({})\n          config_command.execute(subcommand)\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error executing config command: #{e.message}\")\n        end\n\n        :continue\n      end\n\n      # Handles the docs command submenu and operations.\n      #\n      # @return [Symbol] :continue to keep the menu running\n      def handle_docs_command\n        debug_log('Entering handle_docs_command')\n\n        subcommand = @prompt.select('📖 Documentation - Choose operation:'.colorize(:blue)) do |menu|\n          menu.choice '🏗️ Generate YARD docs for file', 'generate'\n          menu.choice '❓ Help', 'help'\n          menu.choice 'Back to main menu', :back\n        end\n\n        return :continue if subcommand == :back\n\n        case subcommand\n        when 'generate'\n          file_path = @prompt.ask('Enter the Ruby file path to document:', default: './')\n\n          begin\n            docs_command = BlueprintsCLI::Commands::DocsCommand.new({})\n            docs_command.execute('generate', file_path)\n          rescue StandardError => e\n            BlueprintsCLI.logger.failure(\"Error executing docs command: #{e.message}\")\n          end\n        when 'help'\n          begin\n            docs_command = BlueprintsCLI::Commands::DocsCommand.new({})\n            docs_command.execute('help')\n          rescue StandardError => e\n            BlueprintsCLI.logger.failure(\"Error executing docs help: #{e.message}\")\n          end\n        end\n\n        :continue\n      end\n\n      # Handles the setup command submenu and operations.\n      #\n      # @return [Symbol] :continue to keep the menu running\n      def handle_setup_command\n        debug_log('Entering handle_setup_command')\n\n        subcommand = @prompt.select('🔧 Setup - Choose operation:'.colorize(:blue)) do |menu|\n          menu.choice '🚀 Run complete setup wizard', 'wizard'\n          menu.choice '🤖 Setup AI providers only', 'providers'\n          menu.choice '🗄️ Setup database only', 'database'\n          menu.choice '📊 Setup AI models only', 'models'\n          menu.choice '✅ Verify current setup', 'verify'\n          menu.choice '❓ Help', 'help'\n          menu.choice 'Back to main menu', :back\n        end\n\n        return :continue if subcommand == :back\n\n        begin\n          setup_command = BlueprintsCLI::Commands::SetupCommand.new({})\n          setup_command.execute(subcommand)\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error executing setup command: #{e.message}\")\n        end\n\n        :continue\n      end\n\n      # Handles the logs command using tty-pager to display log files.\n      #\n      # @return [Symbol] :continue to keep the menu running\n      def handle_logs_command\n        debug_log('Entering handle_logs_command')\n\n        begin\n          # Get the default log path from the logger\n          log_path = BlueprintsCLI::Logger.send(:default_log_path)\n\n          unless File.exist?(log_path)\n            puts \"📋 No log file found at #{log_path}\".colorize(:yellow)\n            return :continue\n          end\n\n          # Display log file info\n          file_size = File.size(log_path)\n          file_mtime = File.mtime(log_path)\n          puts \"\\n📋 Log File: #{log_path}\".colorize(:cyan)\n          puts \"📊 Size: #{format_file_size(file_size)}\".colorize(:blue)\n          puts \"📅 Last Modified: #{file_mtime.strftime('%Y-%m-%d %H:%M:%S')}\".colorize(:blue)\n          puts\n\n          # Use tty-pager to display the log file\n          TTY::Pager.page(path: log_path)\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"Error viewing logs: #{e.message}\")\n          puts \"❌ Error viewing logs: #{e.message}\".colorize(:red)\n        end\n\n        :continue\n      end\n\n      # Format file size in human-readable format\n      #\n      # @param size [Integer] file size in bytes\n      # @return [String] formatted file size\n      def format_file_size(size)\n        units = %w[B KB MB GB TB]\n        unit_index = 0\n        size_float = size.to_f\n\n        while size_float >= 1024 && unit_index < units.length - 1\n          size_float /= 1024\n          unit_index += 1\n        end\n\n        if unit_index.zero?\n          \"#{size_float.to_i} #{units[unit_index]}\"\n        else\n          \"#{'%.1f' % size_float} #{units[unit_index]}\"\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "setup_command.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'base_command'\n\nmodule BlueprintsCLI\n  module Commands\n    # SetupCommand provides first-time setup and configuration management\n    # for BlueprintsCLI. It guides users through AI provider configuration,\n    # database setup, and application preferences.\n    class SetupCommand < BaseCommand\n      # Provides a description of what this command does.\n      # @return [String] A description of the command's purpose.\n      def self.description\n        'Run first-time setup wizard for BlueprintsCLI configuration'\n      end\n\n      # Initializes a new SetupCommand instance.\n      # @param [Hash] options The options to configure the command.\n      def initialize(options)\n        super\n        @prompt = TTY::Prompt.new\n      end\n\n      # Executes the setup command.\n      # @param [Array<String>] args The arguments to pass to the command.\n      def execute(*args)\n        subcommand = args.shift\n        case subcommand\n        when 'wizard', 'run', nil\n          run_setup_wizard\n        when 'providers'\n          setup_providers_only\n        when 'database'\n          setup_database_only\n        when 'models'\n          setup_models_only\n        when 'verify'\n          verify_setup\n        when 'help'\n          show_help\n        else\n          log_failure(\"Unknown subcommand: #{subcommand}\")\n          show_help\n          false\n        end\n      end\n\n      private\n\n      # Run the complete setup wizard\n      #\n      # @return [Boolean] True if setup completed successfully\n      def run_setup_wizard\n        log_step('Starting BlueprintsCLI setup wizard...')\n\n        begin\n          setup_manager = BlueprintsCLI::Setup::SetupManager.new\n\n          # Check if setup is needed\n          unless setup_manager.setup_required?\n            log_info('Setup skipped by user')\n            return true\n          end\n\n          # Run complete setup\n          success = setup_manager.run\n\n          if success\n            log_success('Setup completed successfully!')\n            display_next_steps\n          else\n            log_failure('Setup was not completed')\n          end\n\n          success\n        rescue BlueprintsCLI::Setup::SetupManager::SetupCancelledError\n          log_info('Setup cancelled by user')\n          true\n        rescue StandardError => e\n          log_failure(\"Setup failed: #{e.message}\")\n          log_debug(e.backtrace.join(\"\\n\"))\n          false\n        end\n      end\n\n      # Setup only AI providers\n      #\n      # @return [Boolean] True if provider setup completed\n      def setup_providers_only\n        log_step('Setting up AI providers...')\n\n        begin\n          setup_manager = BlueprintsCLI::Setup::SetupManager.new\n          success = setup_manager.setup_providers\n\n          if success\n            log_success('Provider setup completed!')\n          else\n            log_failure('Provider setup failed')\n          end\n\n          success\n        rescue StandardError => e\n          log_failure(\"Provider setup failed: #{e.message}\")\n          log_debug(e.backtrace.join(\"\\n\"))\n          false\n        end\n      end\n\n      # Setup only database\n      #\n      # @return [Boolean] True if database setup completed\n      def setup_database_only\n        log_step('Setting up database...')\n\n        begin\n          setup_manager = BlueprintsCLI::Setup::SetupManager.new\n          success = setup_manager.setup_database\n\n          if success\n            log_success('Database setup completed!')\n          else\n            log_failure('Database setup failed')\n          end\n\n          success\n        rescue StandardError => e\n          log_failure(\"Database setup failed: #{e.message}\")\n          log_debug(e.backtrace.join(\"\\n\"))\n          false\n        end\n      end\n\n      # Setup only AI models\n      #\n      # @return [Boolean] True if model setup completed\n      def setup_models_only\n        log_step('Setting up AI models...')\n\n        begin\n          setup_manager = BlueprintsCLI::Setup::SetupManager.new\n          success = setup_manager.setup_models\n\n          if success\n            log_success('Model setup completed!')\n          else\n            log_failure('Model setup failed')\n          end\n\n          success\n        rescue StandardError => e\n          log_failure(\"Model setup failed: #{e.message}\")\n          log_debug(e.backtrace.join(\"\\n\"))\n          false\n        end\n      end\n\n      # Verify current setup\n      #\n      # @return [Boolean] True if verification passed\n      def verify_setup\n        log_step('Verifying BlueprintsCLI setup...')\n\n        begin\n          config = BlueprintsCLI::Configuration.new\n\n          # Check configuration file exists\n          if config.exist?\n            log_success('✓ Configuration file found')\n          else\n            log_failure('✗ Configuration file missing')\n            log_tip(\"Run 'bin/blueprintsCLI setup' to create configuration\")\n            return false\n          end\n\n          # Check database configuration\n          database_url = config.database_url\n          if database_url\n            log_success('✓ Database URL configured')\n            verify_database_connection(database_url)\n          else\n            log_failure('✗ Database URL not configured')\n          end\n\n          # Check AI provider configuration\n          verify_ai_providers(config)\n\n          # Check required directories\n          verify_directories\n\n          log_success('Setup verification completed!')\n          true\n        rescue StandardError => e\n          log_failure(\"Setup verification failed: #{e.message}\")\n          log_debug(e.backtrace.join(\"\\n\"))\n          false\n        end\n      end\n\n      # Verify database connection\n      #\n      # @param database_url [String] Database URL to test\n      def verify_database_connection(database_url)\n        require 'sequel'\n        db = Sequel.connect(database_url)\n        db.test_connection\n        log_success('✓ Database connection successful')\n        db.disconnect\n      rescue StandardError => e\n        log_failure(\"✗ Database connection failed: #{e.message}\")\n      end\n\n      # Verify AI provider configuration\n      #\n      # @param config [BlueprintsCLI::Configuration] Configuration instance\n      def verify_ai_providers(config)\n        providers = %w[openai anthropic gemini deepseek]\n        found_providers = []\n\n        providers.each do |provider|\n          api_key = config.ai_api_key(provider)\n          if api_key && !api_key.empty?\n            log_success(\"✓ #{provider.capitalize} API key found\")\n            found_providers << provider\n          end\n        end\n\n        if found_providers.empty?\n          log_failure('✗ No AI provider API keys found')\n          log_tip('Set environment variables for your AI providers')\n        else\n          log_info(\"Found #{found_providers.size} configured AI provider(s)\")\n        end\n      end\n\n      # Verify required directories exist\n      def verify_directories\n        log_file_dir = File.dirname(BlueprintsCLI.configuration.fetch(:logger, :file_path,\n                                                                      default: '/tmp/app.log'))\n\n        if Dir.exist?(log_file_dir)\n          log_success('✓ Log directory exists')\n        else\n          log_warning(\"⚠ Log directory missing: #{log_file_dir}\")\n          log_tip('Directory will be created automatically when needed')\n        end\n      end\n\n      # Display next steps after successful setup\n      def display_next_steps\n        puts \"\\n🎉 Welcome to BlueprintsCLI!\"\n        puts \"\\nNext steps:\"\n        puts \"• Run 'bin/blueprintsCLI' to access the interactive menu\"\n        puts \"• Try 'bin/blueprintsCLI blueprint list' to see existing blueprints\"\n        puts \"• Submit your first blueprint with 'bin/blueprintsCLI blueprint submit'\"\n        puts \"• Generate documentation with 'bin/blueprintsCLI docs generate'\"\n        puts \"\\nFor help: bin/blueprintsCLI help\"\n      end\n\n      # Show help information\n      def show_help\n        puts <<~HELP\n          Usage: blueprintsCLI setup <subcommand> [options]\n\n          Subcommands:\n            wizard                 - Run complete setup wizard (default)\n            providers             - Setup AI providers only\n            database              - Setup database only\n            models                - Setup AI models only\n            verify                - Verify current setup\n            help                  - Show this help message\n\n          Examples:\n            bin/blueprintsCLI setup\n            bin/blueprintsCLI setup wizard\n            bin/blueprintsCLI setup providers\n            bin/blueprintsCLI setup verify\n\n          The setup wizard will guide you through:\n          • AI provider configuration (OpenAI, Anthropic, Gemini, etc.)\n          • Database setup with PostgreSQL and pgvector\n          • Model selection and configuration\n          • Application preferences and logging\n\n          For first-time users, run the complete wizard to configure everything.\n        HELP\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/commands/"
    },
    {
      "filename": "config.yml",
      "content": "---\ndatabase:\n  url: postgresql://postgres:blueprints@localhost:5432/blueprints\n  pool_size: 5\nai:\n  sublayer:\n    provider: Gemini\n    model: gemini-2.0-flash\n    project_name: BlueprintsCLI\n    template: default\n    project_template: CLI\n  rubyllm:\n    default_model: gemini-2.0-flash\n    default_embedding_model: text-embedding-004\n    default_image_model: imagen-3.0-generate-002\n    request_timeout: 120\n    max_retries: 3\n    retry_interval: 0.5\n    retry_backoff_factor: 2\n    retry_interval_randomness: 0.5\n    log_level: info\n    log_assume_model_exists: false\n    openai_api_base: https://openrouter.ai/api/v1\n  openai:\n    log_errors: true\n  embedding_model: text-embedding-004\nlogger:\n  level: info\n  console_logging: false\n  file_logging: true\n  file_level: info\n  file_path: \"/home/b08x/.local/state/BlueprintsCLI/app.log\"\n  context_enabled: true\n  context_detail_level: full\n  context_cache_size: 1000\neditor:\n  default: micro\n  auto_save: true\n  temp_dir: \"/tmp\"\nui:\n  colors: true\n  interactive: true\n  pager: most\n  auto_pager: true\n  enhanced_menu: true\n  slash_commands: true\nfeatures:\n  auto_description: true\n  auto_categorize: true\n  improvement_analysis: true\n  vector_search: true\nsearch:\n  default_limit: 10\n  semantic_search: true\n  text_search_fallback: true\nexport:\n  include_metadata: false\n  auto_detect_extension: true\nperformance:\n  batch_size: 100\n  connection_pool_size: 5\nblueprints:\n  database:\n    url: postgresql://postgres:blueprints@localhost:5432/blueprints\n  features:\n    auto_description: true\n    auto_categorize: true\n    improvement_analysis: true\n  editor: micro\n  auto_save_edits: false\n  search:\n    default_limit: 10\n    semantic_search: true\n  export:\n    include_metadata: false\n    auto_detect_extension: true\n  performance:\n    batch_size: 100\n    connection_pool_size: 5\n  ui:\n    colors: true\n    interactive: true\n    pager: true\n",
      "path": "/lib/blueprintsCLI/config/"
    },
    {
      "filename": "environment.rb",
      "content": "# frozen_string_literal: true\n\n# config/environment.rb\n\nrequire 'bundler/setup'\nBundler.require\n\n# Set up database connection using unified configuration\nENV['RACK_ENV'] ||= 'development'\nrequire_relative '../configuration'\nconfig = BlueprintsCLI::Configuration.new\nDB = Sequel.connect(config.database_url)\n\n# Load initializers\nrequire_relative 'initializers/sublayer'\n",
      "path": "/lib/blueprintsCLI/config/"
    },
    {
      "filename": "sublayer.rb",
      "content": "# frozen_string_literal: true\n\n# config/initializers/sublayer.rb\n\nrequire 'ruby_llm'\nrequire 'sublayer'\n\n# Configure Sublayer using the unified configuration system\nblueprints_config = BlueprintsCLI::Configuration.new\nsublayer_config = blueprints_config.sublayer_config\n\nSublayer.configure do |config|\n  config.ai_provider = Object.const_get(\"Sublayer::Providers::#{sublayer_config[:ai_provider]}\")\n  config.ai_model = sublayer_config[:ai_model]\nend\n\n# Configure RubyLLM using the unified configuration system\nruby_llm_config = blueprints_config.ruby_llm_config\nunless ruby_llm_config.empty?\n  RubyLLM.configure do |config|\n    ruby_llm_config.each { |key, value| config.send(\"#{key}=\", value) }\n  end\nend\n\n# Set up RubyLLM provider to match Sublayer for consistency\nbegin\n  RubyLLM.provider = Sublayer.configuration.ai_provider.new(\n    model: Sublayer.configuration.ai_model\n  )\nrescue StandardError => e\n  # Continue without RubyLLM provider setup if it fails\n  puts \"Warning: Could not set up RubyLLM provider: #{e.message}\"\nend\n\nputs \"Sublayer and RubyLLM configured to use #{Sublayer.configuration.ai_provider} with model #{Sublayer.configuration.ai_model}\"\n",
      "path": "/lib/blueprintsCLI/config/initializers/"
    },
    {
      "filename": "configuration.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-config'\nrequire 'fileutils'\nrequire 'ruby_llm'\n\n# Provider configurations are now handled by the unified config system\n# See BlueprintsCLI::Configuration#configure_providers method\n\nmodule BlueprintsCLI\n  # Unified configuration management using TTY::Config\n  #\n  # Handles configuration for:\n  # - BlueprintsCLI application settings\n  # - Sublayer AI provider configuration\n  # - Ruby LLM provider settings\n  # - Logger configuration\n  #\n  # @example Basic usage\n  #   config = BlueprintsCLI::Configuration.new\n  #   config.fetch(:blueprints, :database, :url)\n  #\n  # @example Environment variables\n  #   ENV['BLUEPRINTS_DATABASE_URL'] = 'postgres://...'\n  #   config.fetch(:blueprints, :database, :url) # Returns env var value\n  class Configuration\n    # Error raised when configuration validation fails\n    ValidationError = Class.new(StandardError)\n\n    # Error raised when required configuration is missing\n    MissingConfigError = Class.new(StandardError)\n\n    # Default configuration file name\n    DEFAULT_FILENAME = 'config'\n\n    # Default configuration file extension\n    DEFAULT_EXTENSION = '.yml'\n\n    # Environment variable prefix for auto-mapping\n    ENV_PREFIX = 'BLUEPRINTS'\n\n    # The TTY::Config instance\n    attr_reader :config\n\n    # Initialize configuration with optional custom paths\n    #\n    # @param config_paths [Array<String>] Additional paths to search for config files\n    # @param filename [String] Configuration filename (without extension)\n    # @param auto_load [Boolean] Whether to automatically load configuration files\n    def initialize(config_paths: [], filename: DEFAULT_FILENAME, auto_load: true)\n      @config = TTY::Config.new\n      setup_config(config_paths, filename)\n      load_configuration if auto_load\n      setup_validations\n    end\n\n    # Fetch a configuration value using nested keys\n    #\n    # @param keys [Array<Symbol,String>] Nested keys to fetch\n    # @param default [Object] Default value if key not found\n    # @return [Object] The configuration value\n    #\n    # @example\n    #   config.fetch(:blueprints, :database, :url)\n    #   config.fetch(:ai, :sublayer, :provider, default: 'gemini')\n    def fetch(*keys, default: nil)\n      @config.fetch(*keys, default: default)\n    end\n\n    # Set a configuration value using nested keys\n    #\n    # @param keys [Array<Symbol,String>] Nested keys to set\n    # @param value [Object] Value to set\n    # @return [Object] The set value\n    #\n    # @example\n    #   config.set(:blueprints, :database, :url, value: 'postgres://...')\n    def set(*keys, value:)\n      @config.set(*keys, value: value)\n      # NOTE: We don't validate on set because it may cause issues during initial setup\n      value\n    end\n\n    # Check if configuration file exists\n    #\n    # @return [Boolean] True if config file exists\n    def exist?\n      @config.exist?\n    end\n\n    # Write current configuration to file\n    #\n    # @param force [Boolean] Whether to overwrite existing file\n    # @param create [Boolean] Whether to create missing directories\n    # @return [Boolean] True if write succeeded\n    def write(force: false, create: true)\n      @config.write(force: force, create: create)\n      true\n    rescue TTY::Config::WriteError => e\n      BlueprintsCLI.logger.failure(\"Failed to write configuration: #{e.message}\")\n      false\n    end\n\n    # Reload configuration from file and environment\n    #\n    # @return [self]\n    def reload!\n      @config = TTY::Config.new\n      setup_config([], DEFAULT_FILENAME)\n      load_configuration\n      setup_validations\n      self\n    end\n\n    # Get configuration file path\n    #\n    # @return [String, nil] Path to configuration file or nil if not found\n    def config_file_path\n      @config.source_file\n    end\n\n    # Convert configuration to hash\n    #\n    # @return [Hash] Configuration as hash\n    def to_hash\n      @config.to_hash\n    end\n    alias to_h to_hash\n\n    # Validate entire configuration\n    #\n    # @return [Array<String>] Array of validation error messages (empty if valid)\n    def validate!\n      errors = []\n\n      begin\n        validate_blueprints!\n      rescue ValidationError => e\n        errors << e.message\n      end\n\n      begin\n        validate_ai!\n      rescue ValidationError => e\n        errors << e.message\n      end\n\n      begin\n        validate_logger!\n      rescue ValidationError => e\n        errors << e.message\n      end\n\n      unless errors.empty?\n        raise ValidationError,\n              \"Configuration validation failed:\\n#{errors.join(\"\\n\")}\"\n      end\n\n      true\n    end\n\n    # Check if configuration is valid\n    #\n    # @return [Boolean] True if configuration is valid\n    def valid?\n      validate!\n      true\n    rescue ValidationError\n      false\n    end\n\n    # Get database URL with environment variable fallback\n    #\n    # @return [String, nil] Database URL\n    def database_url\n      fetch(:blueprints, :database, :url) ||\n        ENV['BLUEPRINT_DATABASE_URL'] ||\n        ENV['DATABASE_URL'] ||\n        build_database_url\n    end\n\n    # Build database URL from individual components\n    #\n    # @return [String] Constructed database URL\n    def build_database_url\n      host = ENV['DB_HOST'] || 'localhost'\n      port = ENV['DB_PORT'] || '5432'\n      user = ENV['DB_USER'] || 'postgres'\n      password = ENV['DB_PASSWORD'] || 'blueprints'\n      database = ENV['DB_NAME'] || 'blueprints'\n\n      \"postgresql://#{user}:#{password}@#{host}:#{port}/#{database}\"\n    end\n\n    # Get AI provider API key for given provider\n    #\n    # @param provider [String, Symbol] AI provider name\n    # @return [String, nil] API key\n    def ai_api_key(provider)\n      case provider.to_s.downcase\n      when 'gemini', 'google'\n        ENV['GEMINI_API_KEY'] || ENV['GOOGLE_API_KEY']\n      when 'openai'\n        # Support both OpenRouter and direct OpenAI\n        ENV['OPENROUTER_API_KEY'] || ENV['OPENAI_API_KEY']\n      when 'anthropic'\n        ENV['ANTHROPIC_API_KEY']\n      when 'deepseek'\n        ENV['DEEPSEEK_API_KEY']\n      end\n    end\n\n    # Get Sublayer configuration hash\n    #\n    # @return [Hash] Sublayer configuration\n    def sublayer_config\n      {\n        project_name: fetch(:ai, :sublayer, :project_name, default: 'blueprintsCLI'),\n        project_template: fetch(:ai, :sublayer, :project_template, default: 'CLI'),\n        ai_provider: fetch(:ai, :sublayer, :provider, default: 'Gemini'),\n        ai_model: fetch(:ai, :sublayer, :model, default: 'gemini-2.0-flash')\n      }\n    end\n\n    # Get Ruby LLM configuration hash\n    #\n    # @return [Hash] Ruby LLM configuration\n    def ruby_llm_config\n      config_hash = {}\n\n      # Add API keys that are available\n      config_hash[:openai_api_key] = ai_api_key(:openai) if ai_api_key(:openai)\n      config_hash[:anthropic_api_key] = ai_api_key(:anthropic) if ai_api_key(:anthropic)\n      config_hash[:gemini_api_key] = ai_api_key(:gemini) if ai_api_key(:gemini)\n      config_hash[:deepseek_api_key] = ai_api_key(:deepseek) if ai_api_key(:deepseek)\n\n      # Add custom API base if configured\n      config_hash[:openai_api_base] = fetch(:ai, :ruby_llm, :openai_api_base) if fetch(:ai,\n                                                                                       :ruby_llm, :openai_api_base)\n\n      config_hash\n    end\n\n    # Interactive configuration setup\n    def interactive_setup\n      require 'tty-prompt'\n      prompt = TTY::Prompt.new\n\n      puts '🔧 BlueprintsCLI Interactive Configuration Setup'\n      puts '=' * 50\n\n      # Database configuration\n      configure_database_interactive(prompt)\n\n      # AI provider configuration\n      configure_ai_interactive(prompt)\n\n      # Logger configuration\n      configure_logger_interactive(prompt)\n\n      # Editor configuration\n      configure_editor_interactive(prompt)\n\n      # Save configuration\n      save_config\n\n      true\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error during interactive setup: #{e.message}\")\n      false\n    end\n\n    # Individual configuration methods for edit command\n    def configure_logger\n      configure_logger_interactive(TTY::Prompt.new)\n    end\n\n    def configure_paths\n      prompt = TTY::Prompt.new\n      puts \"\\n📁 Path Configuration\"\n\n      temp_dir = prompt.ask('Temporary directory:', default: fetch(:editor, :temp_dir) || '/tmp')\n      set(:editor, :temp_dir, value: temp_dir)\n    end\n\n    def configure_display\n      prompt = TTY::Prompt.new\n      puts \"\\n🎨 Display Configuration\"\n\n      colors = prompt.yes?('Enable colored output?', default: fetch(:ui, :colors, default: true))\n      set(:ui, :colors, value: colors)\n\n      interactive_mode = prompt.yes?('Enable interactive prompts?',\n                                     default: fetch(:ui, :interactive, default: true))\n      set(:ui, :interactive, value: interactive_mode)\n\n      pager = prompt.ask('Pager command:', default: fetch(:ui, :pager) || 'most')\n      set(:ui, :pager, value: pager)\n    end\n\n    def configure_restic\n      # Placeholder for restic configuration if needed\n      puts \"\\n💾 Restic Configuration (not implemented yet)\"\n    end\n\n    def configure_terminals\n      # Placeholder for terminal configuration if needed\n      puts \"\\n🖥️  Terminal Configuration (not implemented yet)\"\n    end\n\n    # Save current configuration to file\n    def save_config\n      write(force: true)\n    end\n\n    private\n\n    # Validate terminal command availability\n    def validate_terminal_command\n      # This is a placeholder validation - just return true for now\n      # Could be extended to check if configured terminal commands are available\n      true\n    end\n\n    # Configure database settings interactively\n    def configure_database_interactive(prompt)\n      puts \"\\n📊 Database Configuration\"\n\n      current_url = fetch(:database, :url) || fetch(:blueprints, :database, :url)\n      database_url = prompt.ask('Database URL:', default: current_url)\n\n      set(:database, :url, value: database_url) if database_url\n    end\n\n    # Configure AI provider settings interactively\n    def configure_ai_interactive(prompt)\n      puts \"\\n🤖 AI Provider Configuration\"\n\n      provider = prompt.select('Select AI provider:', %w[Gemini OpenAI Anthropic DeepSeek])\n      set(:ai, :sublayer, :provider, value: provider)\n\n      case provider.downcase\n      when 'gemini'\n        api_key = prompt.mask('Gemini API Key (leave empty to use environment variable):')\n        set(:ai, :provider_keys, :gemini, value: api_key) unless api_key.empty?\n      when 'openai'\n        api_key = prompt.mask('OpenAI API Key (leave empty to use environment variable):')\n        set(:ai, :provider_keys, :openai, value: api_key) unless api_key.empty?\n      when 'anthropic'\n        api_key = prompt.mask('Anthropic API Key (leave empty to use environment variable):')\n        set(:ai, :provider_keys, :anthropic, value: api_key) unless api_key.empty?\n      when 'deepseek'\n        api_key = prompt.mask('DeepSeek API Key (leave empty to use environment variable):')\n        set(:ai, :provider_keys, :deepseek, value: api_key) unless api_key.empty?\n      end\n    end\n\n    # Configure logger settings interactively\n    def configure_logger_interactive(prompt)\n      puts \"\\n📝 Logger Configuration\"\n\n      level = prompt.select('Console log level:', %w[debug info warn error fatal])\n      set(:logger, :level, value: level)\n\n      file_logging = prompt.yes?('Enable file logging?')\n      set(:logger, :file_logging, value: file_logging)\n\n      return unless file_logging\n\n      file_level = prompt.select('File log level:', %w[debug info warn error fatal])\n      set(:logger, :file_level, value: file_level)\n\n      file_path = prompt.ask('Log file path:', default: default_log_path)\n      set(:logger, :file_path, value: file_path)\n    end\n\n    # Configure editor settings interactively\n    def configure_editor_interactive(prompt)\n      puts \"\\n✏️  Editor Configuration\"\n\n      current_editor = fetch(:editor, :default) || ENV['EDITOR'] || ENV['VISUAL'] || 'vim'\n      editor = prompt.ask('Default editor:', default: current_editor)\n      set(:editor, :default, value: editor)\n\n      auto_save = prompt.yes?('Enable auto-save for edits?')\n      set(:editor, :auto_save, value: auto_save)\n    end\n\n    # Setup TTY::Config with paths and environment mapping\n    def setup_config(config_paths, filename)\n      @config.filename = filename\n      @config.extname = DEFAULT_EXTENSION\n      @config.env_prefix = ENV_PREFIX\n      @config.env_separator = '_'\n      @config.autoload_env\n\n      # Add default search paths\n      default_paths = [\n        File.join(Dir.home, '.config', 'BlueprintsCLI'),\n        File.join(Dir.home, '.blueprintsCLI'),\n        File.join(__dir__, 'config'),\n        Dir.pwd\n      ]\n\n      (default_paths + config_paths).each do |path|\n        @config.append_path(path) if Dir.exist?(path)\n      end\n    end\n\n    # Load configuration from file and set defaults\n    def load_configuration\n      # Try to read existing configuration file\n      begin\n        @config.read if @config.exist?\n      rescue TTY::Config::ReadError => e\n        # Can't use BlueprintsCLI.logger here as it may not be initialized yet\n        warn \"Failed to read configuration file: #{e.message}\"\n      end\n\n      # Set default values\n      set_defaults\n\n      # Map common environment variables\n      setup_env_mappings\n\n      # Configure external providers\n      configure_providers\n    end\n\n    # Set default configuration values\n    def set_defaults\n      # Blueprints defaults\n      @config.set_if_empty(:blueprints, :database, :url,\n                           value: 'postgresql://postgres:blueprints@localhost:5432/blueprints')\n      @config.set_if_empty(:blueprints, :features, :auto_description, value: true)\n      @config.set_if_empty(:blueprints, :features, :auto_categorize, value: true)\n      @config.set_if_empty(:blueprints, :features, :improvement_analysis, value: true)\n      @config.set_if_empty(:blueprints, :editor, value: ENV['EDITOR'] || ENV['VISUAL'] || 'vim')\n      @config.set_if_empty(:blueprints, :auto_save_edits, value: false)\n      @config.set_if_empty(:blueprints, :search, :default_limit, value: 10)\n      @config.set_if_empty(:blueprints, :search, :semantic_search, value: true)\n      @config.set_if_empty(:blueprints, :export, :include_metadata, value: false)\n      @config.set_if_empty(:blueprints, :export, :auto_detect_extension, value: true)\n      @config.set_if_empty(:blueprints, :performance, :batch_size, value: 100)\n      @config.set_if_empty(:blueprints, :performance, :connection_pool_size, value: 5)\n      @config.set_if_empty(:blueprints, :ui, :colors, value: true)\n      @config.set_if_empty(:blueprints, :ui, :interactive, value: true)\n      @config.set_if_empty(:blueprints, :ui, :pager, value: true)\n\n      # AI defaults\n      @config.set_if_empty(:ai, :sublayer, :project_name, value: 'blueprintsCLI')\n      @config.set_if_empty(:ai, :sublayer, :project_template, value: 'CLI')\n      @config.set_if_empty(:ai, :sublayer, :provider, value: 'Gemini')\n      @config.set_if_empty(:ai, :sublayer, :model, value: 'gemini-2.0-flash')\n      @config.set_if_empty(:ai, :embedding_model, value: 'text-embedding-004')\n\n      # RubyLLM defaults\n      @config.set_if_empty(:ai, :rubyllm, :default_model, value: 'gemini-2.0-flash')\n      @config.set_if_empty(:ai, :rubyllm, :default_embedding_model, value: 'text-embedding-004')\n      @config.set_if_empty(:ai, :rubyllm, :default_image_model, value: 'imagen-3.0-generate-002')\n      @config.set_if_empty(:ai, :rubyllm, :request_timeout, value: 120)\n      @config.set_if_empty(:ai, :rubyllm, :max_retries, value: 3)\n      @config.set_if_empty(:ai, :rubyllm, :retry_interval, value: 0.5)\n      @config.set_if_empty(:ai, :rubyllm, :retry_backoff_factor, value: 2)\n      @config.set_if_empty(:ai, :rubyllm, :retry_interval_randomness, value: 0.5)\n      @config.set_if_empty(:ai, :rubyllm, :log_level, value: 'info')\n      @config.set_if_empty(:ai, :rubyllm, :log_assume_model_exists, value: false)\n\n      # OpenAI gem defaults\n      @config.set_if_empty(:ai, :openai, :log_errors, value: true)\n\n      # Logger defaults\n      @config.set_if_empty(:logger, :level, value: 'info')\n      @config.set_if_empty(:logger, :file_logging, value: false)\n      @config.set_if_empty(:logger, :file_level, value: 'debug')\n      @config.set_if_empty(:logger, :file_path, value: default_log_path)\n    end\n\n    # Setup environment variable mappings\n    def setup_env_mappings\n      # Database\n      @config.set_from_env(:blueprints, :database, :url) { 'BLUEPRINT_DATABASE_URL' }\n      @config.set_from_env(:blueprints, :database, :url) { 'DATABASE_URL' }\n\n      # Editor\n      @config.set_from_env(:blueprints, :editor) { 'EDITOR' }\n      @config.set_from_env(:blueprints, :editor) { 'VISUAL' }\n\n      # Debug mode\n      @config.set_from_env(:blueprints, :debug) { 'DEBUG' }\n      @config.set_from_env(:blueprints, :debug) { 'BLUEPRINTS_DEBUG' }\n\n      # AI Provider API keys\n      @config.set_from_env(:ai, :provider_keys, :openai) { 'OPENAI_API_KEY' }\n      @config.set_from_env(:ai, :provider_keys, :gemini) { 'GEMINI_API_KEY' }\n      @config.set_from_env(:ai, :provider_keys, :gemini) { 'GOOGLE_API_KEY' }\n      @config.set_from_env(:ai, :provider_keys, :anthropic) { 'ANTHROPIC_API_KEY' }\n      @config.set_from_env(:ai, :provider_keys, :deepseek) { 'DEEPSEEK_API_KEY' }\n      @config.set_from_env(:ai, :provider_keys, :openai_access_token) { 'OPENAI_ACCESS_TOKEN' }\n      @config.set_from_env(:ai, :provider_keys, :openai_base_uri) { 'OPENAI_BASE_URI' }\n      @config.set_from_env(:ai, :rubyllm, :openai_api_key) { 'OPENAI_API_KEY' }\n      @config.set_from_env(:ai, :rubyllm, :openai_api_base) { 'OPENAI_API_BASE' }\n    end\n\n    # Setup validation rules\n    def setup_validations\n      # Database URL validation\n      @config.validate(:blueprints, :database, :url) do |key, value|\n        unless value.is_a?(String) && !value.empty?\n          raise ValidationError,\n                \"#{key} must be a non-empty string\"\n        end\n\n        unless value.start_with?('postgres://') || value.start_with?('postgresql://')\n          raise ValidationError, \"#{key} must be a PostgreSQL URL (postgres:// or postgresql://)\"\n        end\n      end\n\n      # Feature flags validation\n      @config.validate(:blueprints, :features, :auto_description) do |key, value|\n        raise ValidationError, \"#{key} must be true or false\" unless [true, false].include?(value)\n      end\n\n      @config.validate(:blueprints, :features, :auto_categorize) do |key, value|\n        raise ValidationError, \"#{key} must be true or false\" unless [true, false].include?(value)\n      end\n\n      # Numeric validations\n      @config.validate(:blueprints, :search, :default_limit) do |key, value|\n        unless value.is_a?(Integer) && value.positive?\n          raise ValidationError,\n                \"#{key} must be a positive integer\"\n        end\n      end\n\n      @config.validate(:blueprints, :performance, :batch_size) do |key, value|\n        unless value.is_a?(Integer) && value.positive?\n          raise ValidationError,\n                \"#{key} must be a positive integer\"\n        end\n      end\n\n      # AI provider validation\n      @config.validate(:ai, :sublayer, :provider) do |key, value|\n        valid_providers = %w[Gemini OpenAI Anthropic DeepSeek]\n        unless valid_providers.include?(value)\n          raise ValidationError, \"#{key} must be one of: #{valid_providers.join(', ')}\"\n        end\n      end\n\n      # Logger level validation\n      @config.validate(:logger, :level) do |key, value|\n        valid_levels = %w[debug info warn error fatal]\n        unless valid_levels.include?(value.to_s.downcase)\n          raise ValidationError, \"#{key} must be one of: #{valid_levels.join(', ')}\"\n        end\n      end\n\n      # RubyLLM timeout validation\n      @config.validate(:ai, :rubyllm, :request_timeout) do |key, value|\n        unless value.is_a?(Integer) && value.positive?\n          raise ValidationError,\n                \"#{key} must be a positive integer\"\n        end\n      end\n\n      # RubyLLM retry validation\n      @config.validate(:ai, :rubyllm, :max_retries) do |key, value|\n        unless value.is_a?(Integer) && value >= 0\n          raise ValidationError,\n                \"#{key} must be a non-negative integer\"\n        end\n      end\n\n      # RubyLLM retry interval validation\n      @config.validate(:ai, :rubyllm, :retry_interval) do |key, value|\n        unless value.is_a?(Numeric) && value >= 0\n          raise ValidationError,\n                \"#{key} must be a non-negative number\"\n        end\n      end\n\n      # RubyLLM log level validation\n      @config.validate(:ai, :rubyllm, :log_level) do |key, value|\n        valid_levels = %w[debug info warn]\n        unless valid_levels.include?(value.to_s.downcase)\n          raise ValidationError, \"#{key} must be one of: #{valid_levels.join(', ')}\"\n        end\n      end\n\n      # RubyLLM boolean validation\n      @config.validate(:ai, :rubyllm, :log_assume_model_exists) do |key, value|\n        raise ValidationError, \"#{key} must be true or false\" unless [true, false].include?(value)\n      end\n    end\n\n    # Validate blueprints section\n    def validate_blueprints!\n      database_url = fetch(:blueprints, :database, :url)\n      # Only validate if we're not using the default fallback\n      return unless database_url.nil? || (database_url.empty? && !ENV['BLUEPRINT_DATABASE_URL'] && !ENV['DATABASE_URL'])\n\n      raise ValidationError, 'Database URL is required'\n    end\n\n    # Validate AI section\n    def validate_ai!\n      provider = fetch(:ai, :sublayer, :provider)\n      model = fetch(:ai, :sublayer, :model)\n\n      raise ValidationError, 'AI provider is required' if provider.nil? || provider.empty?\n\n      raise ValidationError, 'AI model is required' if model.nil? || model.empty?\n\n      # Check if API key is available for the provider\n      api_key = ai_api_key(provider)\n      return unless api_key.nil? || api_key.empty?\n\n      # Can't use BlueprintsCLI.logger here as it may not be initialized yet\n      warn \"No API key found for AI provider '#{provider}'. Set the appropriate environment variable.\"\n    end\n\n    # Validate logger section\n    def validate_logger!\n      level = fetch(:logger, :level)\n      if level && !%w[debug info warn error fatal].include?(level.to_s.downcase)\n        raise ValidationError, \"Invalid logger level: #{level}\"\n      end\n\n      return unless fetch(:logger, :file_logging) && fetch(:logger, :file_path).nil?\n\n      raise ValidationError, 'Logger file path is required when file logging is enabled'\n    end\n\n    # Get default log file path\n    def default_log_path\n      state_home = ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')\n      File.join(state_home, 'BlueprintsCLI', 'app.log')\n    end\n\n    # Configure external provider libraries based on unified configuration\n    def configure_providers\n      configure_rubyllm\n      configure_openai_gem\n    end\n\n    # Configure RubyLLM with settings from unified config system\n    def configure_rubyllm\n      RubyLLM.configure do |config|\n        # API Keys - use the existing ai_api_key method that checks environment variables\n        config.openai_api_key = ai_api_key(:openai)\n        config.gemini_api_key = ai_api_key(:gemini)\n        config.anthropic_api_key = ai_api_key(:anthropic)\n        config.deepseek_api_key = ai_api_key(:deepseek)\n\n        # Custom endpoint\n        config.openai_api_base = fetch(:ai, :rubyllm, :openai_api_base)\n\n        # Default models\n        config.default_model = fetch(:ai, :rubyllm, :default_model)\n        config.default_embedding_model = fetch(:ai, :rubyllm, :default_embedding_model)\n        config.default_image_model = fetch(:ai, :rubyllm, :default_image_model)\n\n        # Connection settings\n        config.request_timeout = fetch(:ai, :rubyllm, :request_timeout)\n        config.max_retries = fetch(:ai, :rubyllm, :max_retries)\n        config.retry_interval = fetch(:ai, :rubyllm, :retry_interval)\n        config.retry_backoff_factor = fetch(:ai, :rubyllm, :retry_backoff_factor)\n        config.retry_interval_randomness = fetch(:ai, :rubyllm, :retry_interval_randomness)\n\n        # Logging settings\n        log_file = fetch(:ai, :rubyllm, :log_file)\n        config.log_file = log_file unless log_file.nil?\n        config.log_level = fetch(:ai, :rubyllm, :log_level)&.to_sym || :info\n        config.log_assume_model_exists = fetch(:ai, :rubyllm, :log_assume_model_exists)\n      end\n    rescue StandardError => e\n      # Can't use BlueprintsCLI.logger here as it may not be initialized yet\n      warn \"Error configuring RubyLLM: #{e.message}\"\n    end\n\n    # Configure legacy OpenAI gem with settings from unified config system\n    def configure_openai_gem\n      return unless defined?(OpenAI)\n\n      OpenAI.configure do |config|\n        # Use environment variables directly for OpenAI gem\n        access_token = ENV['OPENAI_ACCESS_TOKEN'] || ai_api_key(:openai)\n        base_uri = ENV['OPENAI_BASE_URI']\n\n        config.access_token = access_token if access_token\n        config.uri_base = base_uri if base_uri\n        config.log_errors = fetch(:ai, :openai, :log_errors, default: true)\n      end\n    rescue StandardError => e\n      # Can't use BlueprintsCLI.logger here as it may not be initialized yet\n      warn \"Error configuring OpenAI gem: #{e.message}\"\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "database.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\nrequire 'pgvector'\nrequire_relative 'db/interface'\n# Temporarily comment out enhanced RAG for testing\n# require_relative 'nlp/enhanced_rag_service'\n# require_relative 'models/cache_models'\n# require_relative 'services/informers_embedding_service'\n\nmodule BlueprintsCLI\n  # Provides a direct database interface for managing \"blueprints\" (code snippets).\n  #\n  # This class encapsulates all database operations for blueprints, including\n  # standard CRUD actions, category management, and advanced vector-based\n  # similarity searches. It uses the Sequel ORM to interact with a PostgreSQL\n  # database (requiring the `pgvector` extension for search) and leverages the\n  # Google Gemini API to generate text embeddings for semantic search capabilities.\n  #\n  # Configuration is loaded from the unified configuration system via\n  # `BlueprintsCLI::Configuration`, environment variables, or sensible defaults.\n  #\n  class BlueprintDatabase\n    include BlueprintsCLI::Interfaces::DatabaseInterface\n\n    # @!attribute [r] db\n    #   @return [Sequel::Database] The active Sequel database connection instance.\n    # @!attribute [r] rag_service\n    #   @return [BlueprintsCLI::NLP::EnhancedRagService] The enhanced RAG service for NLP processing.\n    # @!attribute [r] cache_manager\n    #   @return [BlueprintsCLI::Models::CacheManager] The cache manager for intelligent caching.\n    attr_reader :db, :rag_service, :cache_manager\n\n    #\n    # Initializes the database connection and validates the schema.\n    #\n    # Connects to the PostgreSQL database using a URL determined by the provided\n    # parameter, a configuration file, or environment variables. It also ensures\n    # that the necessary tables (`blueprints`, `categories`, `blueprints_categories`)\n    # and the `pgvector` extension exist.\n    #\n    # @param database_url [String, nil] The PostgreSQL connection URL. If nil,\n    #   it falls back to `BLUEPRINT_DATABASE_URL` or `DATABASE_URL`\n    #   environment variables, or a default local URL.\n    #\n    # @raise [StandardError] If the database connection fails or a required\n    #   table is missing from the schema.\n    #\n    def initialize(database_url: nil, rag_config: {})\n      @database_url = database_url || load_database_url\n      @db = connect_to_database\n      # Temporarily disable enhanced RAG for testing\n      # @cache_manager = Models::CacheManager.new\n      # @rag_service = NLP::EnhancedRagService.new(rag_config)\n\n      validate_database_schema\n\n      # Temporarily disable search index rebuilding\n      # rebuild_search_index\n    end\n\n    #\n    # Creates a new blueprint, generates its embedding, and associates categories.\n    #\n    # This method inserts a new blueprint into the database within a transaction.\n    # It automatically generates a vector embedding from the blueprint's name and\n    # description using the Gemini API. If categories are provided, they are\n    # created if they don't exist and linked to the new blueprint.\n    #\n    # @param code [String] The code content for the blueprint.\n    # @param name [String, nil] A name for the blueprint.\n    # @param description [String, nil] A description of the blueprint's purpose.\n    # @param categories [Array<String>] A list of category names to associate.\n    #\n    # @return [Hash, nil] A hash representing the complete blueprint record\n    #   (including its new ID and categories), or `nil` if an error occurs.\n    #\n    # @example\n    #   db.create_blueprint(\n    #     code: \"puts 'Hello, World!'\",\n    #     name: \"Hello World Snippet\",\n    #     description: \"A simple Ruby script to print a greeting.\",\n    #     categories: [\"Ruby\", \"Examples\"]\n    #   )\n    #   # => {id: 1, code: \"...\", name: \"...\", ..., categories: [{id: 1, title: \"Ruby\"}, ...]}\n    #\n    def create_blueprint(code:, name: nil, description: nil, categories: [], language: 'ruby',\n                         file_type: '.rb', blueprint_type: 'code', parser_type: 'ruby')\n      @db.transaction do\n        # Prepare blueprint data for enhanced processing\n        {\n          code: code,\n          name: name,\n          description: description,\n          categories: categories\n        }\n\n        # Process through enhanced RAG pipeline\n        # rag_result = @rag_service.process_blueprint(blueprint_data)\n\n        # Use traditional embedding generation (enhanced RAG disabled)\n        content_to_embed = { name: name, description: description }.to_json\n        begin\n          embedding_result = RubyLLM.embed(content_to_embed)\n          # Extract the actual vector array from the result\n          embedding_vector = embedding_result.vectors\n        rescue RubyLLM::Error => e\n          # Fallback to a zero vector if embedding fails\n          BlueprintsCLI.logger.warn(\"RubyLLM embedding failed: #{e.message}, using zero vector\")\n          embedding_vector = Array.new(768, 0.0)\n        rescue StandardError => e\n          # Handle other errors\n          BlueprintsCLI.logger.warn(\"Embedding generation failed: #{e.message}, using zero vector\")\n          embedding_vector = Array.new(768, 0.0)\n        end\n\n        # Insert blueprint record with enhanced metadata\n        blueprint_id = @db[:blueprints].insert(\n          code: code,\n          name: name,\n          description: description,\n          language: language,\n          file_type: file_type,\n          blueprint_type: blueprint_type,\n          parser_type: parser_type,\n          embedding: Pgvector.encode(embedding_vector),\n          # nlp_metadata: rag_result.to_json,\n          created_at: Time.now,\n          updated_at: Time.now\n        )\n\n        # Store in cache for future access (disabled for now)\n        # @cache_manager.store(:pipeline, blueprint_data.to_json, @rag_service.config, rag_result)\n\n        # Handle categories if provided\n        insert_blueprint_categories(blueprint_id, categories) if categories.any?\n\n        # Update search index (disabled for now)\n        # blueprint_data.merge(id: blueprint_id)\n        # @rag_service.update_search_index(blueprint_id, rag_result)\n\n        # Return the blueprint\n        get_blueprint(blueprint_id)\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error creating blueprint: #{e.message}\")\n      nil\n    end\n\n    #\n    # Retrieves a specific blueprint and its associated categories by ID.\n    #\n    # @param id [Integer] The unique identifier of the blueprint.\n    #\n    # @return [Hash, nil] A hash containing the blueprint's data and a nested\n    #   `:categories` array, or `nil` if no blueprint with that ID is found.\n    #\n    # @example\n    #   blueprint = db.get_blueprint(42)\n    #   # => {id: 42, name: \"My Blueprint\", ..., categories: [...]}\n    #\n    def get_blueprint(id)\n      blueprint = @db[:blueprints].where(id: id).first\n      return nil unless blueprint\n\n      # Add categories\n      blueprint[:categories] = get_blueprint_categories(id)\n\n      # Add enhanced NLP metadata if available\n      if blueprint[:nlp_metadata]\n        begin\n          blueprint[:nlp_analysis] = JSON.parse(blueprint[:nlp_metadata])\n        rescue JSON::ParserError\n          # Ignore parsing errors for metadata\n        end\n      end\n\n      blueprint\n    end\n\n    #\n    # Lists all blueprints with pagination, ordered by creation date.\n    #\n    # Retrieves a collection of blueprints, with the most recently created ones\n    # appearing first. Each blueprint in the returned array includes its\n    # associated categories.\n    #\n    # @param limit [Integer] The maximum number of blueprints to return.\n    # @param offset [Integer] The number of blueprints to skip, for pagination.\n    #\n    # @return [Array<Hash>] An array of blueprint hashes.\n    #\n    # @example\n    #   # Get the 10 most recent blueprints\n    #   recent_blueprints = db.list_blueprints(limit: 10)\n    #\n    #   # Get the next page of 10 blueprints\n    #   next_page = db.list_blueprints(limit: 10, offset: 10)\n    #\n    def list_blueprints(limit: 100, offset: 0)\n      blueprints = @db[:blueprints]\n                   .order(Sequel.desc(:created_at))\n                   .limit(limit)\n                   .offset(offset)\n                   .all\n\n      # Add categories for each blueprint\n      blueprints.each do |blueprint|\n        blueprint[:categories] = get_blueprint_categories(blueprint[:id])\n      end\n\n      blueprints\n    end\n\n    #\n    # Searches for blueprints by semantic similarity to a query string.\n    #\n    # This method generates a vector embedding for the `query` text and uses\n    # `pgvector`'s cosine distance operator (`<->`) to find the most semantically\n    # similar blueprints in the database. Results are ordered by similarity.\n    #\n    # @param query [String] The search query text.\n    # @param limit [Integer] The maximum number of search results to return.\n    #\n    # @return [Array<Hash>] An array of blueprint hashes, sorted by relevance.\n    #   Each hash includes a `:distance` key indicating similarity (lower is better).\n    #   Returns an empty array if query embedding fails.\n    #\n    # @example\n    #   results = db.search_blueprints(query: \"http server in ruby\", limit: 5)\n    #   # => [{id: 12, ..., distance: 0.18}, {id: 34, ..., distance: 0.21}]\n    #\n    def search_blueprints(query:, limit: 10, enhanced: true)\n      if enhanced\n        # Use enhanced RAG service for hybrid search\n        search_options = {\n          max_results: limit,\n          relevance_threshold: 0.3,\n          include_patterns: true,\n          boost_exact_matches: true\n        }\n\n        rag_search_result = @rag_service.search_blueprints(query, search_options)\n\n        # Convert RAG results to database format\n        blueprint_ids = rag_search_result[:results].filter_map do |r|\n          r[:blueprint_id] || r[:text_id]\n        end\n        return [] if blueprint_ids.empty?\n\n        # Fetch full blueprint data\n        results = @db[:blueprints].where(id: blueprint_ids).all\n\n        # Add categories and enhance with RAG analysis\n        results.each do |blueprint|\n          blueprint[:categories] = get_blueprint_categories(blueprint[:id])\n\n          # Add RAG search metadata\n          rag_match = rag_search_result[:results].find do |r|\n            (r[:blueprint_id] || r[:text_id]) == blueprint[:id]\n          end\n          blueprint[:search_metadata] = rag_match if rag_match\n          blueprint[:query_analysis] = rag_search_result[:query_analysis]\n        end\n\n        # Sort by RAG relevance score\n        results.sort_by { |b| -(b.dig(:search_metadata, :final_score) || 0) }\n      else\n        # Fallback to traditional vector search\n        traditional_vector_search(query, limit)\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error in enhanced search: #{e.message}\")\n      # Fallback to traditional search on error\n      traditional_vector_search(query, limit)\n    end\n\n    #\n    # Deletes a blueprint and its category associations from the database.\n    #\n    # The deletion is performed in a transaction to ensure atomicity. It first\n    # removes links in the `blueprints_categories` join table before deleting\n    # the main blueprint record.\n    #\n    # @param id [Integer] The ID of the blueprint to delete.\n    #\n    # @return [Boolean] `true` if a record was successfully deleted, `false`\n    #   otherwise (e.g., if the ID did not exist or an error occurred).\n    #\n    def delete_blueprint(id)\n      @db.transaction do\n        # Delete category associations\n        @db[:blueprints_categories].where(blueprint_id: id).delete\n\n        # Delete the blueprint\n        deleted_count = @db[:blueprints].where(id: id).delete\n        deleted_count > 0\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error deleting blueprint: #{e.message}\")\n      false\n    end\n\n    #\n    # Updates the attributes of an existing blueprint.\n    #\n    # This method updates a blueprint's data in a transaction. If `name` or\n    # `description` are changed, the embedding vector is automatically\n    # regenerated. If a `categories` array is provided, it will **replace**\n    # all existing category associations for the blueprint.\n    #\n    # @param id [Integer] The ID of the blueprint to update.\n    # @param code [String, nil] The new code content.\n    # @param name [String, nil] The new name.\n    # @param description [String, nil] The new description.\n    # @param categories [Array<String>, nil] An array of category names to\n    #   set for the blueprint, replacing any existing ones.\n    #\n    # @return [Hash, nil] The updated blueprint hash, or `nil` on failure.\n    #\n    def update_blueprint(id:, code: nil, name: nil, description: nil, categories: nil)\n      updates = { updated_at: Time.now }\n      updates[:code] = code if code\n      updates[:name] = name if name\n      updates[:description] = description if description\n\n      # Regenerate embedding if name or description changed\n      if name || description\n        current = get_blueprint(id)\n        new_name = name || current[:name]\n        new_description = description || current[:description]\n        content_to_embed = { name: new_name, description: new_description }.to_json\n        begin\n          embedding_result = RubyLLM.embed(content_to_embed)\n          embedding_vector = embedding_result.vectors\n          updates[:embedding] = Pgvector.encode(embedding_vector)\n        rescue RubyLLM::Error => e\n          BlueprintsCLI.logger.warn(\"Update embedding failed: #{e.message}\")\n          # Skip embedding update on failure\n        rescue StandardError => e\n          BlueprintsCLI.logger.warn(\"Update embedding generation failed: #{e.message}\")\n          # Skip embedding update on failure\n        end\n      end\n\n      @db.transaction do\n        # Update blueprint\n        @db[:blueprints].where(id: id).update(updates)\n\n        # Update categories if provided\n        if categories\n          @db[:blueprints_categories].where(blueprint_id: id).delete\n          insert_blueprint_categories(id, categories)\n        end\n\n        # Return updated blueprint\n        get_blueprint(id)\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error updating blueprint: #{e.message}\")\n      nil\n    end\n\n    #\n    # Retrieves all available categories from the database.\n    #\n    # @return [Array<Hash>] An array of hashes, where each hash represents a category.\n    #\n    def get_categories\n      @db[:categories].all\n    end\n\n    #\n    # Creates a new category or finds an existing one by title.\n    #\n    # If a category with the given title already exists, this method will not\n    # create a duplicate. Instead, it will find and return the ID of the\n    # existing category.\n    #\n    # @param title [String] The unique title for the category.\n    # @param description [String, nil] An optional description for the category.\n    #\n    # @return [Integer] The ID of the created or existing category.\n    #\n    def create_category(title:, description: nil)\n      @db[:categories].insert(\n        title: title,\n        created_at: Time.now,\n        updated_at: Time.now\n      )\n    rescue Sequel::UniqueConstraintViolation\n      # Category already exists, find and return it\n      @db[:categories].where(title: title).first[:id]\n    end\n\n    #\n    # Gathers basic statistics about the blueprints database.\n    #\n    # Provides a quick summary, including total counts of blueprints and\n    # categories, and the database URL (with the password redacted).\n    #\n    # @return [Hash{Symbol => Object}] A hash with `:total_blueprints`,\n    #   `:total_categories`, and `:database_url` keys.\n    #\n    def stats\n      basic_stats = {\n        total_blueprints: @db[:blueprints].count,\n        total_categories: @db[:categories].count,\n        database_url: @database_url.gsub(/:[^:@]*@/, ':***@') # Hide password\n      }\n\n      # Add enhanced RAG statistics\n      rag_stats = @rag_service.get_statistics\n      cache_stats = @cache_manager.statistics\n\n      basic_stats.merge({\n                          enhanced_features: {\n                            rag_service: rag_stats,\n                            cache_performance: cache_stats,\n                            nlp_enabled: true,\n                            search_index_size: rag_stats[:search_index_stats] || {}\n                          }\n                        })\n    rescue StandardError => e\n      BlueprintsCLI.logger.warn(\"Error gathering enhanced stats: #{e.message}\")\n      basic_stats\n    end\n\n    # Find similar blueprints using enhanced RAG service\n    def find_similar_blueprints(blueprint_id, options = {})\n      @rag_service.find_similar_blueprints(blueprint_id, options)\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error finding similar blueprints: #{e.message}\")\n      []\n    end\n\n    # Analyze code patterns for a blueprint\n    def analyze_blueprint_patterns(blueprint_id)\n      blueprint = get_blueprint(blueprint_id)\n      return {} unless blueprint\n\n      @rag_service.analyze_code_patterns(blueprint)\n    rescue StandardError => e\n      BlueprintsCLI.logger.failure(\"Error analyzing blueprint patterns: #{e.message}\")\n      {}\n    end\n\n    # Rebuild the search index with all existing blueprints\n    def rebuild_search_index\n      blueprints = list_blueprints(limit: 10_000) # Get all blueprints\n      @rag_service.rebuild_search_index(blueprints)\n    rescue StandardError => e\n      BlueprintsCLI.logger.warn(\"Error rebuilding search index: #{e.message}\")\n    end\n\n    # Get enhanced search suggestions based on query\n    def get_search_suggestions(partial_query, limit: 5)\n      # Use Trie-based prefix search from RAG service\n      suggestions = []\n\n      # Get recent searches from cache\n      if @rag_service.search_index && @rag_service.search_index[:trie]\n        trie = @rag_service.search_index[:trie]\n        matches = trie.wildcard(\"#{partial_query.downcase}*\")\n        suggestions = matches.first(limit)\n      end\n\n      suggestions\n    rescue StandardError => e\n      BlueprintsCLI.logger.warn(\"Error getting search suggestions: #{e.message}\")\n      []\n    end\n\n    # Get blueprint recommendations based on user patterns\n    def get_recommendations(user_context = {}, limit: 5)\n      # Use priority queue from RAG service to get top-ranked blueprints\n      if @rag_service.search_index && @rag_service.search_index[:priority_rankings]\n        recommendations = []\n        temp_queue = @rag_service.search_index[:priority_rankings].dup\n\n        count = 0\n        while !temp_queue.empty? && count < limit\n          ranked_item = temp_queue.pop\n          blueprint_id = ranked_item[:blueprint_id] || ranked_item[:text_id]\n          blueprint = get_blueprint(blueprint_id) if blueprint_id\n          recommendations << blueprint if blueprint\n          count += 1\n        end\n\n        recommendations\n      else\n        # Fallback to recent blueprints\n        list_blueprints(limit: limit)\n      end\n    rescue StandardError => e\n      BlueprintsCLI.logger.warn(\"Error getting recommendations: #{e.message}\")\n      list_blueprints(limit: limit)\n    end\n\n    private\n\n    #\n    # Loads the database URL from the unified configuration system.\n    #\n    # @!visibility private\n    # @return [String] The database connection URL.\n    #\n    def load_database_url\n      BlueprintsCLI.configuration.database_url\n    end\n\n    #\n    # Establishes a connection to the database using Sequel.\n    #\n    # @!visibility private\n    # @return [Sequel::Database] The database connection object.\n    # @raise [StandardError] If the connection fails.\n    #\n    def connect_to_database\n      Sequel.connect(@database_url)\n    rescue StandardError => e\n      BlueprintsCLI.logger.fatal(\"Failed to connect to database: #{e.message}\")\n      puts \"Database URL: #{@database_url.gsub(/:[^:@]*@/, ':***@')}\".colorize(:yellow)\n      raise e\n    end\n\n    #\n    # Validates that the required database tables and extensions exist.\n    #\n    # @!visibility private\n    # @raise [StandardError] If a required table is not found.\n    #\n    def validate_database_schema\n      required_tables = %i[blueprints categories blueprints_categories]\n\n      required_tables.each do |table|\n        raise \"Missing required table: #{table}. Please ensure the blueprints database is properly set up.\" unless @db.table_exists?(table)\n      end\n\n      # Check for vector extension\n      return if @db.fetch(\"SELECT 1 FROM pg_extension WHERE extname = 'vector'\").first\n\n      BlueprintsCLI.logger.warn('pgvector extension not found. Vector search may not work.')\n    end\n\n    #\n    # Fetches all categories associated with a given blueprint ID.\n    #\n    # @!visibility private\n    # @param blueprint_id [Integer] The blueprint's ID.\n    # @return [Array<Hash>] An array of category hashes.\n    #\n    def get_blueprint_categories(blueprint_id)\n      @db.fetch(\n        \"SELECT c.* FROM categories c\n           JOIN blueprints_categories bc ON c.id = bc.category_id\n           WHERE bc.blueprint_id = ?\",\n        blueprint_id\n      ).all\n    end\n\n    #\n    # Associates a list of categories with a blueprint.\n    #\n    # For each category name, it finds or creates the category record and then\n    # creates a link in the `blueprints_categories` join table.\n    #\n    # @!visibility private\n    # @param blueprint_id [Integer] The ID of the blueprint to link.\n    # @param category_names [Array<String>] The names of the categories to link.\n    #\n    def insert_blueprint_categories(blueprint_id, category_names)\n      category_names.each do |category_name|\n        category_name = category_name.strip\n        next if category_name.empty?\n\n        # Find or create category\n        category = @db[:categories].where(title: category_name).first\n        category_id = if category\n                        category[:id]\n                      else\n                        create_category(title: category_name)\n                      end\n\n        # Link blueprint to category\n        @db[:blueprints_categories].insert_ignore.insert(\n          blueprint_id: blueprint_id,\n          category_id: category_id\n        )\n      end\n    end\n\n    # Traditional vector search fallback\n    def traditional_vector_search(query, limit)\n      # Generate embedding for the search query\n      begin\n        query_embedding_result = RubyLLM.embed(query)\n        query_embedding_vector = query_embedding_result.vectors\n      rescue RubyLLM::Error => e\n        BlueprintsCLI.logger.warn(\"Search embedding failed: #{e.message}\")\n        return []\n      rescue StandardError => e\n        BlueprintsCLI.logger.warn(\"Search embedding generation failed: #{e.message}\")\n        return []\n      end\n\n      return [] unless query_embedding_vector&.any?\n\n      query_embedding = Pgvector.encode(query_embedding_vector)\n\n      # Perform vector similarity search using pgvector\n      results = @db.fetch(\n        \"SELECT *, embedding <-> ? AS distance\n           FROM blueprints\n           ORDER BY embedding <-> ?\n           LIMIT ?\",\n        query_embedding, query_embedding, limit\n      ).all\n\n      # Add categories for each result\n      results.each do |blueprint|\n        blueprint[:categories] = get_blueprint_categories(blueprint[:id])\n      end\n\n      results\n    end\n\n    # Generate fallback embedding using RubyLLM\n    def generate_fallback_embedding(blueprint_data)\n      content_to_embed = {\n        name: blueprint_data[:name],\n        description: blueprint_data[:description]\n      }.to_json\n\n      embedding_result = RubyLLM.embed(content_to_embed)\n      embedding_result.vectors\n    rescue RubyLLM::Error => e\n      BlueprintsCLI.logger.warn(\"RubyLLM fallback embedding failed: #{e.message}\")\n      # Return zero vector as last resort\n      Array.new(768, 0.0)\n    rescue StandardError => e\n      BlueprintsCLI.logger.warn(\"Error generating fallback embedding: #{e.message}\")\n      # Return zero vector as last resort\n      Array.new(768, 0.0)\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "interface.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Interfaces\n    ##\n    # DatabaseInterface defines the contract for database operations.\n    #\n    # This interface specifies the methods that any database wrapper implementation\n    # must provide for CRUD operations, search functionality, and statistics.\n    #\n    # @example Implementing the interface\n    #   class MyDatabaseWrapper\n    #     include BlueprintsCLI::Interfaces::DatabaseInterface\n    #\n    #     def create_record(data)\n    #       # Implementation here\n    #     end\n    #\n    #     # ... other interface methods\n    #   end\n    module DatabaseInterface\n      ##\n      # Creates a new record in the database.\n      #\n      # @abstract\n      # @param data [Hash] The data for the new record\n      # @return [Hash, nil] The created record with assigned ID, or nil if creation failed\n      # @raise [NotImplementedError] if not implemented\n      def create_record(data)\n        raise NotImplementedError, \"#{self.class} must implement #create_record\"\n      end\n\n      ##\n      # Retrieves a record by its ID.\n      #\n      # @abstract\n      # @param id [Integer, String] The ID of the record to retrieve\n      # @return [Hash, nil] The record data, or nil if not found\n      # @raise [NotImplementedError] if not implemented\n      def get_record(id)\n        raise NotImplementedError, \"#{self.class} must implement #get_record\"\n      end\n\n      ##\n      # Updates an existing record.\n      #\n      # @abstract\n      # @param id [Integer, String] The ID of the record to update\n      # @param data [Hash] The updated data\n      # @return [Hash, nil] The updated record, or nil if update failed\n      # @raise [NotImplementedError] if not implemented\n      def update_record(id, data)\n        raise NotImplementedError, \"#{self.class} must implement #update_record\"\n      end\n\n      ##\n      # Deletes a record by its ID.\n      #\n      # @abstract\n      # @param id [Integer, String] The ID of the record to delete\n      # @return [Boolean] true if the record was deleted, false otherwise\n      # @raise [NotImplementedError] if not implemented\n      def delete_record(id)\n        raise NotImplementedError, \"#{self.class} must implement #delete_record\"\n      end\n\n      ##\n      # Lists records with pagination support.\n      #\n      # @abstract\n      # @param limit [Integer] The maximum number of records to return\n      # @param offset [Integer] The number of records to skip\n      # @return [Array<Hash>] An array of record hashes\n      # @raise [NotImplementedError] if not implemented\n      def list_records(limit: 100, offset: 0)\n        raise NotImplementedError, \"#{self.class} must implement #list_records\"\n      end\n\n      ##\n      # Searches records based on a query.\n      #\n      # @abstract\n      # @param query [String] The search query\n      # @param limit [Integer] The maximum number of results to return\n      # @return [Array<Hash>] An array of matching record hashes\n      # @raise [NotImplementedError] if not implemented\n      def search_records(query, limit: 10)\n        raise NotImplementedError, \"#{self.class} must implement #search_records\"\n      end\n\n      ##\n      # Returns database statistics.\n      #\n      # @abstract\n      # @return [Hash] A hash containing database statistics\n      # @raise [NotImplementedError] if not implemented\n      def stats\n        raise NotImplementedError, \"#{self.class} must implement #stats\"\n      end\n\n      ##\n      # Gets the database connection object.\n      #\n      # @abstract\n      # @return [Object] The database connection object\n      # @raise [NotImplementedError] if not implemented\n      def connection\n        raise NotImplementedError, \"#{self.class} must implement #connection\"\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/"
    },
    {
      "filename": "20240102183532_create_blueprints.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  change do\n    create_table(:blueprints) do\n      primary_key :id\n      String :name, text: true\n      String :description, text: true\n      String :code, text: true\n      DateTime :created_at, null: false\n      DateTime :updated_at, null: false\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "20240102183853_enable_vector_extension.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  up do\n    # This migration enables the pgvector extension in the PostgreSQL database.\n    # The `IF NOT EXISTS` clause prevents an error if the extension is already enabled.\n    run 'CREATE EXTENSION IF NOT EXISTS vector;'\n  end\n\n  down do\n    # This block defines how to reverse the migration.\n    run 'DROP EXTENSION IF EXISTS vector;'\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "20240102183854_add_vector_column_to_blueprints.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  change do\n    # This migration adds the `embedding` column to the `blueprints` table.\n    # The column type is `vector(768)`, which is provided by the pgvector extension.\n    # The number 768 corresponds to the dimensions of the embeddings generated\n    # by the \"text-embedding-004\" model from Google Gemini.\n    add_column :blueprints, :embedding, 'vector(768)'\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "20240307204210_create_categories.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  change do\n    create_table(:categories) do\n      primary_key :id\n      String :name, null: false, unique: true\n      DateTime :created_at, null: false\n      DateTime :updated_at, null: false\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "20240307204431_create_join_table_blueprint_category.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  change do\n    # This migration creates the join table for the many-to-many relationship\n    # between blueprints and categories.\n    create_table(:blueprints_categories) do\n      # Foreign keys to link to the blueprints and categories tables.\n      foreign_key :blueprint_id, :blueprints, null: false, on_delete: :cascade\n      foreign_key :category_id, :categories, null: false, on_delete: :cascade\n\n      # A composite primary key to ensure that each blueprint-category pair is unique.\n      primary_key %i[blueprint_id category_id]\n\n      # An index to speed up queries on the join table.\n      index %i[blueprint_id category_id]\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "20250712200427_add_language_and_type_fields_to_blueprints.rb",
      "content": "# frozen_string_literal: true\n\nSequel.migration do\n  change do\n    alter_table(:blueprints) do\n      add_column :language, String, default: 'ruby'        # Programming language (ruby, python, javascript, etc.)\n      add_column :file_type, String, default: '.rb'        # File extension (.rb, .py, .js, .yml, etc.)\n      add_column :blueprint_type, String, default: 'code'  # High-level category (code, configuration, template, etc.)\n      add_column :parser_type, String, default: 'ruby'     # Parser to use (ruby, ansible, react, python, etc.)\n\n      add_index :blueprints, :language\n      add_index :blueprints, :blueprint_type\n      add_index :blueprints, :parser_type\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/migrate/"
    },
    {
      "filename": "blueprint.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'sequel'\nrequire 'pgvector'\n\n# Represents a single code blueprint in the database.\n# This model includes logic for timestamping, associations, and vector-based search.\n# Supports multiple programming languages and file types for diverse blueprint management.\nclass Blueprint < Sequel::Model\n  # Use the timestamps plugin to automatically manage created_at and updated_at fields.\n  plugin :timestamps, update_on_create: true\n\n  # Set up the many-to-many relationship with the Category model.\n  # The join table is implicitly assumed to be :blueprints_categories.\n  many_to_many :categories\n\n  # Language detection mapping based on file extensions\n  LANGUAGE_MAPPING = {\n    '.rb' => 'ruby',\n    '.py' => 'python',\n    '.js' => 'javascript',\n    '.jsx' => 'javascript',\n    '.ts' => 'typescript',\n    '.tsx' => 'typescript',\n    '.java' => 'java',\n    '.cpp' => 'cpp',\n    '.c' => 'c',\n    '.cs' => 'csharp',\n    '.php' => 'php',\n    '.go' => 'go',\n    '.rs' => 'rust',\n    '.swift' => 'swift',\n    '.kt' => 'kotlin',\n    '.scala' => 'scala',\n    '.clj' => 'clojure',\n    '.hs' => 'haskell',\n    '.elm' => 'elm',\n    '.yml' => 'yaml',\n    '.yaml' => 'yaml',\n    '.json' => 'json',\n    '.xml' => 'xml',\n    '.html' => 'html',\n    '.css' => 'css',\n    '.scss' => 'scss',\n    '.sass' => 'sass',\n    '.less' => 'less',\n    '.sh' => 'bash',\n    '.ps1' => 'powershell',\n    '.sql' => 'sql',\n    '.dockerfile' => 'dockerfile',\n    '.tf' => 'terraform',\n    '.vue' => 'vue',\n    '.svelte' => 'svelte'\n  }.freeze\n\n  # Parser type mapping for different blueprint categories\n  PARSER_MAPPING = {\n    'ruby' => 'ruby',\n    'python' => 'python',\n    'javascript' => 'javascript',\n    'typescript' => 'javascript',\n    'yaml' => 'ansible',\n    'json' => 'json',\n    'dockerfile' => 'docker',\n    'terraform' => 'terraform',\n    'vue' => 'vue',\n    'svelte' => 'svelte'\n  }.freeze\n\n  # Blueprint type classification\n  BLUEPRINT_TYPES = {\n    'code' => %w[ruby python javascript typescript java cpp c csharp php\n      go rust swift kotlin scala clojure haskell elm],\n    'configuration' => %w[yaml json xml],\n    'template' => %w[html css scss sass less],\n    'script' => %w[bash powershell],\n    'infrastructure' => %w[dockerfile terraform],\n    'database' => ['sql'],\n    'frontend' => %w[vue svelte]\n  }.freeze\n\n  # Automatically detect and set language, file_type, blueprint_type, and parser_type\n  # based on the provided filename or content analysis\n  #\n  # @param filename [String, nil] The filename to analyze for type detection\n  # @return [Hash] Hash containing detected types\n  def self.detect_types(filename = nil)\n    if filename\n      ext = File.extname(filename.downcase)\n      language = LANGUAGE_MAPPING[ext] || 'text'\n      file_type = ext.empty? ? '.txt' : ext\n    else\n      language = 'text'\n      file_type = '.txt'\n    end\n\n    blueprint_type = BLUEPRINT_TYPES.find do |_type, langs|\n      langs.include?(language)\n    end&.first || 'other'\n    parser_type = PARSER_MAPPING[language] || language\n\n    {\n      language: language,\n      file_type: file_type,\n      blueprint_type: blueprint_type,\n      parser_type: parser_type\n    }\n  end\n\n  # Filter blueprints by language\n  #\n  # @param language [String] The programming language to filter by\n  # @return [Sequel::Dataset] Filtered dataset\n  def self.by_language(language)\n    where(language: language)\n  end\n\n  # Filter blueprints by blueprint type\n  #\n  # @param type [String] The blueprint type to filter by\n  # @return [Sequel::Dataset] Filtered dataset\n  def self.by_type(type)\n    where(blueprint_type: type)\n  end\n\n  # Filter blueprints by parser type\n  #\n  # @param parser [String] The parser type to filter by\n  # @return [Sequel::Dataset] Filtered dataset\n  def self.by_parser(parser)\n    where(parser_type: parser)\n  end\n\n  # Get supported languages\n  #\n  # @return [Array<String>] Array of supported programming languages\n  def self.supported_languages\n    LANGUAGE_MAPPING.values.uniq.sort\n  end\n\n  # Get supported blueprint types\n  #\n  # @return [Array<String>] Array of supported blueprint types\n  def self.supported_blueprint_types\n    BLUEPRINT_TYPES.keys.sort\n  end\n\n  # Performs a search for blueprints.\n  # If a query is provided, it performs a semantic vector search.\n  # Otherwise, it returns the most recently created blueprints.\n  #\n  # @param query [String, nil] The search term.\n  # @return [Sequel::Dataset] A dataset of blueprints.\n  def self.search(query)\n    if query && !query.strip.empty?\n      begin\n        # Generate an embedding for the search query.\n        embedding_result = RubyLLM.embed(query)\n        embedding_vector = embedding_result.vectors\n\n        # Use the pgvector cosine distance operator (<->) to find the nearest neighbors.\n        # The results are ordered by their distance to the query embedding (lower is better).\n        order(Sequel.lit('embedding <-> ?', Pgvector.encode(embedding_vector))).limit(20)\n      rescue RubyLLM::Error => e\n        # Fall back to text search if embedding fails\n        puts \"Warning: Search embedding failed: #{e.message}\"\n        where(Sequel.ilike(:name, \"%#{query}%\") | Sequel.ilike(:description, \"%#{query}%\"))\n          .order(Sequel.desc(:created_at)).limit(20)\n      rescue StandardError => e\n        puts \"Warning: Search failed: #{e.message}\"\n        where(Sequel.ilike(:name, \"%#{query}%\") | Sequel.ilike(:description, \"%#{query}%\"))\n          .order(Sequel.desc(:created_at)).limit(20)\n      end\n    else\n      # If no query is provided, return the 20 most recent blueprints.\n      order(Sequel.desc(:created_at)).limit(20)\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/db/models/"
    },
    {
      "filename": "category.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'sequel'\n\n# Represents a category that can be used to tag and organize blueprints.\nclass Category < Sequel::Model\n  # Use the timestamps plugin to automatically manage created_at and updated_at fields.\n  plugin :timestamps, update_on_create: true\n\n  # Set up the many-to-many relationship with the Blueprint model.\n  # The join table is implicitly assumed to be :blueprints_categories.\n  many_to_many :blueprints\nend\n",
      "path": "/lib/blueprintsCLI/db/models/"
    },
    {
      "filename": "enhanced_logger.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'forwardable'\n\nmodule BlueprintsCLI\n  # EnhancedLogger provides context-aware logging by wrapping TTY::Logger\n  # and automatically capturing class/method information from the call stack.\n  #\n  # This logger maintains backward compatibility with existing logging calls\n  # while adding rich context information including class names, method names,\n  # file paths, and line numbers.\n  #\n  # @example Basic usage\n  #   logger = EnhancedLogger.new(base_logger)\n  #   logger.info(\"Processing data\")  # Automatically includes context\n  #\n  # @example With custom context\n  #   logger.info(\"Custom message\", class: \"MyClass\", method: \"my_method\")\n  class EnhancedLogger\n    # Delegate most methods to the underlying TTY::Logger instance\n    extend Forwardable\n    def_delegators :@base_logger, :level, :level=, :add_type, :handlers, :handlers=\n\n    # Standard log levels that should include context\n    LOG_METHODS = %i[debug info warn error fatal success failure tip step].freeze\n\n    # Initialize the enhanced logger wrapper\n    #\n    # @param base_logger [TTY::Logger] The underlying TTY::Logger instance\n    # @param context_enabled [Boolean] Whether to automatically capture context\n    # @param context_detail_level [Symbol] Level of detail for context (:minimal, :standard, :full)\n    # @param context_cache_size [Integer] Maximum size of the context cache\n    def initialize(base_logger, context_enabled: true, context_detail_level: :full,\n                   context_cache_size: 1000)\n      @base_logger = base_logger\n      @context_enabled = context_enabled\n      @context_detail_level = context_detail_level\n      @context_cache_size = context_cache_size\n      @context_cache = {}\n\n      # Define enhanced logging methods that include context\n      LOG_METHODS.each do |method|\n        define_singleton_method(method) do |message = nil, **data|\n          enhanced_log(method, message, **data)\n        end\n      end\n    end\n\n    # Enable or disable automatic context capture\n    #\n    # @param enabled [Boolean] Whether to capture context automatically\n    attr_writer :context_enabled\n\n    # Check if context capture is enabled\n    #\n    # @return [Boolean] True if context capture is enabled\n    def context_enabled?\n      @context_enabled\n    end\n\n    private\n\n    # Enhanced logging method that adds context information\n    #\n    # @param level [Symbol] The log level method to call\n    # @param message [String] The log message\n    # @param data [Hash] Additional structured data\n    def enhanced_log(level, message = nil, **data)\n      # Add context information if enabled and not already provided\n      if @context_enabled && !data.key?(:class) && !data.key?(:method)\n        context = extract_context\n        data = data.merge(context) if context\n      end\n\n      # Call the original logging method with enhanced data\n      if message\n        @base_logger.public_send(level, message, **data)\n      else\n        @base_logger.public_send(level, **data)\n      end\n    end\n\n    # Extract class and method context from the call stack\n    #\n    # @param skip_frames [Integer] Number of stack frames to skip\n    # @return [Hash, nil] Context hash with class, method, file, line info\n    def extract_context(skip_frames = 3)\n      # Get caller information, skipping internal frames\n      caller_info = caller_locations(skip_frames, 1)&.first\n      return nil unless caller_info\n\n      # Cache key for performance optimization\n      cache_key = \"#{caller_info.path}:#{caller_info.lineno}\"\n      return @context_cache[cache_key] if @context_cache[cache_key]\n\n      # Extract method name from the caller\n      method_name = extract_method_name(skip_frames + 1)\n\n      # Extract class name by examining the call stack\n      class_name = extract_class_name(skip_frames + 1)\n\n      # Build context based on detail level\n      context = build_context_by_level(class_name, method_name, caller_info)\n\n      # Cache the result for performance (with size limit)\n      if context&.any?\n        manage_cache_size\n        @context_cache[cache_key] = context\n      end\n\n      context&.any? ? context : nil\n    end\n\n    # Extract method name from caller stack\n    #\n    # @param skip_frames [Integer] Number of frames to skip\n    # @return [String, nil] The method name or nil if not found\n    def extract_method_name(skip_frames)\n      # Get the method name from caller\n      caller_line = caller(skip_frames, 1)&.first\n      return nil unless caller_line\n\n      # Extract method name using regex (handles various formats)\n      method_match = caller_line[/`([^']*)'/, 1]\n      method_match unless method_match == 'rescue in <main>' || method_match&.start_with?('<')\n    end\n\n    # Extract class name by walking up the call stack\n    #\n    # @param skip_frames [Integer] Number of frames to skip\n    # @return [String, nil] The class name or nil if not found\n    def extract_class_name(skip_frames)\n      # Look through several frames to find a class context\n      (skip_frames..(skip_frames + 10)).each do |frame_index|\n        location = caller_locations(frame_index, 1)&.first\n        break unless location\n\n        # Try to determine class from the file path and method context\n        file_path = location.path\n\n        # Skip internal Ruby/gem files\n        next if file_path.include?('/gems/') || file_path.include?('/ruby/')\n\n        # Look for BlueprintsCLI classes in the path\n        next unless file_path.include?('blueprintsCLI')\n\n        # Extract class name from file path\n        relative_path = file_path.split('blueprintsCLI').last\n        if relative_path&.include?('commands')\n          # Handle command classes\n          return extract_command_class_name(relative_path)\n        elsif relative_path&.include?('actions')\n          # Handle action classes\n          return extract_action_class_name(relative_path)\n        elsif relative_path&.include?('services')\n          # Handle service classes\n          return extract_service_class_name(relative_path)\n        end\n      end\n\n      nil\n    end\n\n    # Extract command class name from file path\n    #\n    # @param path [String] Relative path within blueprintsCLI\n    # @return [String, nil] The command class name\n    def extract_command_class_name(path)\n      return unless path.include?('commands') && path.end_with?('.rb')\n\n      filename = File.basename(path, '.rb')\n      # Convert snake_case to CamelCase and add Command suffix\n      class_base = filename.split('_').map(&:capitalize).join\n      \"BlueprintsCLI::Commands::#{class_base}\" unless class_base == 'BaseCommand'\n    end\n\n    # Extract action class name from file path\n    #\n    # @param path [String] Relative path within blueprintsCLI\n    # @return [String, nil] The action class name\n    def extract_action_class_name(path)\n      return unless path.include?('actions') && path.end_with?('.rb')\n\n      filename = File.basename(path, '.rb')\n      class_base = filename.split('_').map(&:capitalize).join\n      \"BlueprintsCLI::Actions::#{class_base}\"\n    end\n\n    # Extract service class name from file path\n    #\n    # @param path [String] Relative path within blueprintsCLI\n    # @return [String, nil] The service class name\n    def extract_service_class_name(path)\n      return unless path.include?('services') && path.end_with?('.rb')\n\n      filename = File.basename(path, '.rb')\n      class_base = filename.split('_').map(&:capitalize).join\n      \"BlueprintsCLI::Services::#{class_base}\"\n    end\n\n    # Build context hash based on configured detail level\n    #\n    # @param class_name [String, nil] The extracted class name\n    # @param method_name [String, nil] The extracted method name\n    # @param caller_info [Thread::Backtrace::Location] Caller location info\n    # @return [Hash] Context hash with appropriate level of detail\n    def build_context_by_level(class_name, method_name, caller_info)\n      case @context_detail_level\n      when :minimal\n        # Just class and method\n        { class: class_name, method: method_name }.compact\n      when :standard\n        # Class, method, and file\n        {\n          class: class_name,\n          method: method_name,\n          file: File.basename(caller_info.path)\n        }.compact\n      when :full\n        # Full context with line numbers\n        {\n          class: class_name,\n          method: method_name,\n          file: File.basename(caller_info.path),\n          line: caller_info.lineno,\n          path: caller_info.path\n        }.compact\n      else\n        # Default to standard if unknown level\n        {\n          class: class_name,\n          method: method_name,\n          file: File.basename(caller_info.path)\n        }.compact\n      end\n    end\n\n    # Manage cache size to prevent memory bloat\n    def manage_cache_size\n      return unless @context_cache.size >= @context_cache_size\n\n      # Remove oldest 25% of entries when cache is full\n      entries_to_remove = @context_cache_size / 4\n      @context_cache = @context_cache.to_a.drop(entries_to_remove).to_h\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "enhanced_menu.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'cli_ui_integration'\nrequire_relative 'slash_command_parser'\n\nmodule BlueprintsCLI\n  # EnhancedMenu provides an advanced interactive interface with slash commands\n  # and autocomplete functionality using CLI-UI framework\n  class EnhancedMenu\n    def initialize\n      @running = true\n      CLIUIIntegration.initialize!\n    end\n\n    # Start the enhanced interactive session\n    def start\n      show_welcome_banner\n\n      loop do\n        break unless @running\n\n        begin\n          handle_user_input\n        rescue Interrupt, EOFError\n          handle_exit\n          break\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:Error: #{e.message}}}\")\n          BlueprintsCLI.logger.error(\"Enhanced menu error: #{e.message}\")\n        end\n      end\n    end\n\n    private\n\n    def show_welcome_banner\n      CLIUIIntegration.frame('🚀 BlueprintsCLI Enhanced Interactive Mode', color: :cyan) do\n        CLIUIIntegration.puts('{{green:Welcome to BlueprintsCLI!}}')\n        CLIUIIntegration.puts('')\n        CLIUIIntegration.puts('{{yellow:💡 Tips:}}')\n        CLIUIIntegration.puts('  • Use slash commands: {{blue:/blueprint submit}}, {{blue:/search ruby}}')\n        CLIUIIntegration.puts('  • Press {{blue:TAB}} for autocomplete')\n        CLIUIIntegration.puts('  • Type {{blue:/help}} for available commands')\n        CLIUIIntegration.puts('  • Type {{blue:/exit}} or press {{blue:Ctrl+C}} to quit')\n        CLIUIIntegration.puts('')\n      end\n    end\n\n    def handle_user_input\n      # Get user input with support for slash commands\n      input = get_user_input\n\n      return if input.nil? || input.empty?\n\n      # Check if it's a slash command\n      parser = SlashCommandParser.new(input)\n\n      if parser.slash_command?\n        if parser.valid?\n          result = parser.execute\n          unless result\n            CLIUIIntegration.puts('{{yellow:Command failed or incomplete. Try {{blue:/help}} for assistance.}}')\n          end\n        else\n          handle_invalid_slash_command(parser)\n        end\n      else\n        # Handle regular text input (could be used for search, etc.)\n        handle_regular_input(input)\n      end\n    end\n\n    def get_user_input\n      # Custom prompt with slash command support\n      CLIUIIntegration.raw_puts('')\n      print \"#{::CLI::UI.fmt('{{cyan:blueprintsCLI}}')} #{::CLI::UI.fmt('{{blue:>}}')} \"\n\n      input = $stdin.gets&.chomp\n      input&.strip\n    end\n\n    def handle_invalid_slash_command(parser)\n      CLIUIIntegration.puts(\"{{red:Invalid command: #{parser.input}}}\")\n\n      # Suggest completions if available\n      completions = parser.completions\n      if completions.any?\n        CLIUIIntegration.puts('{{yellow:Did you mean:}}')\n        completions.first(5).each do |completion|\n          CLIUIIntegration.puts(\"  {{blue:#{completion}}}\")\n        end\n      else\n        CLIUIIntegration.puts('Type {{blue:/help}} to see available commands.')\n      end\n    end\n\n    def handle_regular_input(input)\n      # If it's not a slash command, treat it as a search query\n      if input.strip.length > 2\n        CLIUIIntegration.puts(\"{{yellow:Searching for: \\\"#{input}\\\"...}}\")\n\n        begin\n          blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n          blueprint_command.execute('search', input)\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:Search failed: #{e.message}}}\")\n        end\n      else\n        CLIUIIntegration.puts('{{yellow:Enter a slash command or search term. Type {{blue:/help}} for assistance.}}')\n      end\n    end\n\n    def handle_exit\n      CLIUIIntegration.puts('')\n      CLIUIIntegration.puts('{{green:👋 Thank you for using BlueprintsCLI!}}')\n      @running = false\n    end\n\n    # Enhanced menu selection with CLI-UI for fallback scenarios\n    def show_traditional_menu\n      CLIUIIntegration.frame('Choose an option', color: :blue) do\n        choice = CLIUIIntegration.select('What would you like to do?') do |menu|\n          menu.option('📋 Manage Blueprints') { :blueprints }\n          menu.option('⚙️ Configuration') { :config }\n          menu.option('📖 Documentation') { :docs }\n          menu.option('🔧 Setup') { :setup }\n          menu.option('🔍 Quick Search') { :search }\n          menu.option('❓ Help') { :help }\n          menu.option('🚪 Exit') { :exit }\n        end\n\n        handle_traditional_choice(choice)\n      end\n    end\n\n    def handle_traditional_choice(choice)\n      case choice\n      when :blueprints\n        parser = SlashCommandParser.new('/blueprint')\n        parser.execute\n      when :config\n        parser = SlashCommandParser.new('/config')\n        parser.execute\n      when :docs\n        parser = SlashCommandParser.new('/docs')\n        parser.execute\n      when :setup\n        parser = SlashCommandParser.new('/setup')\n        parser.execute\n      when :search\n        query = CLIUIIntegration.ask('Enter search query:')\n        parser = SlashCommandParser.new(\"/search #{query}\")\n        parser.execute\n      when :help\n        parser = SlashCommandParser.new('/help')\n        parser.execute\n      when :exit\n        handle_exit\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "category.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Generators\n    # Generates a list of relevant categories for a given code blueprint by using an LLM.\n    #\n    # This class is designed to analyze a piece of source code and an optional description,\n    # then produce a set of tags that help in organizing and discovering the code blueprint\n    # within a larger system. It uses a predefined list of categories to ensure consistency.\n    #\n    # @example Generating categories for a Ruby script\n    #   code_snippet = \"class MyScript\\n  def run\\n    puts 'Hello'\\n  end\\nend\"\n    #   description = \"A simple hello world script.\"\n    #   generator = BlueprintsCLI::Generators::Category.new(code: code_snippet, description: description)\n    #   categories = generator.generate\n    #   # => [\"ruby\", \"script\", \"utility\"]\n    class Category < Sublayer::Generators::Base\n      # Configures the LLM output to be a list of strings named \"categories\".\n      llm_output_adapter type: :list_of_strings,\n                         name: 'categories',\n                         description: 'Relevant categories and tags for this code blueprint'\n\n      # Initializes a new Category instance.\n      #\n      # @param code [String] The source code to be analyzed.\n      # @param description [String, nil] An optional high-level description of the code\n      #   to provide additional context to the LLM.\n      def initialize(code:, description: nil)\n        @code = code\n        @description = description\n      end\n\n      # Triggers the LLM to generate categories for the provided code.\n      #\n      # This method delegates to the parent class's generation logic, which uses the\n      # `#prompt` method to build a query for the LLM and parses the response\n      # into an array of strings as configured by the `llm_output_adapter`.\n      #\n      # @return [Array<String>] A list of 2-4 category tags for the code.\n      def generate\n        super\n      end\n\n      # Builds the prompt string for the LLM.\n      #\n      # This method constructs a detailed prompt that includes the code, its description,\n      # and a predefined list of categories to guide the LLM in its analysis. The goal\n      # is to get a consistent and relevant set of tags.\n      #\n      # @return [String] The complete prompt to be sent to the LLM.\n      def prompt\n        content_to_analyze = [@description, @code].compact.join(\"\\n\\n\")\n\n        <<-PROMPT\n          Analyze this code and generate relevant categories/tags for organization and discovery.\n\n          #{@description ? \"Description: #{@description}\" : ''}\n\n          Code:\n          ```\n          #{@code}\n          ```\n\n          Please categorize this code with 2-4 relevant tags from the following categories:\n\n          **Programming Languages & Frameworks:**\n          ruby, python, javascript, rails, react, vue, express, flask, django\n\n          **Application Types:**\n          web-app, api, cli-tool, library, script, microservice, database-migration\n\n          **Domain Areas:**\n          authentication, authorization, data-processing, file-handling, web-scraping,#{' '}\n          text-processing, image-processing, email, notifications, logging, monitoring\n\n          **Patterns & Concepts:**\n          mvc, rest-api, graphql, async, background-jobs, caching, testing, validation,\n          error-handling, configuration, security, performance-optimization\n\n          **Technical Areas:**\n          database, orm, sql, nosql, redis, elasticsearch, docker, kubernetes,#{' '}\n          json, xml, csv, pdf, encryption, oauth, jwt\n\n          **Utility Types:**\n          utility, helper, wrapper, adapter, parser, formatter, converter, generator\n\n          Return only the most relevant 2-4 categories that best describe this code.\n          Choose existing categories when possible rather than creating new ones.\n        PROMPT\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/generators/"
    },
    {
      "filename": "description.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Generators\n    #\n    # Uses a Large Language Model (LLM) to generate a clear, developer-focused\n    # description for a given snippet of source code.\n    #\n    # This generator analyzes the provided code, automatically detects its\n    # programming language if not specified, and produces a concise summary.\n    # It is designed to create documentation for \"code blueprints\" that can be\n    # reused by other developers.\n    #\n    # The output is configured via `llm_output_adapter` to be a single string\n    # containing the generated description.\n    #\n    # @example Generating a description for a Ruby method\n    #   ruby_code = \"def hello(name)\\n  \\\"Hello, \\#{name}!\\\"\\nend\"\n    #   generator = BlueprintsCLI::Generators::Description.new(code: ruby_code)\n    #   description = generator.generate\n    #   # => \"This Ruby method `hello` takes a name as input and returns a greeting string.\"\n    #\n    class Description < Sublayer::Generators::Base\n      llm_output_adapter type: :single_string,\n                         name: 'description',\n                         description: 'A clear, concise description of what this code blueprint accomplishes'\n\n      #\n      # Initializes a new blueprint description generator.\n      #\n      # It prepares the generator with the necessary code and determines the\n      # programming language, which is crucial for crafting an accurate LLM prompt.\n      #\n      # @param code [String] The source code to be analyzed and described.\n      # @param language [String, nil] The programming language of the code. If `nil`,\n      #   the language is automatically detected using `#detect_language`.\n      #\n      def initialize(code:, language: nil)\n        @code = code\n        @language = language || detect_language(code)\n      end\n\n      #\n      # Executes the LLM call to generate the code description.\n      #\n      # This method delegates to the `super` method from `Sublayer::Generators::Base`,\n      # which handles the core logic of sending the prompt (from the `#prompt` method)\n      # to the LLM and parsing the response.\n      #\n      # @return [String] A clear, concise description of the code's functionality.\n      #\n      def generate\n        super\n      end\n\n      #\n      # Constructs the prompt that instructs the LLM on how to generate the description.\n      #\n      # The prompt includes the source code, its detected language, and specific\n      # guidelines for creating a high-quality, developer-oriented summary.\n      #\n      # @return [String] The fully-formed prompt to be sent to the LLM.\n      #\n      def prompt\n        <<-PROMPT\n          Analyze this #{@language} code and generate a clear, concise description of what it does.\n\n          Code:\n          ```#{@language}\n          #{@code}\n          ```\n\n          Please provide a description that:\n          - Explains the primary functionality in 1-2 sentences\n          - Mentions key design patterns or techniques used\n          - Indicates the intended use case or context\n          - Is written for developers who might want to reuse this code\n\n          Focus on WHAT the code does and WHY someone would use it, not HOW it works in detail.\n        PROMPT\n      end\n\n      private\n\n      #\n      # Heuristically detects the programming language of a code snippet.\n      #\n      # It uses a case statement with regular expressions to match common syntax\n      # patterns for various languages. If no specific language is matched, it\n      # defaults to a generic 'code' identifier.\n      #\n      # @param code [String] The source code to analyze.\n      # @return [String] The lower-case name of the detected language (e.g., 'ruby', 'python')\n      #   or 'code' if the language could not be identified.\n      #\n      def detect_language(code)\n        case code\n        when /class\\s+\\w+.*<.*ApplicationRecord/m, /def\\s+\\w+.*end/m, /require ['\"].*['\"]/m\n          'ruby'\n        when /function\\s+\\w+\\s*\\(/m, /const\\s+\\w+\\s*=/m, /import\\s+.*from/m\n          'javascript'\n        when /def\\s+\\w+\\s*\\(/m, /import\\s+\\w+/m, /from\\s+\\w+\\s+import/m\n          'python'\n        when /#include\\s*<.*>/m, /int\\s+main\\s*\\(/m\n          'c'\n        when /public\\s+class\\s+\\w+/m, /import\\s+java\\./m\n          'java'\n        when /fn\\s+\\w+\\s*\\(/m, /use\\s+std::/m\n          'rust'\n        when /func\\s+\\w+\\s*\\(/m, /package\\s+main/m\n          'go'\n        else\n          'code'\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/generators/"
    },
    {
      "filename": "improvement.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\nrequire 'json'\nrequire_relative '../configuration'\nrequire_relative '../logger'\n\nmodule BlueprintsCLI\n  module Generators\n    # Response object for improvement suggestions that provides both Array interface\n    # for backward compatibility and metadata access for enhanced functionality.\n    #\n    # This object is returned by {Improvement#generate} and acts as a hybrid between\n    # a simple Array<String> (for backward compatibility) and a rich response object\n    # with metadata (for enhanced functionality).\n    #\n    # @example Array-like interface (backward compatibility)\n    #   response.each { |improvement| puts improvement }\n    #   first_improvement = response[0]\n    #   puts \"Found #{response.length} improvements\"\n    #\n    # @example Metadata interface (enhanced functionality)\n    #   puts \"Model: #{response.model_info[:model_id]}\"\n    #   puts \"Tokens: #{response.token_usage[:total_tokens]}\"\n    #   puts \"Success: #{response.success?}\"\n    class ImprovementResponse\n      include Enumerable\n\n      # @return [Array<String>] The list of improvement suggestions\n      attr_reader :improvements\n\n      # @return [Hash] Metadata about the response (tokens, model, timing, errors)\n      attr_reader :metadata\n\n      # @return [RubyLLM::Message, nil] The raw response from RubyLLM\n      attr_reader :raw_response\n\n      # Creates a new ImprovementResponse instance.\n      #\n      # @param improvements [Array<String>] List of improvement suggestions\n      # @param metadata [Hash] Response metadata (tokens, model, timing, etc.)\n      # @param raw_response [RubyLLM::Message, nil] Raw LLM response object\n      def initialize(improvements:, metadata:, raw_response:)\n        @improvements = Array(improvements)\n        @metadata = metadata || {}\n        @raw_response = raw_response\n      end\n\n      # Array-like interface for backward compatibility\n      def each(&block)\n        @improvements.each(&block)\n      end\n\n      def [](index)\n        @improvements[index]\n      end\n\n      def length\n        @improvements.length\n      end\n      alias size length\n\n      def empty?\n        @improvements.empty?\n      end\n\n      def to_a\n        @improvements.dup\n      end\n\n      def first\n        @improvements.first\n      end\n\n      def last\n        @improvements.last\n      end\n\n      def any?\n        !@improvements.empty?\n      end\n\n      # Returns token usage information.\n      #\n      # @return [Hash] Token usage with keys:\n      #   - :input_tokens [Integer] Tokens in the request\n      #   - :output_tokens [Integer] Tokens in the response\n      #   - :total_tokens [Integer] Sum of input and output tokens\n      def token_usage\n        {\n          input_tokens: @metadata[:input_tokens] || 0,\n          output_tokens: @metadata[:output_tokens] || 0,\n          total_tokens: (@metadata[:input_tokens] || 0) + (@metadata[:output_tokens] || 0)\n        }\n      end\n\n      # Returns model information.\n      #\n      # @return [Hash] Model info with keys:\n      #   - :model_id [String] The model identifier used\n      #   - :provider [String] The AI provider name\n      def model_info\n        {\n          model_id: @metadata[:model_id],\n          provider: @metadata[:provider]\n        }\n      end\n\n      # Returns the response time in seconds.\n      #\n      # @return [Float, nil] Time taken to generate the response\n      def response_time\n        @metadata[:response_time]\n      end\n\n      # Checks if the generation was successful.\n      #\n      # @return [Boolean] true if improvements were generated, false if error occurred\n      def success?\n        !@improvements.empty? && !@metadata[:error]\n      end\n\n      # JSON serialization including both improvements and metadata.\n      #\n      # @return [String] JSON representation\n      def to_json(*args)\n        {\n          improvements: @improvements,\n          metadata: @metadata,\n          success: success?\n        }.to_json(*args)\n      end\n\n      def inspect\n        \"#<ImprovementResponse improvements=#{@improvements.length} items, tokens=#{token_usage[:total_tokens]}>\"\n      end\n    end\n\n    # Analyzes a given code blueprint using RubyLLM to suggest specific, actionable\n    # improvements across various categories like quality, performance, and security.\n    #\n    # This generator replaces the previous Sublayer-based implementation with RubyLLM,\n    # providing the same interface while adding metadata access capabilities and\n    # improved reliability.\n    #\n    # @example Get improvement suggestions for a Ruby method\n    #   code_to_improve = <<-RUBY\n    #     def get_user_data(user_id)\n    #       data = User.find(user_id)\n    #       return data\n    #     end\n    #   RUBY\n    #\n    #   generator = BlueprintsCLI::Generators::Improvement.new(\n    #     code: code_to_improve,\n    #     description: \"A simple method to fetch a user record from the database.\"\n    #   )\n    #\n    #   result = generator.generate\n    #\n    #   # Backward compatible usage\n    #   result.each { |suggestion| puts suggestion }\n    #\n    #   # New metadata access\n    #   puts \"Used #{result.token_usage[:total_tokens]} tokens\"\n    #   puts \"Model: #{result.model_info[:model_id]}\"\n    class Improvement\n      # Error raised when LLM response cannot be parsed\n      ParseError = Class.new(StandardError)\n\n      # Error raised when LLM communication fails\n      CommunicationError = Class.new(StandardError)\n\n      # Initializes a new Improvement instance.\n      #\n      # @param code [String] The source code to be analyzed.\n      # @param description [String, nil] An optional high-level description of the code's\n      #   functionality to provide more context to the LLM.\n      def initialize(code:, description: nil)\n        @code = code\n        @description = description\n        @config = BlueprintsCLI::Configuration.new\n      end\n\n      # Executes the code analysis and returns the suggested improvements.\n      #\n      # This method creates a RubyLLM chat instance, sends the analysis prompt,\n      # and parses the response into a structured ImprovementResponse object.\n      #\n      # @return [ImprovementResponse] A response object that acts like Array<String>\n      #   for backward compatibility but also provides metadata access.\n      def generate\n        start_time = Time.now\n\n        begin\n          chat = create_chat_instance\n          response = chat.ask(build_prompt)\n          end_time = Time.now\n          response_time = end_time - start_time\n          improvements = parse_improvements(response.content)\n          metadata = build_metadata(response, response_time)\n\n          ImprovementResponse.new(\n            improvements: improvements,\n            metadata: metadata,\n            raw_response: response\n          )\n        rescue ParseError, RubyLLM::Error => e\n          handle_error(e, start_time)\n        rescue StandardError => e\n          BlueprintsCLI.logger.failure(\"An unexpected error occurred during improvement generation: #{e.message}\")\n          handle_error(e, start_time)\n        end\n      end\n\n      private\n\n      # Creates a RubyLLM chat instance with appropriate configuration\n      #\n      # @return [RubyLLM::Chat] Configured chat instance\n      def create_chat_instance\n        # Get model from configuration, fallback to default\n        model = @config.fetch(:ai, :rubyllm, :default_model) || 'gemini-2.0-flash'\n\n        # Create chat with system instructions for structured output\n        chat = RubyLLM.chat(model: model)\n        chat.with_instructions(system_instructions)\n\n        chat\n      end\n\n      # System instructions for the LLM to ensure structured output\n      #\n      # @return [String] System instructions\n      def system_instructions\n        <<~INSTRUCTIONS\n          You are a senior software engineer and code reviewer. Your task is to analyze code and provide specific, actionable improvement suggestions.\n\n          Always respond with valid JSON in the exact format requested. Each improvement should be:\n          - Specific and actionable\n          - Focused on a single improvement area\n          - Written as a complete sentence\n          - Practical and implementable\n\n          Do not include explanations outside the JSON response.\n        INSTRUCTIONS\n      end\n\n      # Builds the analysis prompt for the LLM\n      #\n      # @return [String] The complete prompt to be sent for analysis\n      def build_prompt\n        <<~PROMPT\n          Analyze this code blueprint and suggest specific, actionable improvements.\n\n          #{@description ? \"Description: #{@description}\" : ''}\n\n          Code:\n          ```\n          #{@code}\n          ```\n\n          Please provide 3-6 specific improvement suggestions focusing on:\n\n          **Code Quality:**\n          - Readability and clarity improvements\n          - Better variable/method naming\n          - Code organization and structure\n          - DRY principle violations\n\n          **Performance:**\n          - Algorithm efficiency improvements\n          - Memory usage optimizations\n          - Database query optimizations (if applicable)\n          - Caching opportunities\n\n          **Security:**\n          - Input validation and sanitization\n          - Authentication and authorization concerns\n          - Data exposure risks\n          - Secure coding practices\n\n          **Best Practices:**\n          - Framework-specific conventions\n          - Error handling improvements\n          - Logging and debugging enhancements\n          - Testing considerations\n\n          **Maintainability:**\n          - Documentation needs\n          - Configuration externalization\n          - Dependency management\n          - Code modularity\n\n          Format each suggestion as a single, actionable sentence that clearly explains:\n          1. WHAT to improve\n          2. WHY it's important\n          3. HOW to implement it (briefly)\n\n          Focus on the most impactful improvements first. Avoid generic advice.\n\n          Please respond with a JSON object in this exact format:\n          {\n            \"improvements\": [\n              \"First improvement suggestion here\",\n              \"Second improvement suggestion here\",\n              \"Third improvement suggestion here\"\n            ]\n          }\n        PROMPT\n      end\n\n      # Parses improvement suggestions from LLM response content\n      #\n      # @param content [String] The raw response content from the LLM\n      # @return [Array<String>] Array of improvement suggestions\n      # @raise [ParseError] If the response cannot be parsed\n      def parse_improvements(content)\n        # Try to extract JSON from the response\n        json_match = content.match(/\\{.*\\}/m)\n        raise ParseError, 'No JSON found in response' unless json_match\n\n        json_content = json_match[0]\n        parsed = JSON.parse(json_content)\n\n        improvements = parsed['improvements']\n        raise ParseError, \"No 'improvements' key found in response\" unless improvements\n        raise ParseError, 'Improvements is not an array' unless improvements.is_a?(Array)\n        raise ParseError, 'No improvements found' if improvements.empty?\n\n        # Clean up and validate improvements\n        improvements.map(&:strip).reject(&:empty?)\n      rescue JSON::ParserError => e\n        raise ParseError, \"Invalid JSON in response: #{e.message}\"\n      end\n\n      # Builds metadata hash from response and timing information\n      #\n      # @param response [RubyLLM::Message] The LLM response object\n      # @param response_time [Float] Time taken for the request\n      # @return [Hash] Metadata hash\n      def build_metadata(response, response_time)\n        {\n          model_id: response.model_id,\n          provider: extract_provider_from_model(response.model_id),\n          input_tokens: response.input_tokens,\n          output_tokens: response.output_tokens,\n          total_tokens: (response.input_tokens || 0) + (response.output_tokens || 0),\n          response_time: response_time,\n          timestamp: Time.now.iso8601\n        }\n      end\n\n      # Extracts provider name from model ID\n      #\n      # @param model_id [String] The model identifier\n      # @return [String] Provider name\n      def extract_provider_from_model(model_id)\n        case model_id\n        when /gemini/i\n          'Google'\n        when /gpt|openai/i\n          'OpenAI'\n        when /claude/i\n          'Anthropic'\n        when /deepseek/i\n          'DeepSeek'\n        else\n          'Unknown'\n        end\n      end\n\n      # Handles errors during generation process\n      #\n      # @param error [StandardError] The error that occurred\n      # @param start_time [Time] When the generation started\n      # @return [ImprovementResponse] Error response object\n      def handle_error(error, start_time)\n        end_time = Time.now\n        response_time = end_time - start_time\n\n        # Log the error\n        if error.is_a?(RubyLLM::Error)\n          BlueprintsCLI::Logger.ai_error(error)\n        else\n          BlueprintsCLI.logger.warn(\"Improvement generation failed: #{error.message}\")\n        end\n        BlueprintsCLI.logger.debug(error.backtrace.join(\"\\n\")) if ENV['DEBUG']\n\n        # Return empty response with error metadata\n        ImprovementResponse.new(\n          improvements: [],\n          metadata: {\n            error: error.message,\n            error_type: error.class.name,\n            response_time: response_time,\n            timestamp: Time.now.iso8601\n          },\n          raw_response: nil\n        )\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/generators/"
    },
    {
      "filename": "name.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Generators\n    #\n    # Generates a descriptive, title-cased name for a given code snippet,\n    # referred to as a \"code blueprint\".\n    #\n    # This class constructs a detailed prompt for an LLM, providing the code,\n    # an optional description, and specific rules to guide the model in creating\n    # a suitable name. It is designed to produce names that are 3-6 words long,\n    # clearly indicate functionality, and are specific enough to be useful in a\n    # catalog of blueprints.\n    #\n    class Name < Sublayer::Generators::Base\n      llm_output_adapter type: :single_string,\n                         name: 'name',\n                         description: 'A descriptive name for this code blueprint'\n\n      #\n      # Initializes a new instance of the Name.\n      #\n      # @param code [String] The source code of the blueprint for which to generate a name.\n      # @param description [String, nil] An optional existing description of the code to\n      #   provide additional context for the name generation process.\n      #\n      def initialize(code:, description: nil)\n        @code = code\n        @description = description\n      end\n\n      #\n      # Executes the name generation process.\n      #\n      # This method delegates to the parent class's `generate` method, which is\n      # responsible for orchestrating the call to the LLM with the prompt from\n      # the `#prompt` method and returning the resulting name.\n      #\n      # @return [String] The generated name for the code blueprint.\n      #\n      def generate\n        super\n      end\n\n      #\n      # Constructs the prompt sent to the LLM for name generation.\n      #\n      # The prompt includes the code, an optional description, and a set of rules\n      # and examples to guide the LLM in creating a high-quality, formatted name.\n      # It specifically requests a title-cased name that is 3-6 words long and\n      # avoids generic terms.\n      #\n      # @return [String] The complete, formatted prompt text.\n      #\n      def prompt\n        <<-PROMPT\n          Generate a clear, descriptive name for this code blueprint.\n\n          #{@description ? \"Description: #{@description}\" : ''}\n\n          Code:\n          ```\n          #{@code}\n          ```\n\n          The name should:\n          - Be 3-6 words long\n          - Clearly indicate what the code does\n          - Use title case (e.g., \"User Authentication Helper\", \"CSV Data Processor\")\n          - Be specific enough to distinguish it from similar code\n          - Avoid generic terms like \"Script\" or \"Code\" unless necessary\n\n          Examples of good names:\n          - \"REST API Response Formatter\"\n          - \"Database Migration Helper\"\n          - \"Email Template Generator\"\n          - \"JWT Token Validator\"\n          - \"File Upload Handler\"\n\n          Return only the name, no additional text or explanation.\n        PROMPT\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/generators/"
    },
    {
      "filename": "logger.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\nrequire_relative 'enhanced_logger'\n\nmodule BlueprintsCLI\n  # Centralized logger module for the BlueprintsCLI application.\n  # Encapsulates TTY::Logger configuration and provides a singleton instance.\n  module Logger\n    # Class variable to hold the singleton logger instance.\n    @@instance = nil\n\n    # Retrieves the singleton logger instance.\n    # On first call, it initializes and configures the logger.\n    #\n    # @return [TTY::Logger] The configured logger instance.\n    def self.instance\n      return @@instance if @@instance\n\n      # Load user configuration for the logger\n      app_config = BlueprintsCLI::Configuration.new\n      log_level = app_config.fetch(:logger, :level)&.to_sym || :info\n      console_logging_enabled = app_config.fetch(:logger, :console_logging, default: true)\n      file_logging_enabled = app_config.fetch(:logger, :file_logging) || false\n      log_file_path = app_config.fetch(:logger, :file_path) || default_log_path\n      file_log_level = app_config.fetch(:logger, :file_level)&.to_sym || :debug\n\n      base_logger = TTY::Logger.new do |config|\n        # Configure handlers (console and optional file)\n        handlers = []\n        handlers << configure_console_handler(log_level) if console_logging_enabled\n        handlers << configure_file_handler(log_file_path, file_log_level) if file_logging_enabled\n\n        config.handlers = handlers\n      end\n\n      # Add custom log types after initialization with styling\n      # Use try-catch to handle any conflicts with built-in types\n      begin\n        base_logger.add_type(:success, { level: :info, symbol: '✅', color: :green })\n      rescue TTY::Logger::Error\n        # Type already exists, skip\n      end\n\n      begin\n        base_logger.add_type(:failure, { level: :error, symbol: '❌', color: :red })\n      rescue TTY::Logger::Error\n        # Type already exists, skip\n      end\n\n      begin\n        base_logger.add_type(:tip, { level: :info, symbol: '💡', color: :cyan })\n      rescue TTY::Logger::Error\n        # Type already exists, skip\n      end\n\n      begin\n        base_logger.add_type(:step, { level: :info, symbol: '🚀', color: :blue })\n      rescue TTY::Logger::Error\n        # Type already exists, skip\n      end\n\n      # Check context logging configuration options\n      context_enabled = app_config.fetch(:logger, :context_enabled, default: true)\n      context_detail_level = app_config.fetch(:logger, :context_detail_level,\n                                              default: 'full')&.to_sym || :full\n      context_cache_size = app_config.fetch(:logger, :context_cache_size, default: 1000) || 1000\n\n      # Wrap the base logger with enhanced context-aware functionality\n      @@instance = EnhancedLogger.new(\n        base_logger,\n        context_enabled: context_enabled,\n        context_detail_level: context_detail_level,\n        context_cache_size: context_cache_size\n      )\n\n      @@instance\n    end\n\n    # Logs a structured, user-friendly error for AI-related exceptions.\n    #\n    # @param error [StandardError] The exception to log.\n    def self.ai_error(error)\n      instance.failure(\"AI Error: #{error.message}\")\n      case error\n      when RubyLLM::AuthenticationError\n        instance.tip(\"Check your API key and provider settings in `config.yml`.\")\n      when RubyLLM::ConfigurationError\n        instance.tip(\"Review your AI configuration in `config.yml` for missing or invalid values.\")\n      when RubyLLM::RateLimitError\n        instance.tip(\"You have exceeded your API quota. Please check your plan and usage limits.\")\n      when RubyLLM::APIConnectionError\n        instance.tip(\"Could not connect to the AI provider. Check your network connection.\")\n      when RubyLLM::InvalidRequestError\n        instance.warn(\"The request to the AI provider was invalid. This may be a bug.\")\n        instance.debug(error.backtrace.join(\"\\n\")) if ENV['DEBUG']\n      else\n        instance.warn(\"An unexpected error occurred while communicating with the AI provider.\")\n        instance.debug(error.backtrace.join(\"\\n\")) if ENV['DEBUG']\n      end\n    end\n\n    # Reset the singleton instance (useful for testing)\n    def self.reset!\n      @@instance = nil\n    end\n\n    private\n\n    # Configures the console handler with custom styles.\n    #\n    # @param level [Symbol] The minimum log level for the console.\n    # @return [Array] The handler configuration array for TTY::Logger.\n    def self.configure_console_handler(level)\n      [\n        :console,\n        {\n          level: level,\n          output: $stderr, # Log to stderr to separate from program output\n          styles: {\n            info: { symbol: 'ℹ️', color: :blue },\n            debug: { symbol: '🐞', color: :magenta },\n            error: { symbol: '❌', color: :red },\n            warn: { symbol: '⚠️', color: :yellow },\n            fatal: { symbol: '💀', color: :red, bold: true }\n          }\n        }\n      ]\n    end\n\n    # Configures the file stream handler.\n    #\n    # @param path [String] The path to the log file.\n    # @param level [Symbol] The minimum log level for the file.\n    # @return [Array] The handler configuration array for TTY::Logger.\n    def self.configure_file_handler(path, level)\n      # Ensure the directory for the log file exists\n      FileUtils.mkdir_p(File.dirname(path))\n\n      [\n        :stream,\n        {\n          level: level,\n          output: File.open(path, 'a'),\n          formatter: :json # Use JSON format for structured logging\n        }\n      ]\n    end\n\n    # Determines the default path for the log file.\n    #\n    # @return [String] The absolute path for the log file.\n    def self.default_log_path\n      # Use XDG Base Directory Specification if available, otherwise fallback\n      state_home = ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')\n      File.join(state_home, 'BlueprintsCLI', 'app.log')\n    end\n  end\nend",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "cache_models.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ohm'\nrequire 'json'\n\nmodule BlueprintsCLI\n  module Models\n    # Redis Ohm models for intelligent caching of NLP processing results\n    # Leverages algorithms gem data structures for optimized storage and retrieval\n\n    # Base cache model with common functionality\n    class CacheEntry < Ohm::Model\n      attribute :key\n      attribute :data\n      attribute :metadata\n      attribute :created_at\n      attribute :last_accessed\n      attribute :access_count\n      attribute :ttl\n\n      index :key\n      index :created_at\n      index :last_accessed\n\n      def initialize(attributes = {})\n        super\n        self.created_at = Time.now.to_f.to_s unless created_at\n        self.last_accessed = Time.now.to_f.to_s\n        self.access_count = '0' unless access_count\n      end\n\n      # Deserialize stored data\n      def get_data\n        return nil unless data\n\n        JSON.parse(data)\n      rescue JSON::ParserError\n        data\n      end\n\n      # Serialize and store data\n      def set_data(value)\n        self.data = value.is_a?(String) ? value : JSON.generate(value)\n      end\n\n      # Get metadata as hash\n      def get_metadata\n        return {} unless metadata\n\n        JSON.parse(metadata)\n      rescue JSON::ParserError\n        {}\n      end\n\n      # Set metadata as hash\n      def set_metadata(value)\n        self.metadata = value.is_a?(String) ? value : JSON.generate(value)\n      end\n\n      # Track access for LRU eviction\n      def mark_accessed!\n        self.last_accessed = Time.now.to_f.to_s\n        self.access_count = (access_count.to_i + 1).to_s\n        save_changes\n      end\n\n      # Check if entry has expired\n      def expired?\n        return false unless ttl\n\n        Time.now.to_f - created_at.to_f > ttl.to_f\n      end\n\n      # Get age in seconds\n      def age\n        Time.now.to_f - created_at.to_f\n      end\n    end\n\n    # Specialized cache for SpaCy processing results\n    class SpacyCache < CacheEntry\n      attribute :model_name\n      attribute :text_hash\n      attribute :token_count\n      attribute :entity_count\n      attribute :processing_time\n\n      index :model_name\n      index :text_hash\n      index :token_count\n      index :entity_count\n\n      # Create cache entry for SpaCy results\n      def self.store_result(text, model_name, result, processing_time = 0)\n        text_hash = Digest::MD5.hexdigest(text)\n\n        cache_entry = create(\n          key: \"spacy_#{model_name}_#{text_hash}\",\n          text_hash: text_hash,\n          model_name: model_name,\n          token_count: result[:tokens]&.length&.to_s || '0',\n          entity_count: result[:entities]&.length&.to_s || '0',\n          processing_time: processing_time.to_s,\n          ttl: '86400' # 24 hours\n        )\n\n        cache_entry.set_data(result)\n        cache_entry.set_metadata({\n                                   text_length: text.length,\n                                   complexity_score: calculate_complexity(result),\n                                   cached_at: Time.now.iso8601\n                                 })\n\n        cache_entry.save_changes\n        cache_entry\n      end\n\n      # Retrieve cached SpaCy result\n      def self.get_result(text, model_name)\n        text_hash = Digest::MD5.hexdigest(text)\n        key = \"spacy_#{model_name}_#{text_hash}\"\n\n        entry = find(key: key).first\n        return nil unless entry && !entry.expired?\n\n        entry.mark_accessed!\n        entry.get_data\n      end\n\n      # Clean up expired entries\n      def self.cleanup_expired\n        all.each do |entry|\n          entry.delete if entry.expired?\n        end\n      end\n\n      # Get statistics for SpaCy cache\n      def self.statistics\n        entries = all.to_a\n        {\n          total_entries: entries.length,\n          avg_processing_time: entries.sum { |e| e.processing_time.to_f } / entries.length,\n          avg_token_count: entries.sum { |e| e.token_count.to_i } / entries.length,\n          avg_entity_count: entries.sum { |e| e.entity_count.to_i } / entries.length,\n          models_used: entries.map(&:model_name).uniq,\n          hit_rate: calculate_hit_rate(entries)\n        }\n      end\n\n      def self.calculate_complexity(result)\n        complexity = 0.0\n        complexity += (result[:entities]&.length || 0) * 0.1\n        complexity += (result[:dependencies]&.length || 0) * 0.05\n        complexity += (result[:noun_phrases]&.length || 0) * 0.08\n        complexity.round(3)\n      end\n\n      def self.calculate_hit_rate(entries)\n        return 0.0 if entries.empty?\n\n        total_accesses = entries.sum { |e| e.access_count.to_i }\n        return 0.0 if total_accesses.zero?\n\n        (entries.length.to_f / total_accesses * 100).round(2)\n      end\n    end\n\n    # Specialized cache for Linguistics processing results\n    class LinguisticsCache < CacheEntry\n      attribute :text_hash\n      attribute :word_count\n      attribute :morphology_count\n      attribute :concept_count\n      attribute :semantic_density\n\n      index :text_hash\n      index :word_count\n      index :concept_count\n      index :semantic_density\n\n      # Store linguistics processing result\n      def self.store_result(text, result, processing_time = 0)\n        text_hash = Digest::MD5.hexdigest(text)\n\n        cache_entry = create(\n          key: \"linguistics_#{text_hash}\",\n          text_hash: text_hash,\n          word_count: (result[:morphology]&.length || 0).to_s,\n          morphology_count: (result[:morphology]&.length || 0).to_s,\n          concept_count: (result[:concepts]&.length || 0).to_s,\n          semantic_density: (result.dig(:complexity_metrics, :semantic_density) || 0.0).to_s,\n          processing_time: processing_time.to_s,\n          ttl: '86400'\n        )\n\n        cache_entry.set_data(result)\n        cache_entry.set_metadata({\n                                   text_length: text.length,\n                                   vocabulary_richness: result.dig(:complexity_metrics,\n                                                                   :vocabulary_richness),\n                                   lexical_diversity: result.dig(:complexity_metrics,\n                                                                 :lexical_diversity),\n                                   cached_at: Time.now.iso8601\n                                 })\n\n        cache_entry.save_changes\n        cache_entry\n      end\n\n      # Retrieve cached linguistics result\n      def self.get_result(text)\n        text_hash = Digest::MD5.hexdigest(text)\n        key = \"linguistics_#{text_hash}\"\n\n        entry = find(key: key).first\n        return nil unless entry && !entry.expired?\n\n        entry.mark_accessed!\n        entry.get_data\n      end\n\n      # Find entries by semantic density range\n      def self.by_semantic_density(min_density, max_density)\n        all.select do |entry|\n          density = entry.semantic_density.to_f\n          density.between?(min_density, max_density)\n        end\n      end\n\n      # Get top concepts across all cached entries\n      def self.top_concepts(limit = 10)\n        concept_frequency = Hash.new(0)\n\n        all.each do |entry|\n          next if entry.expired?\n\n          result = entry.get_data\n          next unless result[:concepts]\n\n          result[:concepts].each do |concept|\n            concept_frequency[concept[:word]] += 1\n          end\n        end\n\n        concept_frequency.sort_by { |_word, freq| -freq }.first(limit)\n      end\n    end\n\n    # Cache for embedding vectors with KD-tree optimization\n    class EmbeddingCache < CacheEntry\n      attribute :text_hash\n      attribute :provider\n      attribute :model_name\n      attribute :vector_dimensions\n      attribute :similarity_hash\n\n      index :text_hash\n      index :provider\n      index :model_name\n      index :vector_dimensions\n\n      # Store embedding vector\n      def self.store_embedding(text, provider, model_name, vector, processing_time = 0)\n        text_hash = Digest::MD5.hexdigest(text)\n        vector_data = vector.is_a?(Array) ? vector : [vector].flatten\n\n        cache_entry = create(\n          key: \"embedding_#{provider}_#{model_name}_#{text_hash}\",\n          text_hash: text_hash,\n          provider: provider,\n          model_name: model_name,\n          vector_dimensions: vector_data.length.to_s,\n          similarity_hash: calculate_similarity_hash(vector_data),\n          processing_time: processing_time.to_s,\n          ttl: '604800' # 7 days\n        )\n\n        cache_entry.set_data(vector_data)\n        cache_entry.set_metadata({\n                                   text_length: text.length,\n                                   vector_norm: calculate_vector_norm(vector_data),\n                                   cached_at: Time.now.iso8601\n                                 })\n\n        cache_entry.save_changes\n        cache_entry\n      end\n\n      # Retrieve cached embedding\n      def self.get_embedding(text, provider, model_name)\n        text_hash = Digest::MD5.hexdigest(text)\n        key = \"embedding_#{provider}_#{model_name}_#{text_hash}\"\n\n        entry = find(key: key).first\n        return nil unless entry && !entry.expired?\n\n        entry.mark_accessed!\n        entry.get_data\n      end\n\n      # Find similar embeddings using similarity hash\n      def self.find_similar(target_vector, provider, model_name, threshold = 0.8)\n        target_hash = calculate_similarity_hash(target_vector)\n\n        candidates = find(provider: provider, model_name: model_name).select do |entry|\n          next false if entry.expired?\n\n          # Quick filter by similarity hash\n          hash_similarity = jaccard_similarity(target_hash, entry.similarity_hash)\n          hash_similarity >= threshold * 0.5 # Loose threshold for candidates\n        end\n\n        # Calculate actual cosine similarity for candidates\n        similar_entries = []\n        candidates.each do |entry|\n          cached_vector = entry.get_data\n          next unless cached_vector.is_a?(Array)\n\n          similarity = cosine_similarity(target_vector, cached_vector)\n          next unless similarity >= threshold\n\n          similar_entries << {\n            entry: entry,\n            vector: cached_vector,\n            similarity: similarity\n          }\n        end\n\n        similar_entries.sort_by { |item| -item[:similarity] }\n      end\n\n      # Build KD-tree index for fast nearest neighbor search\n      def self.build_kd_tree_index(provider, model_name)\n        require 'algorithms'\n\n        entries = find(provider: provider, model_name: model_name).reject(&:expired?)\n        return nil if entries.empty?\n\n        # Prepare points for KD-tree (using first 2 dimensions)\n        points = {}\n        entries.each do |entry|\n          vector = entry.get_data\n          next unless vector.is_a?(Array) && vector.length >= 2\n\n          points[entry.id] = [vector[0], vector[1]]\n        end\n\n        return nil if points.empty?\n\n        Containers::KDTree.new(points)\n      end\n\n      # Calculate a hash for quick similarity filtering\n      def self.calculate_similarity_hash(vector)\n        return '' unless vector.is_a?(Array)\n\n        # Create hash based on vector quantization\n        quantized = vector.map { |v| (v * 10).round }\n        Digest::MD5.hexdigest(quantized.join(','))[0..7]\n      end\n\n      # Calculate vector norm\n      def self.calculate_vector_norm(vector)\n        return 0.0 unless vector.is_a?(Array)\n\n        Math.sqrt(vector.sum { |v| v * v })\n      end\n\n      # Jaccard similarity for similarity hashes\n      def self.jaccard_similarity(hash1, hash2)\n        return 0.0 if hash1.empty? || hash2.empty?\n\n        chars1 = hash1.chars.to_set\n        chars2 = hash2.chars.to_set\n\n        intersection = (chars1 & chars2).size\n        union = (chars1 | chars2).size\n\n        return 0.0 if union.zero?\n\n        intersection.to_f / union\n      end\n\n      # Cosine similarity between vectors\n      def self.cosine_similarity(vector1, vector2)\n        return 0.0 unless vector1.is_a?(Array) && vector2.is_a?(Array)\n        return 0.0 if vector1.length != vector2.length\n\n        dot_product = vector1.zip(vector2).sum { |a, b| a * b }\n        norm1 = Math.sqrt(vector1.sum { |v| v * v })\n        norm2 = Math.sqrt(vector2.sum { |v| v * v })\n\n        return 0.0 if norm1.zero? || norm2.zero?\n\n        dot_product / (norm1 * norm2)\n      end\n    end\n\n    # Cache for complete pipeline results\n    class PipelineCache < CacheEntry\n      attribute :text_hash\n      attribute :pipeline_config\n      attribute :processors_used\n      attribute :analysis_score\n      attribute :feature_count\n\n      index :text_hash\n      index :pipeline_config\n      index :analysis_score\n      index :feature_count\n\n      # Store complete pipeline result\n      def self.store_result(text, config, result, processing_time = 0)\n        text_hash = Digest::MD5.hexdigest(text)\n        config_hash = Digest::MD5.hexdigest(config.to_json)\n\n        cache_entry = create(\n          key: \"pipeline_#{config_hash}_#{text_hash}\",\n          text_hash: text_hash,\n          pipeline_config: config_hash,\n          processors_used: result[:processors_used]&.join(',') || '',\n          analysis_score: (result.dig(:analysis_scores, :quality) || 0.0).to_s,\n          feature_count: count_features(result).to_s,\n          processing_time: processing_time.to_s,\n          ttl: '43200' # 12 hours\n        )\n\n        cache_entry.set_data(result)\n        cache_entry.set_metadata({\n                                   text_length: text.length,\n                                   completeness: result.dig(:analysis_scores, :completeness),\n                                   information_density: result.dig(:analysis_scores,\n                                                                   :information_density),\n                                   cached_at: Time.now.iso8601\n                                 })\n\n        cache_entry.save_changes\n        cache_entry\n      end\n\n      # Retrieve cached pipeline result\n      def self.get_result(text, config)\n        text_hash = Digest::MD5.hexdigest(text)\n        config_hash = Digest::MD5.hexdigest(config.to_json)\n        key = \"pipeline_#{config_hash}_#{text_hash}\"\n\n        entry = find(key: key).first\n        return nil unless entry && !entry.expired?\n\n        entry.mark_accessed!\n        entry.get_data\n      end\n\n      # Get pipeline performance statistics\n      def self.performance_stats\n        entries = all.reject(&:expired?)\n        return {} if entries.empty?\n\n        {\n          total_cached: entries.length,\n          avg_processing_time: entries.sum { |e| e.processing_time.to_f } / entries.length,\n          avg_analysis_score: entries.sum { |e| e.analysis_score.to_f } / entries.length,\n          avg_feature_count: entries.sum { |e| e.feature_count.to_i } / entries.length,\n          processor_usage: calculate_processor_usage(entries),\n          cache_efficiency: calculate_cache_efficiency(entries)\n        }\n      end\n\n      def self.count_features(result)\n        count = 0\n        count += result.dig(:combined_analysis, :keywords)&.length || 0\n        count += result.dig(:combined_analysis, :entities)&.length || 0\n        count += result.dig(:combined_analysis, :concepts)&.length || 0\n        count\n      end\n\n      def self.calculate_processor_usage(entries)\n        usage = Hash.new(0)\n        entries.each do |entry|\n          processors = entry.processors_used.split(',')\n          processors.each { |processor| usage[processor] += 1 }\n        end\n        usage\n      end\n\n      def self.calculate_cache_efficiency(entries)\n        return 0.0 if entries.empty?\n\n        total_accesses = entries.sum { |e| e.access_count.to_i }\n        return 0.0 if total_accesses.zero?\n\n        cache_hits = entries.count { |e| e.access_count.to_i > 1 }\n        (cache_hits.to_f / entries.length * 100).round(2)\n      end\n    end\n\n    # Cache manager for coordinating all cache operations\n    class CacheManager\n      include Containers\n\n      def initialize\n        @cache_stats = RBTreeMap.new\n        @cleanup_interval = 3600 # 1 hour\n        @last_cleanup = Time.now\n      end\n\n      # Unified cache storage\n      def store(cache_type, *args)\n        case cache_type\n        when :spacy\n          SpacyCache.store_result(*args)\n        when :linguistics\n          LinguisticsCache.store_result(*args)\n        when :embedding\n          EmbeddingCache.store_embedding(*args)\n        when :pipeline\n          PipelineCache.store_result(*args)\n        else\n          raise ArgumentError, \"Unknown cache type: #{cache_type}\"\n        end\n\n        update_stats(cache_type, :store)\n        cleanup_if_needed\n      end\n\n      # Unified cache retrieval\n      def get(cache_type, *args)\n        result = case cache_type\n                 when :spacy\n                   SpacyCache.get_result(*args)\n                 when :linguistics\n                   LinguisticsCache.get_result(*args)\n                 when :embedding\n                   EmbeddingCache.get_embedding(*args)\n                 when :pipeline\n                   PipelineCache.get_result(*args)\n                 end\n\n        update_stats(cache_type, result ? :hit : :miss)\n        result\n      end\n\n      # Get comprehensive cache statistics\n      def statistics\n        {\n          spacy: SpacyCache.statistics,\n          linguistics: {\n            total_entries: LinguisticsCache.all.length,\n            top_concepts: LinguisticsCache.top_concepts(5)\n          },\n          embedding: {\n            total_entries: EmbeddingCache.all.length,\n            providers: EmbeddingCache.all.map(&:provider).uniq\n          },\n          pipeline: PipelineCache.performance_stats,\n          cache_operations: @cache_stats.to_h,\n          memory_usage: calculate_memory_usage\n        }\n      end\n\n      # Cleanup expired entries across all caches\n      def cleanup_expired!\n        SpacyCache.cleanup_expired\n        LinguisticsCache.all.each { |e| e.delete if e.expired? }\n        EmbeddingCache.all.each { |e| e.delete if e.expired? }\n        PipelineCache.all.each { |e| e.delete if e.expired? }\n\n        @last_cleanup = Time.now\n      end\n\n      # Clear all caches\n      def clear_all!\n        [SpacyCache, LinguisticsCache, EmbeddingCache, PipelineCache].each do |klass|\n          klass.all.each(&:delete)\n        end\n        @cache_stats.clear\n      end\n\n      private\n\n      def update_stats(cache_type, operation)\n        key = \"#{cache_type}_#{operation}\"\n        @cache_stats[key] = (@cache_stats[key] || 0) + 1\n      end\n\n      def cleanup_if_needed\n        return unless Time.now - @last_cleanup > @cleanup_interval\n\n        Thread.new { cleanup_expired! }\n      end\n\n      def calculate_memory_usage\n        total_entries = 0\n        total_entries += SpacyCache.all.length\n        total_entries += LinguisticsCache.all.length\n        total_entries += EmbeddingCache.all.length\n        total_entries += PipelineCache.all.length\n\n        # Rough estimate: 1KB per entry\n        \"#{total_entries}KB (estimated)\"\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/models/"
    },
    {
      "filename": "enhanced_rag_service.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'pipeline_builder'\nrequire_relative '../models/cache_models'\nrequire_relative '../providers/embedding_provider'\nrequire_relative '../services/informers_embedding_service'\nrequire 'algorithms'\n\nmodule BlueprintsCLI\n  module NLP\n    # Enhanced RAG service that integrates the full NLP pipeline with caching\n    # and algorithmic optimizations for blueprint processing\n    class EnhancedRagService\n      include Containers\n\n      attr_reader :pipeline, :cache_manager, :search_index, :performance_metrics\n\n      def initialize(config = {})\n        @config = default_config.merge(config)\n        @cache_manager = Models::CacheManager.new\n        @performance_metrics = RBTreeMap.new\n        @search_index = build_search_infrastructure\n\n        initialize_pipeline\n        setup_embedding_service\n      end\n\n      # Process blueprint with enhanced NLP analysis\n      def process_blueprint(blueprint_data)\n        start_time = Time.now\n\n        begin\n          text_content = extract_text_content(blueprint_data)\n          blueprint_id = blueprint_data[:id] || generate_blueprint_id(text_content)\n\n          # Check cache first\n          if (cached_result = @cache_manager.get(:pipeline, text_content, @config))\n            update_metrics(:cache_hit, Time.now - start_time)\n            return enrich_cached_result(cached_result, blueprint_id)\n          end\n\n          # Process through NLP pipeline\n          nlp_result = @pipeline.process(text_content)\n\n          # Generate embeddings\n          embeddings = generate_embeddings(text_content, nlp_result)\n\n          # Extract code-specific features\n          code_features = extract_code_features(text_content, blueprint_data)\n\n          # Build comprehensive analysis\n          enhanced_result = build_enhanced_analysis(\n            blueprint_data, nlp_result, embeddings, code_features\n          )\n\n          # Update search index\n          update_search_index(blueprint_id, enhanced_result)\n\n          # Cache the result\n          processing_time = Time.now - start_time\n          @cache_manager.store(:pipeline, text_content, @config, enhanced_result, processing_time)\n\n          update_metrics(:processing_success, processing_time)\n          enhanced_result\n        rescue StandardError => e\n          processing_time = Time.now - start_time\n          update_metrics(:processing_error, processing_time, error: e.message)\n\n          # Return fallback analysis\n          build_fallback_analysis(blueprint_data, e.message)\n        end\n      end\n\n      # Enhanced search with hybrid approach\n      def search_blueprints(query, options = {})\n        start_time = Time.now\n        search_options = default_search_options.merge(options)\n\n        begin\n          # Process query through NLP pipeline\n          query_analysis = @pipeline.process(query)\n          query_embeddings = generate_embeddings(query, query_analysis)\n\n          # Perform hybrid search\n          search_results = @pipeline.hybrid_search(\n            query,\n            @search_index,\n            search_options.merge(query_vector: query_embeddings)\n          )\n\n          # Rank and filter results\n          ranked_results = rank_search_results(query_analysis, search_results, search_options)\n\n          # Apply relevance filtering\n          filtered_results = apply_relevance_filters(ranked_results, search_options)\n\n          update_metrics(:search_success, Time.now - start_time)\n\n          {\n            query: query,\n            query_analysis: query_analysis,\n            results: filtered_results,\n            search_stats: {\n              total_found: search_results.length,\n              after_ranking: ranked_results.length,\n              final_count: filtered_results.length,\n              processing_time: Time.now - start_time\n            }\n          }\n        rescue StandardError => e\n          update_metrics(:search_error, Time.now - start_time, error: e.message)\n\n          {\n            query: query,\n            results: [],\n            error: e.message,\n            search_stats: { processing_time: Time.now - start_time }\n          }\n        end\n      end\n\n      # Get similar blueprints using vector similarity\n      def find_similar_blueprints(blueprint_id, options = {})\n        start_time = Time.now\n        similarity_options = { k: 10, threshold: 0.7 }.merge(options)\n\n        begin\n          # Get blueprint embeddings from cache or generate\n          target_embedding = get_blueprint_embedding(blueprint_id)\n          return [] unless target_embedding\n\n          # Find similar using KD-tree and priority queue\n          similar_vectors = @pipeline.find_similar_vectors(\n            target_embedding,\n            k: similarity_options[:k] * 2 # Get more candidates\n          )\n\n          # Refine similarity using full vector comparison\n          refined_similarities = refine_similarity_search(\n            target_embedding, similar_vectors, similarity_options\n          )\n\n          update_metrics(:similarity_search, Time.now - start_time)\n          refined_similarities\n        rescue StandardError => e\n          update_metrics(:similarity_error, Time.now - start_time, error: e.message)\n          []\n        end\n      end\n\n      # Analyze code complexity and patterns\n      def analyze_code_patterns(blueprint_data)\n        start_time = Time.now\n\n        begin\n          code_content = extract_code_content(blueprint_data)\n          return {} if code_content.empty?\n\n          # Use linguistic analysis for code pattern detection\n          linguistic_analysis = Processors::LinguisticsProcessor.new.process(code_content)\n\n          # Extract programming-specific patterns\n          patterns = {\n            function_patterns: extract_function_patterns(code_content),\n            class_patterns: extract_class_patterns(code_content),\n            variable_patterns: extract_variable_patterns(code_content),\n            comment_analysis: analyze_comments(code_content),\n            complexity_metrics: calculate_code_complexity(code_content, linguistic_analysis)\n          }\n\n          # Use Trie for pattern indexing\n          index_code_patterns(patterns)\n\n          update_metrics(:pattern_analysis, Time.now - start_time)\n          patterns\n        rescue StandardError => e\n          update_metrics(:pattern_error, Time.now - start_time, error: e.message)\n          { error: e.message }\n        end\n      end\n\n      # Get comprehensive service statistics\n      def get_statistics\n        {\n          pipeline_stats: @pipeline.get_statistics,\n          cache_stats: @cache_manager.statistics,\n          performance_metrics: @performance_metrics.to_h,\n          search_index_stats: @search_index ? calculate_index_stats : {},\n          memory_usage: estimate_memory_usage\n        }\n      end\n\n      # Rebuild search index for all blueprints\n      def rebuild_search_index(blueprints)\n        start_time = Time.now\n        @search_index = build_search_infrastructure\n\n        blueprints.each do |blueprint|\n          processed_result = process_blueprint(blueprint)\n          update_search_index(blueprint[:id], processed_result)\n        rescue StandardError => e\n          # Log error but continue processing other blueprints\n          puts \"Error processing blueprint #{blueprint[:id]}: #{e.message}\"\n        end\n\n        update_metrics(:index_rebuild, Time.now - start_time)\n        @search_index\n      end\n\n      private\n\n      def default_config\n        {\n          enable_spacy: true,\n          enable_linguistics: true,\n          enable_caching: true,\n          spacy_model: 'en_core_web_sm',\n          embedding_provider: :informers,\n          parallel_processing: false,\n          output_format: :detailed\n        }\n      end\n\n      def default_search_options\n        {\n          max_results: 20,\n          relevance_threshold: 0.6,\n          include_patterns: true,\n          include_embeddings: false,\n          boost_exact_matches: true\n        }\n      end\n\n      def initialize_pipeline\n        builder = PipelineBuilder.new\n\n        builder.with_spacy(model_name: @config[:spacy_model]) if @config[:enable_spacy]\n\n        builder.with_linguistics if @config[:enable_linguistics]\n\n        builder.configure({\n                            enable_caching: @config[:enable_caching],\n                            parallel_processing: @config[:parallel_processing],\n                            output_format: @config[:output_format]\n                          })\n\n        @pipeline = builder.build\n      end\n\n      def setup_embedding_service\n        @embedding_service = Services::InformersEmbeddingService.instance\n      end\n\n      def build_search_infrastructure\n        {\n          trie: Trie.new,\n          kd_tree_points: {},\n          priority_rankings: PriorityQueue.new { |x, y| x[:relevance] <=> y[:relevance] },\n          pattern_index: RBTreeMap.new,\n          concept_graph: build_concept_graph\n        }\n      end\n\n      def build_concept_graph\n        # Simple concept graph using adjacency list\n        {}\n      end\n\n      def extract_text_content(blueprint_data)\n        content_parts = []\n        content_parts << blueprint_data[:name] if blueprint_data[:name]\n        content_parts << blueprint_data[:description] if blueprint_data[:description]\n        content_parts << blueprint_data[:code] if blueprint_data[:code]\n        content_parts << blueprint_data[:tags]&.join(' ') if blueprint_data[:tags]\n\n        content_parts.join(' ')\n      end\n\n      def extract_code_content(blueprint_data)\n        blueprint_data[:code] || ''\n      end\n\n      def generate_blueprint_id(content)\n        Digest::MD5.hexdigest(content)[0..7]\n      end\n\n      def generate_embeddings(text, nlp_result)\n        # Use the embedding service with fallback\n        embedding = @embedding_service.generate_embedding(text)\n\n        # Enhance with NLP features if embedding generation fails\n        if embedding.nil? || embedding.empty?\n          build_feature_vector(nlp_result)\n        else\n          embedding\n        end\n      end\n\n      def build_feature_vector(nlp_result)\n        # Create simple feature vector from NLP analysis\n        features = []\n\n        # Keyword features\n        keyword_count = nlp_result.dig(:combined_analysis, :keywords)&.length || 0\n        features << (keyword_count.to_f / 100.0)\n\n        # Entity features\n        entity_count = nlp_result.dig(:combined_analysis, :entities)&.length || 0\n        features << (entity_count.to_f / 50.0)\n\n        # Concept features\n        concept_count = nlp_result.dig(:combined_analysis, :concepts)&.length || 0\n        features << (concept_count.to_f / 30.0)\n\n        # Complexity features\n        if nlp_result[:linguistics]\n          complexity = nlp_result[:linguistics][:complexity_metrics] || {}\n          (features << complexity[:lexical_diversity]) || 0.0\n          (features << complexity[:semantic_density]) || 0.0\n        else\n          features << 0.0\n          features << 0.0\n        end\n\n        # Pad to standard length\n        features << 0.0 while features.length < 768\n\n        features[0..767] # Ensure exactly 768 dimensions\n      end\n\n      def extract_code_features(_text, blueprint_data)\n        code = extract_code_content(blueprint_data)\n\n        {\n          language: detect_programming_language(code),\n          line_count: code.lines.count,\n          function_count: code.scan(/def\\s+\\w+|function\\s+\\w+|class\\s+\\w+/).length,\n          comment_ratio: calculate_comment_ratio(code),\n          complexity_score: estimate_cyclomatic_complexity(code),\n          imports: extract_imports(code),\n          patterns: detect_design_patterns(code)\n        }\n      end\n\n      def build_enhanced_analysis(blueprint_data, nlp_result, embeddings, code_features)\n        {\n          blueprint_id: blueprint_data[:id] || generate_blueprint_id(blueprint_data.to_s),\n          nlp_analysis: nlp_result,\n          embeddings: embeddings,\n          code_features: code_features,\n          enhanced_metadata: {\n            processing_timestamp: Time.now.iso8601,\n            content_hash: Digest::MD5.hexdigest(extract_text_content(blueprint_data)),\n            analysis_version: '1.0',\n            feature_counts: {\n              keywords: nlp_result.dig(:combined_analysis, :keywords)&.length || 0,\n              entities: nlp_result.dig(:combined_analysis, :entities)&.length || 0,\n              concepts: nlp_result.dig(:combined_analysis, :concepts)&.length || 0\n            }\n          },\n          search_metadata: build_search_metadata(nlp_result, code_features)\n        }\n      end\n\n      def build_search_metadata(nlp_result, code_features)\n        {\n          searchable_terms: extract_searchable_terms(nlp_result),\n          categorical_tags: extract_categorical_tags(nlp_result, code_features),\n          relevance_boosters: identify_relevance_boosters(nlp_result),\n          semantic_clusters: group_semantic_clusters(nlp_result)\n        }\n      end\n\n      def extract_searchable_terms(nlp_result)\n        terms = []\n\n        # Add keywords\n        if nlp_result.dig(:combined_analysis, :keywords)\n          nlp_result[:combined_analysis][:keywords].each do |keyword|\n            terms << (keyword[:text] || keyword[:word] || keyword.to_s).downcase\n          end\n        end\n\n        # Add entity names\n        if nlp_result.dig(:combined_analysis, :entities)\n          nlp_result[:combined_analysis][:entities].each do |entity|\n            terms << entity[:text].downcase if entity[:text]\n          end\n        end\n\n        # Add concept words\n        if nlp_result.dig(:combined_analysis, :concepts)\n          nlp_result[:combined_analysis][:concepts].each do |concept|\n            terms << concept[:word].downcase if concept[:word]\n          end\n        end\n\n        terms.uniq\n      end\n\n      def extract_categorical_tags(nlp_result, code_features)\n        tags = []\n\n        # Language-based tags\n        tags << code_features[:language] if code_features[:language]\n\n        # Complexity tags\n        complexity = code_features[:complexity_score] || 0\n        tags << case complexity\n                when 0..3 then 'simple'\n                when 4..7 then 'moderate'\n                else 'complex'\n                end\n\n        # Content-based tags\n        tags << 'entity-rich' if nlp_result.dig(:combined_analysis, :entities)&.any?\n\n        tags << 'keyword-dense' if nlp_result.dig(:combined_analysis, :keywords)&.length.to_i > 10\n\n        tags\n      end\n\n      def identify_relevance_boosters(nlp_result)\n        boosters = {}\n\n        # High-value keywords get boost\n        if nlp_result.dig(:combined_analysis, :keywords)\n          high_value_keywords = nlp_result[:combined_analysis][:keywords]\n                                .select { |k| (k[:score] || 0) > 0.7 }\n                                .map { |k| k[:text] || k[:word] }\n          boosters[:high_value_keywords] = high_value_keywords\n        end\n\n        # Named entities get boost\n        if nlp_result.dig(:combined_analysis, :entities)\n          entities = nlp_result[:combined_analysis][:entities]\n                     .select { |e| e[:confidence] > 0.8 }\n                     .map { |e| e[:text] }\n          boosters[:named_entities] = entities\n        end\n\n        boosters\n      end\n\n      def group_semantic_clusters(nlp_result)\n        clusters = {}\n\n        # Group concepts by semantic field\n        if nlp_result[:linguistics] && nlp_result[:linguistics][:concepts]\n          nlp_result[:linguistics][:concepts].each do |concept|\n            category = concept[:category] || 'general'\n            clusters[category] ||= []\n            clusters[category] << concept[:word]\n          end\n        end\n\n        clusters\n      end\n\n      def update_search_index(blueprint_id, enhanced_result)\n        return unless @search_index\n\n        # Index searchable terms in Trie\n        searchable_terms = enhanced_result.dig(:search_metadata, :searchable_terms) || []\n        searchable_terms.each do |term|\n          @search_index[:trie][term] = blueprint_id\n        end\n\n        # Add to KD-tree for vector search\n        if enhanced_result[:embeddings].is_a?(Array) && enhanced_result[:embeddings].length >= 2\n          @search_index[:kd_tree_points][blueprint_id] = enhanced_result[:embeddings][0..1]\n        end\n\n        # Add to priority queue with relevance score\n        relevance = calculate_relevance_score(enhanced_result)\n        @search_index[:priority_rankings].push(\n          { blueprint_id: blueprint_id, enhanced_result: enhanced_result, relevance: relevance },\n          relevance\n        )\n\n        # Index patterns\n        return unless enhanced_result[:code_features] && enhanced_result[:code_features][:patterns]\n\n        enhanced_result[:code_features][:patterns].each do |pattern|\n          @search_index[:pattern_index][pattern] = blueprint_id\n        end\n      end\n\n      def calculate_relevance_score(enhanced_result)\n        score = 0.0\n\n        # Feature count contribution\n        feature_counts = enhanced_result.dig(:enhanced_metadata, :feature_counts) || {}\n        score += (feature_counts[:keywords] || 0) * 0.1\n        score += (feature_counts[:entities] || 0) * 0.2\n        score += (feature_counts[:concepts] || 0) * 0.15\n\n        # Code features contribution\n        if enhanced_result[:code_features]\n          score += enhanced_result[:code_features][:function_count] * 0.05\n          score += (1.0 - (enhanced_result[:code_features][:complexity_score] / 10.0)) * 0.2\n        end\n\n        # Analysis quality contribution\n        if enhanced_result[:nlp_analysis] && enhanced_result[:nlp_analysis][:analysis_scores]\n          score += enhanced_result[:nlp_analysis][:analysis_scores][:quality] * 0.3\n        end\n\n        score.clamp(0.0, 1.0)\n      end\n\n      def enrich_cached_result(cached_result, blueprint_id)\n        cached_result.merge(\n          blueprint_id: blueprint_id,\n          cache_hit: true,\n          retrieved_at: Time.now.iso8601\n        )\n      end\n\n      def build_fallback_analysis(blueprint_data, error_message)\n        {\n          blueprint_id: blueprint_data[:id] || generate_blueprint_id(blueprint_data.to_s),\n          error: error_message,\n          fallback_analysis: {\n            basic_features: extract_basic_features(blueprint_data),\n            content_hash: Digest::MD5.hexdigest(extract_text_content(blueprint_data))\n          },\n          processing_timestamp: Time.now.iso8601\n        }\n      end\n\n      def extract_basic_features(blueprint_data)\n        content = extract_text_content(blueprint_data)\n        {\n          character_count: content.length,\n          word_count: content.split.length,\n          line_count: content.lines.count,\n          has_code: !extract_code_content(blueprint_data).empty?\n        }\n      end\n\n      def rank_search_results(query_analysis, search_results, options)\n        # Enhanced ranking using multiple factors\n        scored_results = search_results.map do |result|\n          score = result[:total_score] || 0.0\n\n          # Boost for exact keyword matches\n          if options[:boost_exact_matches] && query_analysis[:combined_analysis]\n            query_keywords = query_analysis[:combined_analysis][:keywords] || []\n            query_keywords.each do |keyword|\n              score += 0.2 if result[:details]&.to_s&.include?(keyword[:text] || keyword[:word])\n            end\n          end\n\n          result.merge(final_score: score)\n        end\n\n        scored_results.sort_by { |r| -r[:final_score] }\n      end\n\n      def apply_relevance_filters(ranked_results, options)\n        threshold = options[:relevance_threshold] || 0.0\n        max_results = options[:max_results] || 20\n\n        filtered = ranked_results.select { |r| (r[:final_score] || 0) >= threshold }\n        filtered.first(max_results)\n      end\n\n      def get_blueprint_embedding(blueprint_id)\n        # Try to get from cache first\n        cached_embedding = @cache_manager.get(:embedding, blueprint_id, :informers, 'default')\n        return cached_embedding if cached_embedding\n\n        # If not cached, would need to regenerate from blueprint data\n        # This would require access to the database - simplified for now\n        nil\n      end\n\n      def refine_similarity_search(target_embedding, similar_vectors, options)\n        refined = []\n\n        similar_vectors.each do |distance, vector_id|\n          # Calculate actual cosine similarity\n          similarity = calculate_cosine_similarity(target_embedding, vector_id)\n\n          next unless similarity >= options[:threshold]\n\n          refined << {\n            blueprint_id: vector_id,\n            similarity: similarity,\n            distance: distance\n          }\n        end\n\n        refined.sort_by { |item| -item[:similarity] }.first(options[:k])\n      end\n\n      def calculate_cosine_similarity(_vector1, _vector2)\n        # Simplified cosine similarity - would need actual vector data\n        0.8 + rand(0.2) # Placeholder\n      end\n\n      def detect_programming_language(code)\n        return 'unknown' if code.empty?\n\n        # Simple language detection based on patterns\n        case code\n        when /def\\s+\\w+.*:/, /import\\s+\\w+/, /from\\s+\\w+\\s+import/\n          'python'\n        when /function\\s+\\w+/, /const\\s+\\w+\\s*=/, /let\\s+\\w+\\s*=/\n          'javascript'\n        when /def\\s+\\w+/, /class\\s+\\w+/, %r{require\\s+['\"][\\w/]+['\"]}\n          'ruby'\n        when /#include\\s*</, /int\\s+main\\s*\\(/\n          'c'\n        else\n          'unknown'\n        end\n      end\n\n      def calculate_comment_ratio(code)\n        return 0.0 if code.empty?\n\n        total_lines = code.lines.count\n        comment_lines = code.lines.count { |line| line.strip.start_with?('#', '//', '/*', '*') }\n\n        comment_lines.to_f / total_lines\n      end\n\n      def estimate_cyclomatic_complexity(code)\n        # Simple cyclomatic complexity estimation\n        complexity = 1 # Base complexity\n\n        # Count decision points\n        complexity += code.scan(/if\\s|elif\\s|else\\s|for\\s|while\\s|case\\s|when\\s/).length\n        complexity += code.scan(/&&|\\|\\||and\\s|or\\s/).length\n        complexity += code.scan(/\\?.*:/).length # Ternary operators\n\n        complexity\n      end\n\n      def extract_imports(code)\n        imports = []\n\n        # Python imports\n        imports.concat(code.scan(/^(?:from\\s+(\\S+)\\s+)?import\\s+(.+)$/))\n\n        # Ruby requires\n        imports.concat(code.scan(/require\\s+['\"](.+?)['\"]/).flatten)\n\n        # JavaScript imports\n        imports.concat(code.scan(/import\\s+.*?from\\s+['\"](.+?)['\"]/).flatten)\n\n        imports.flatten.uniq\n      end\n\n      def detect_design_patterns(code)\n        patterns = []\n\n        # Singleton pattern\n        patterns << 'singleton' if code.include?('@@instance') || code.include?('getInstance')\n\n        # Factory pattern\n        patterns << 'factory' if code.match?(/create\\w*\\(/i) || code.include?('Factory')\n\n        # Observer pattern\n        patterns << 'observer' if code.include?('notify') || code.include?('Observer')\n\n        # Strategy pattern\n        patterns << 'strategy' if code.include?('Strategy') || code.match?(/execute\\w*\\(/i)\n\n        patterns\n      end\n\n      def extract_function_patterns(code)\n        functions = code.scan(/def\\s+(\\w+)|function\\s+(\\w+)/).flatten.compact\n        {\n          count: functions.length,\n          names: functions,\n          avg_name_length: functions.empty? ? 0 : functions.sum(&:length).to_f / functions.length\n        }\n      end\n\n      def extract_class_patterns(code)\n        classes = code.scan(/class\\s+(\\w+)/).flatten\n        {\n          count: classes.length,\n          names: classes,\n          inheritance: code.scan(/class\\s+\\w+\\s*<\\s*(\\w+)/).flatten\n        }\n      end\n\n      def extract_variable_patterns(code)\n        # Simple variable extraction\n        variables = code.scan(/(\\w+)\\s*=/).flatten.uniq\n        {\n          count: variables.length,\n          naming_convention: analyze_naming_convention(variables)\n        }\n      end\n\n      def analyze_naming_convention(variables)\n        return 'unknown' if variables.empty?\n\n        snake_case = variables.count { |v| v.match?(/^[a-z]+(_[a-z]+)*$/) }\n        camel_case = variables.count { |v| v.match?(/^[a-z]+([A-Z][a-z]*)*$/) }\n\n        if snake_case > camel_case\n          'snake_case'\n        elsif camel_case > snake_case\n          'camelCase'\n        else\n          'mixed'\n        end\n      end\n\n      def analyze_comments(code)\n        comment_lines = code.lines.select { |line| line.strip.start_with?('#', '//', '/*', '*') }\n\n        {\n          count: comment_lines.length,\n          avg_length: comment_lines.empty? ? 0 : comment_lines.sum(&:length).to_f / comment_lines.length,\n          has_docstrings: code.include?('\"\"\"') || code.include?(\"'''\")\n        }\n      end\n\n      def calculate_code_complexity(code, linguistic_analysis)\n        base_complexity = estimate_cyclomatic_complexity(code)\n\n        # Enhance with linguistic metrics\n        linguistic_complexity = 0.0\n        if linguistic_analysis[:complexity_metrics]\n          linguistic_complexity = linguistic_analysis[:complexity_metrics][:lexical_diversity] || 0.0\n        end\n\n        {\n          cyclomatic: base_complexity,\n          linguistic: linguistic_complexity,\n          combined: (base_complexity + (linguistic_complexity * 10)) / 2.0\n        }\n      end\n\n      def index_code_patterns(patterns)\n        return unless @search_index\n\n        # Index patterns in Red-Black tree for ordered access\n        patterns.each do |pattern_type, pattern_data|\n          if pattern_data.is_a?(Hash) && pattern_data[:names]\n            pattern_data[:names].each do |name|\n              @search_index[:pattern_index][\"#{pattern_type}_#{name}\"] = pattern_data\n            end\n          elsif pattern_data.is_a?(Array)\n            pattern_data.each do |pattern|\n              @search_index[:pattern_index][\"#{pattern_type}_#{pattern}\"] = true\n            end\n          end\n        end\n      end\n\n      def calculate_index_stats\n        return {} unless @search_index\n\n        {\n          trie_entries: @search_index[:trie].size,\n          kd_tree_points: @search_index[:kd_tree_points].size,\n          priority_queue_size: @search_index[:priority_rankings].size,\n          pattern_index_size: @search_index[:pattern_index].size\n        }\n      end\n\n      def estimate_memory_usage\n        # Rough memory estimation\n        base_usage = 0\n        base_usage += if @search_index\n                        @search_index.values.sum do |v|\n                          v.respond_to?(:size) ? v.size : 1\n                        end * 100\n                      else\n                        0\n                      end\n        base_usage += @performance_metrics.size * 50\n\n        \"#{base_usage}KB (estimated)\"\n      end\n\n      def update_metrics(operation, duration, error: nil)\n        @performance_metrics[operation] ||= {\n          count: 0,\n          total_duration: 0.0,\n          success_count: 0,\n          avg_duration: 0.0,\n          errors: []\n        }\n\n        @performance_metrics[operation][:count] += 1\n        @performance_metrics[operation][:total_duration] += duration\n        @performance_metrics[operation][:success_count] += 1 unless error\n        @performance_metrics[operation][:avg_duration] =\n          @performance_metrics[operation][:total_duration] / @performance_metrics[operation][:count]\n\n        return unless error\n\n        @performance_metrics[operation][:errors] << {\n          message: error,\n          timestamp: Time.now.iso8601\n        }\n        # Keep only last 10 errors\n        @performance_metrics[operation][:errors] =\n          @performance_metrics[operation][:errors].last(10)\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/nlp/"
    },
    {
      "filename": "pipeline_builder.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'processors/spacy_processor'\nrequire_relative 'processors/linguistics_processor'\nrequire 'algorithms'\n\nmodule BlueprintsCLI\n  module NLP\n    # Builder pattern implementation for constructing NLP processing pipelines\n    # Integrates multiple processors with algorithmic optimizations\n    class PipelineBuilder\n      include Containers\n\n      attr_reader :processors, :pipeline_config, :performance_metrics\n\n      def initialize\n        @processors = []\n        @pipeline_config = {\n          enable_caching: true,\n          cache_ttl: 3600,\n          parallel_processing: false,\n          output_format: :detailed\n        }\n        @performance_metrics = RBTreeMap.new\n        @result_cache = Trie.new\n        @processor_priority = PriorityQueue.new\n      end\n\n      # Add SpaCy processor to pipeline\n      def with_spacy(model_name: 'en_core_web_sm', priority: 10)\n        processor_config = {\n          type: :spacy,\n          processor: Processors::SpacyProcessor.new(model_name: model_name),\n          priority: priority,\n          enabled: true\n        }\n\n        @processors << processor_config\n        @processor_priority.push(processor_config, priority)\n        self\n      end\n\n      # Add Linguistics processor to pipeline\n      def with_linguistics(priority: 20)\n        processor_config = {\n          type: :linguistics,\n          processor: Processors::LinguisticsProcessor.new,\n          priority: priority,\n          enabled: true\n        }\n\n        @processors << processor_config\n        @processor_priority.push(processor_config, priority)\n        self\n      end\n\n      # Configure pipeline settings\n      def configure(options = {})\n        @pipeline_config.merge!(options)\n        self\n      end\n\n      # Enable result caching\n      def with_caching(ttl: 3600)\n        @pipeline_config[:enable_caching] = true\n        @pipeline_config[:cache_ttl] = ttl\n        self\n      end\n\n      # Enable parallel processing of processors\n      def with_parallel_processing\n        @pipeline_config[:parallel_processing] = true\n        self\n      end\n\n      # Set output format (detailed, summary, minimal)\n      def output_format(format)\n        @pipeline_config[:output_format] = format\n        self\n      end\n\n      # Build and return the configured pipeline\n      def build\n        raise 'No processors configured' if @processors.empty?\n\n        # Sort processors by priority using the priority queue\n        ordered_processors = []\n        temp_queue = @processor_priority.dup\n\n        ordered_processors << temp_queue.pop until temp_queue.empty?\n\n        Pipeline.new(ordered_processors, @pipeline_config)\n      end\n    end\n\n    # Main NLP Pipeline class that orchestrates multiple processors\n    class Pipeline\n      include Containers\n\n      attr_reader :processors, :config, :metrics\n\n      def initialize(processors, config)\n        @processors = processors\n        @config = config\n        @metrics = RBTreeMap.new\n        @result_cache = Trie.new if config[:enable_caching]\n        @hybrid_results = {}\n      end\n\n      # Process text through the entire pipeline\n      def process(text)\n        start_time = Time.now\n\n        begin\n          # Check cache if enabled\n          if @config[:enable_caching] && (cached_result = get_cached_result(text))\n            return cached_result\n          end\n\n          # Process through each processor\n          results = if @config[:parallel_processing]\n                      process_parallel(text)\n                    else\n                      process_sequential(text)\n                    end\n\n          # Merge and optimize results\n          final_result = merge_results(results, text)\n\n          # Cache result if enabled\n          cache_result(text, final_result) if @config[:enable_caching]\n\n          # Update performance metrics\n          duration = Time.now - start_time\n          update_metrics(:pipeline_processing, duration, final_result)\n\n          format_output(final_result)\n        rescue StandardError => e\n          duration = Time.now - start_time\n          update_metrics(:pipeline_processing, duration, nil, error: e.message)\n\n          {\n            error: e.message,\n            partial_results: @hybrid_results,\n            processing_time: duration\n          }\n        end\n      end\n\n      # Get processing statistics\n      def get_statistics\n        stats = {}\n\n        @metrics.each do |key, value|\n          stats[key] = {\n            total_calls: value[:count],\n            avg_duration: value[:avg_duration],\n            success_rate: value[:success_count].to_f / value[:count],\n            total_duration: value[:total_duration]\n          }\n        end\n\n        stats\n      end\n\n      # Build hybrid search index from processed results\n      def build_search_index(processed_texts)\n        search_index = {\n          trie: Trie.new,\n          kd_tree_points: {},\n          priority_rankings: PriorityQueue.new { |x, y| x[:relevance] <=> y[:relevance] }\n        }\n\n        processed_texts.each_with_index do |(text_id, results), _index|\n          # Index keywords in Trie for fast prefix search\n          if results[:spacy] && results[:spacy][:keywords]\n            results[:spacy][:keywords].each do |keyword|\n              search_index[:trie][keyword[:text].downcase] = text_id\n            end\n          end\n\n          # Index concepts in Trie\n          if results[:linguistics] && results[:linguistics][:concepts]\n            results[:linguistics][:concepts].each do |concept|\n              search_index[:trie][concept[:word].downcase] = text_id\n            end\n          end\n\n          # Build semantic vectors for KD-tree\n          if results[:semantic_vector]\n            search_index[:kd_tree_points][text_id] = results[:semantic_vector][0..1] # 2D for KD-tree\n          end\n\n          # Add to priority queue with relevance score\n          relevance_score = calculate_relevance_score(results)\n          search_index[:priority_rankings].push(\n            { text_id: text_id, results: results, relevance: relevance_score },\n            relevance_score\n          )\n        end\n\n        # Build KD-tree if we have vector data\n        if search_index[:kd_tree_points].any?\n          search_index[:kd_tree] = KDTree.new(search_index[:kd_tree_points])\n        end\n\n        search_index\n      end\n\n      # Search using hybrid approach (Trie + KD-tree + Priority Queue)\n      def hybrid_search(query, search_index, options = {})\n        results = {\n          prefix_matches: [],\n          semantic_matches: [],\n          ranked_results: []\n        }\n\n        # Prefix search using Trie\n        query_words = query.downcase.split\n        query_words.each do |word|\n          if search_index[:trie].key?(word)\n            results[:prefix_matches] << {\n              word: word,\n              text_id: search_index[:trie][word],\n              match_type: 'exact'\n            }\n          else\n            # Wildcard search for partial matches\n            wildcard_matches = search_index[:trie].wildcard(\"#{word}*\")\n            wildcard_matches.each do |match|\n              next unless search_index[:trie].key?(match)\n\n              results[:prefix_matches] << {\n                word: match,\n                text_id: search_index[:trie][match],\n                match_type: 'partial'\n              }\n            end\n          end\n        end\n\n        # Semantic search using KD-tree (if query has vector representation)\n        if options[:query_vector] && search_index[:kd_tree]\n          nearest_neighbors = search_index[:kd_tree].find_nearest(\n            options[:query_vector][0..1],\n            options[:k] || 5\n          )\n\n          nearest_neighbors.each do |distance, text_id|\n            results[:semantic_matches] << {\n              text_id: text_id,\n              distance: distance,\n              similarity: 1.0 / (1.0 + distance) # Convert distance to similarity\n            }\n          end\n        end\n\n        # Get top-ranked results from priority queue\n        temp_queue = search_index[:priority_rankings].dup\n        rank_count = 0\n\n        while !temp_queue.empty? && rank_count < (options[:max_results] || 10)\n          ranked_item = temp_queue.pop\n          results[:ranked_results] << ranked_item\n          rank_count += 1\n        end\n\n        # Combine and deduplicate results\n        combine_search_results(results, options)\n      end\n\n      private\n\n      def process_sequential(text)\n        results = {}\n\n        @processors.each do |processor_config|\n          next unless processor_config[:enabled]\n\n          processor_type = processor_config[:type]\n          processor = processor_config[:processor]\n\n          begin\n            result = processor.process(text)\n            results[processor_type] = result\n            @hybrid_results[processor_type] = result\n          rescue StandardError => e\n            results[processor_type] = { error: e.message }\n          end\n        end\n\n        results\n      end\n\n      def process_parallel(text)\n        # NOTE: In a real implementation, you'd use threads or processes\n        # For now, we'll simulate parallel processing\n        results = {}\n\n        @processors.each do |processor_config|\n          next unless processor_config[:enabled]\n\n          processor_type = processor_config[:type]\n          processor = processor_config[:processor]\n\n          # Simulate parallel processing\n          Thread.new do\n            result = processor.process(text)\n            results[processor_type] = result\n          rescue StandardError => e\n            results[processor_type] = { error: e.message }\n          end\n        end\n\n        # Wait for all threads to complete (simplified)\n        sleep(0.1) # In real implementation, use proper thread management\n\n        results\n      end\n\n      def merge_results(results, original_text)\n        merged = {\n          original_text: original_text,\n          processing_timestamp: Time.now.iso8601,\n          processors_used: results.keys,\n          combined_analysis: {}\n        }\n\n        # Merge results from different processors\n        results.each do |processor_type, result|\n          merged[processor_type] = result\n\n          # Extract common elements for combined analysis\n          if result[:keywords]\n            merged[:combined_analysis][:keywords] ||= []\n            merged[:combined_analysis][:keywords].concat(result[:keywords])\n          end\n\n          if result[:entities]\n            merged[:combined_analysis][:entities] ||= []\n            merged[:combined_analysis][:entities].concat(result[:entities])\n          end\n\n          if result[:concepts]\n            merged[:combined_analysis][:concepts] ||= []\n            merged[:combined_analysis][:concepts].concat(result[:concepts])\n          end\n        end\n\n        # Deduplicate and rank combined results\n        if merged[:combined_analysis][:keywords]\n          merged[:combined_analysis][:keywords] = deduplicate_and_rank_keywords(\n            merged[:combined_analysis][:keywords]\n          )\n        end\n\n        # Generate semantic vector for the entire analysis\n        merged[:semantic_vector] = generate_semantic_vector(merged)\n\n        # Calculate overall analysis scores\n        merged[:analysis_scores] = calculate_analysis_scores(merged)\n\n        merged\n      end\n\n      def deduplicate_and_rank_keywords(keywords)\n        # Use Red-Black tree to maintain ordered unique keywords\n        keyword_map = RBTreeMap.new\n\n        keywords.each do |keyword|\n          key = keyword[:text] || keyword[:word] || keyword.to_s\n\n          if keyword_map.key?(key)\n            # Merge scores if duplicate\n            existing = keyword_map[key]\n            existing[:score] = [existing[:score], keyword[:score] || 0].max\n          else\n            keyword_map[key] = keyword\n          end\n        end\n\n        # Convert back to array and sort by score\n        unique_keywords = keyword_map.values.sort_by { |k| -(k[:score] || 0) }\n        unique_keywords.first(20) # Limit to top 20\n      end\n\n      def generate_semantic_vector(merged_results)\n        # Simple semantic vector based on analysis features\n        vector = []\n\n        # Feature 1: Keyword density\n        keyword_count = merged_results.dig(:combined_analysis, :keywords)&.length || 0\n        vector << (keyword_count.to_f / 100.0)\n\n        # Feature 2: Entity density\n        entity_count = merged_results.dig(:combined_analysis, :entities)&.length || 0\n        vector << (entity_count.to_f / 50.0)\n\n        # Feature 3: Concept complexity\n        concept_count = merged_results.dig(:combined_analysis, :concepts)&.length || 0\n        vector << (concept_count.to_f / 30.0)\n\n        # Feature 4: Linguistic complexity (if available)\n        if merged_results[:linguistics] && merged_results[:linguistics][:complexity_metrics]\n          complexity = merged_results[:linguistics][:complexity_metrics]\n          (vector << complexity[:lexical_diversity]) || 0.0\n        else\n          vector << 0.0\n        end\n\n        vector\n      end\n\n      def calculate_analysis_scores(merged_results)\n        scores = {}\n\n        # Information density score\n        total_features = 0\n        total_features += merged_results.dig(:combined_analysis, :keywords)&.length || 0\n        total_features += merged_results.dig(:combined_analysis, :entities)&.length || 0\n        total_features += merged_results.dig(:combined_analysis, :concepts)&.length || 0\n\n        text_length = merged_results[:original_text].length\n        scores[:information_density] =\n          text_length.positive? ? total_features.to_f / text_length * 1000 : 0\n\n        # Processing completeness score\n        expected_processors = @processors.count { |p| p[:enabled] }\n        actual_processors = merged_results[:processors_used].length\n        scores[:completeness] = actual_processors.to_f / expected_processors\n\n        # Quality score (based on successful extractions)\n        quality_indicators = 0\n        quality_indicators += 1 if merged_results.dig(:combined_analysis, :keywords)&.any?\n        quality_indicators += 1 if merged_results.dig(:combined_analysis, :entities)&.any?\n        quality_indicators += 1 if merged_results.dig(:combined_analysis, :concepts)&.any?\n        scores[:quality] = quality_indicators.to_f / 3.0\n\n        scores\n      end\n\n      def calculate_relevance_score(results)\n        score = 0.0\n\n        # Score based on extracted features\n        if results[:spacy]\n          score += (results[:spacy][:keywords]&.length || 0) * 0.1\n          score += (results[:spacy][:entities]&.length || 0) * 0.2\n        end\n\n        if results[:linguistics]\n          score += (results[:linguistics][:concepts]&.length || 0) * 0.15\n          score += (results[:linguistics][:complexity_metrics]&.dig(:semantic_density) || 0) * 0.3\n        end\n\n        # Bonus for analysis completeness\n        score += results[:analysis_scores][:completeness] * 0.25 if results[:analysis_scores]\n\n        score.clamp(0.0, 1.0)\n      end\n\n      def combine_search_results(results, options)\n        combined = {}\n        text_ids = Set.new\n\n        # Collect all unique text IDs\n        results[:prefix_matches].each { |match| text_ids << match[:text_id] }\n        results[:semantic_matches].each { |match| text_ids << match[:text_id] }\n        results[:ranked_results].each { |result| text_ids << result[:text_id] }\n\n        # Score each text ID based on different match types\n        text_ids.each do |text_id|\n          score = 0.0\n          match_types = []\n\n          # Prefix match score\n          prefix_matches = results[:prefix_matches].select { |m| m[:text_id] == text_id }\n          if prefix_matches.any?\n            exact_matches = prefix_matches.count { |m| m[:match_type] == 'exact' }\n            partial_matches = prefix_matches.count { |m| m[:match_type] == 'partial' }\n            score += (exact_matches * 0.5) + (partial_matches * 0.2)\n            match_types << 'lexical'\n          end\n\n          # Semantic match score\n          semantic_match = results[:semantic_matches].find { |m| m[:text_id] == text_id }\n          if semantic_match\n            score += semantic_match[:similarity] * 0.4\n            match_types << 'semantic'\n          end\n\n          # Ranking score\n          ranked_result = results[:ranked_results].find { |r| r[:text_id] == text_id }\n          if ranked_result\n            score += ranked_result[:relevance] * 0.3\n            match_types << 'ranked'\n          end\n\n          combined[text_id] = {\n            text_id: text_id,\n            total_score: score,\n            match_types: match_types.uniq,\n            details: {\n              prefix_matches: prefix_matches,\n              semantic_match: semantic_match,\n              ranked_result: ranked_result\n            }\n          }\n        end\n\n        # Sort by total score and return top results\n        sorted_results = combined.values.sort_by { |r| -r[:total_score] }\n        sorted_results.first(options[:max_results] || 10)\n      end\n\n      def format_output(result)\n        case @config[:output_format]\n        when :minimal\n          {\n            keywords: result.dig(:combined_analysis, :keywords)&.first(5),\n            entities: result.dig(:combined_analysis, :entities)&.first(3),\n            summary_scores: result[:analysis_scores]\n          }\n        when :summary\n          {\n            processors_used: result[:processors_used],\n            combined_analysis: result[:combined_analysis],\n            analysis_scores: result[:analysis_scores],\n            processing_timestamp: result[:processing_timestamp]\n          }\n        else # :detailed\n          result\n        end\n      end\n\n      def get_cached_result(text)\n        return nil unless @result_cache\n\n        cache_key = generate_cache_key(text)\n        @result_cache[cache_key] if @result_cache.key?(cache_key)\n      end\n\n      def cache_result(text, result)\n        return unless @result_cache\n\n        cache_key = generate_cache_key(text)\n        @result_cache[cache_key] = result\n      end\n\n      def generate_cache_key(text)\n        \"pipeline_#{Digest::MD5.hexdigest(text[0..200])}\"\n      end\n\n      def update_metrics(operation, duration, _result, error: nil)\n        @metrics[operation] ||= {\n          count: 0,\n          total_duration: 0.0,\n          success_count: 0,\n          avg_duration: 0.0\n        }\n\n        @metrics[operation][:count] += 1\n        @metrics[operation][:total_duration] += duration\n        @metrics[operation][:success_count] += 1 unless error\n        @metrics[operation][:avg_duration] =\n          @metrics[operation][:total_duration] / @metrics[operation][:count]\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/nlp/"
    },
    {
      "filename": "base_processor.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'algorithms'\n\nmodule BlueprintsCLI\n  module NLP\n    module Processors\n      # Abstract base class for NLP processors providing common functionality\n      # and data structure optimizations using the algorithms gem\n      class BaseProcessor\n        include Containers\n\n        attr_reader :cache, :metrics, :trie_index\n\n        def initialize\n          @cache = RBTreeMap.new  # Red-Black tree for ordered metadata storage\n          @metrics = {}\n          @trie_index = Trie.new  # For fast prefix-based lookups\n          @priority_queue = PriorityQueue.new { |x, y| x[:score] <=> y[:score] }\n          @kd_tree_data = {}      # Will be built as needed for vector operations\n        end\n\n        # Abstract method - must be implemented by subclasses\n        def process(text)\n          raise NotImplementedError, \"#{self.class}#process must be implemented\"\n        end\n\n        # Extract key terms using Trie-based prefix matching\n        def extract_key_terms(text, min_length: 3)\n          terms = []\n          words = tokenize(text)\n\n          words.each do |word|\n            next if word.length < min_length\n\n            # Use Trie for efficient prefix matching\n            next unless @trie_index.key?(word.downcase)\n\n            terms << {\n              term: word,\n              canonical: @trie_index[word.downcase],\n              score: calculate_term_score(word)\n            }\n          end\n\n          # Use priority queue to rank terms by relevance\n          terms.each { |term| @priority_queue.push(term, term[:score]) }\n\n          # Extract top terms\n          top_terms = []\n          top_terms << @priority_queue.pop while !@priority_queue.empty? && top_terms.length < 10\n\n          top_terms\n        end\n\n        # Build KD-tree for high-dimensional similarity search\n        def build_vector_index(embeddings_hash)\n          return if embeddings_hash.empty?\n\n          # Convert to format expected by KD-tree\n          points = embeddings_hash.transform_values do |embedding|\n            # Reduce dimensionality for KD-tree efficiency (first 2 dimensions)\n            embedding[0..1] if embedding.is_a?(Array)\n          end.compact\n\n          @kd_tree = KDTree.new(points) if points.any?\n        end\n\n        # Find nearest neighbors using KD-tree\n        def find_similar_vectors(target_vector, k: 5)\n          return [] unless @kd_tree && target_vector.is_a?(Array)\n\n          # Use first 2 dimensions for KD-tree search\n          search_vector = target_vector[0..1]\n          @kd_tree.find_nearest(search_vector, k) || []\n        end\n\n        # Cache results using Red-Black tree for ordered access\n        def cache_result(key, result, metadata = {})\n          cache_entry = {\n            result: result,\n            timestamp: Time.now,\n            metadata: metadata\n          }\n          @cache[key] = cache_entry\n\n          # Maintain cache size limit\n          return unless @cache.size > 1000\n\n          # Remove oldest entries (Red-Black tree maintains order)\n          @cache.delete(@cache.min[0])\n        end\n\n        # Retrieve cached result\n        def get_cached_result(key)\n          entry = @cache[key]\n          return nil unless entry\n\n          # Check if cache entry is still valid (24 hours)\n          if Time.now - entry[:timestamp] < 86_400\n            entry[:result]\n          else\n            @cache.delete(key)\n            nil\n          end\n        end\n\n        # Update metrics\n        def update_metrics(operation, duration, success = true)\n          @metrics[operation] ||= {\n            count: 0,\n            total_duration: 0.0,\n            success_count: 0,\n            avg_duration: 0.0\n          }\n\n          @metrics[operation][:count] += 1\n          @metrics[operation][:total_duration] += duration\n          @metrics[operation][:success_count] += 1 if success\n          @metrics[operation][:avg_duration] =\n            @metrics[operation][:total_duration] / @metrics[operation][:count]\n        end\n\n        private\n\n        # Basic tokenization - to be enhanced by subclasses\n        def tokenize(text)\n          text.downcase.scan(/\\b\\w+\\b/)\n        end\n\n        # Calculate term importance score\n        def calculate_term_score(term)\n          # Basic scoring - can be enhanced with TF-IDF, etc.\n          base_score = term.length.to_f / 10.0\n          base_score += 0.5 if term.match?(/[A-Z]/) # Bonus for proper nouns\n          base_score\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/nlp/processors/"
    },
    {
      "filename": "linguistics_processor.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'base_processor'\n\nbegin\n  require 'linguistics'\n  LINGUISTICS_AVAILABLE = true\nrescue LoadError\n  LINGUISTICS_AVAILABLE = false\n  puts 'Warning: linguistics gem not available. Linguistics processor will be disabled.'\nend\n\nbegin\n  require 'rwordnet'\n  require 'wordnet'\n  WORDNET_AVAILABLE = true\nrescue LoadError\n  WORDNET_AVAILABLE = false\n  puts 'Warning: rwordnet gem not available. WordNet features will be disabled.'\nend\n\nmodule BlueprintsCLI\n  module NLP\n    module Processors\n      # Linguistics gem processor for morphological analysis and WordNet integration\n      # Provides inflection, pluralization, stemming, and semantic relationships\n      class LinguisticsProcessor < BaseProcessor\n        include Linguistics if LINGUISTICS_AVAILABLE\n\n        attr_reader :wordnet\n\n        def initialize\n          super\n\n          if LINGUISTICS_AVAILABLE\n            setup_linguistics\n          else\n            puts 'Linguistics processor initialized in fallback mode'\n          end\n\n          if WORDNET_AVAILABLE\n            begin\n              @wordnet = WordNet::WordNetDB.instance\n            rescue StandardError => e\n              puts \"Warning: Could not initialize WordNet: #{e.message}\"\n              @wordnet = nil\n            end\n          else\n            @wordnet = nil\n          end\n\n          build_morphology_trie\n        end\n\n        # Main processing method using Linguistics and WordNet\n        def process(text)\n          start_time = Time.now\n\n          begin\n            # Check cache first\n            cache_key = generate_cache_key(text)\n            if (cached_result = get_cached_result(cache_key))\n              return cached_result\n            end\n\n            # Return fallback if libraries not available\n            return fallback_processing(text) unless LINGUISTICS_AVAILABLE || WORDNET_AVAILABLE\n\n            # Tokenize and analyze\n            words = tokenize_advanced(text)\n\n            result = {\n              morphology: analyze_morphology(words),\n              inflections: analyze_inflections(words),\n              semantic_relations: analyze_semantic_relations(words),\n              word_forms: generate_word_forms(words),\n              concepts: extract_concepts(words),\n              sentiment_words: identify_sentiment_words(words),\n              complexity_metrics: calculate_linguistic_complexity(words)\n            }\n\n            # Cache the result\n            cache_result(cache_key, result, { text_length: text.length })\n\n            duration = Time.now - start_time\n            update_metrics(:linguistics_processing, duration, true)\n\n            result\n          rescue StandardError => e\n            duration = Time.now - start_time\n            update_metrics(:linguistics_processing, duration, false)\n\n            # Return basic analysis on error\n            {\n              morphology: [],\n              inflections: [],\n              semantic_relations: [],\n              word_forms: [],\n              concepts: [],\n              sentiment_words: [],\n              complexity_metrics: {},\n              error: e.message\n            }\n          end\n        end\n\n        # Analyze morphological features using Linguistics\n        def analyze_morphology(words)\n          morphology_data = []\n\n          words.each do |word|\n            next if word.length < 2\n\n            morph_info = {\n              word: word,\n              singular: word.en.singular,\n              plural: word.en.plural,\n              stem: extract_stem(word),\n              is_plural: word.en.plural?,\n              ordinal: word.en.ordinal,\n              cardinal: word.en.numwords\n            }\n\n            # Store in Red-Black tree for ordered morphological access\n            @cache[\"morph_#{word}\"] = morph_info\n            morphology_data << morph_info\n\n            # Add morphological variants to Trie\n            @trie_index[morph_info[:singular].downcase] = word if morph_info[:singular]\n            @trie_index[morph_info[:plural].downcase] = word if morph_info[:plural]\n          end\n\n          morphology_data\n        end\n\n        # Analyze inflectional patterns\n        def analyze_inflections(words)\n          inflections = []\n\n          words.each do |word|\n            next unless word.match?(/\\A[a-zA-Z]+\\z/) # Only alphabetic words\n\n            inflection_data = {\n              word: word,\n              past_tense: generate_past_tense(word),\n              present_participle: generate_present_participle(word),\n              comparative: word.en.comparative,\n              superlative: word.en.superlative,\n              indefinite_article: word.en.a\n            }\n\n            inflections << inflection_data\n\n            # Use priority queue to rank by inflectional complexity\n            complexity_score = calculate_inflection_complexity(inflection_data)\n            @priority_queue.push(inflection_data, complexity_score)\n          end\n\n          inflections\n        end\n\n        # Analyze semantic relationships using WordNet\n        def analyze_semantic_relations(words)\n          semantic_data = []\n\n          words.each do |word|\n            next if word.length < 3\n\n            begin\n              synsets = @wordnet.synsets(word)\n              next if synsets.empty?\n\n              primary_synset = synsets.first\n\n              relations = {\n                word: word,\n                definition: primary_synset.definition,\n                synonyms: extract_synonyms(synsets),\n                hypernyms: extract_hypernyms(primary_synset),\n                hyponyms: extract_hyponyms(primary_synset),\n                meronyms: extract_meronyms(primary_synset),\n                holonyms: extract_holonyms(primary_synset),\n                antonyms: extract_antonyms(synsets),\n                semantic_field: classify_semantic_field(primary_synset)\n              }\n\n              semantic_data << relations\n\n              # Build semantic similarity vectors for KD-tree\n              build_semantic_vectors(word, relations)\n            rescue StandardError\n              # Continue processing other words on error\n              next\n            end\n          end\n\n          semantic_data\n        end\n\n        # Generate various word forms using Linguistics\n        def generate_word_forms(words)\n          word_forms = {}\n\n          words.each do |word|\n            forms = {\n              base: word,\n              variations: {\n                capitalized: word.capitalize,\n                titlecase: word.en.titlecase,\n                camelcase: word.gsub(/[^a-zA-Z0-9]/, '').en.camelcase,\n                underscore: word.gsub(/\\s+/, '_').downcase,\n                hyphenated: word.gsub(/\\s+/, '-').downcase\n              },\n              linguistic_forms: {\n                singular: word.en.singular,\n                plural: word.en.plural,\n                possessive: \"#{word}'s\",\n                gerund: generate_gerund(word)\n              }\n            }\n\n            word_forms[word] = forms\n\n            # Add all forms to Trie for fast lookup\n            forms[:variations].each_value { |form| @trie_index[form.downcase] = word }\n            forms[:linguistic_forms].each_value do |form|\n              @trie_index[form.downcase] = word if form\n            end\n          end\n\n          word_forms\n        end\n\n        # Extract semantic concepts using WordNet\n        def extract_concepts(words)\n          concepts = []\n          concept_scores = {}\n\n          words.each do |word|\n            synsets = @wordnet.synsets(word)\n            synsets.each do |synset|\n              # Get semantic category\n              category = get_lexical_category(synset)\n\n              concept = {\n                word: word,\n                concept: synset.definition,\n                category: category,\n                hypernym_chain: build_hypernym_chain(synset),\n                specificity: calculate_specificity(synset)\n              }\n\n              # Score concept by specificity and frequency\n              score = concept[:specificity] * (1.0 / (synsets.length + 1))\n              concept_scores[concept] = score\n\n              concepts << concept\n            end\n          rescue StandardError\n            next\n          end\n\n          # Use priority queue to rank concepts\n          concept_scores.each { |concept, score| @priority_queue.push(concept, score) }\n\n          # Extract top concepts\n          top_concepts = []\n          while !@priority_queue.empty? && top_concepts.length < 15\n            top_concepts << @priority_queue.pop\n          end\n\n          top_concepts\n        end\n\n        # Identify sentiment-bearing words\n        def identify_sentiment_words(words)\n          sentiment_words = []\n\n          words.each do |word|\n            sentiment_info = analyze_word_sentiment(word)\n            sentiment_words << sentiment_info if sentiment_info[:sentiment] != 'neutral'\n          end\n\n          sentiment_words.sort_by { |sw| -sw[:intensity] }\n        end\n\n        # Calculate linguistic complexity metrics\n        def calculate_linguistic_complexity(words)\n          {\n            vocabulary_richness: calculate_vocabulary_richness(words),\n            avg_word_length: words.sum(&:length).to_f / words.length,\n            morphological_complexity: calculate_morphological_complexity(words),\n            semantic_density: calculate_semantic_density(words),\n            lexical_diversity: calculate_lexical_diversity(words)\n          }\n        end\n\n        private\n\n        def setup_linguistics\n          # Enable English language processing\n          Linguistics.use(:en) if LINGUISTICS_AVAILABLE\n        end\n\n        def fallback_processing(text)\n          words = basic_tokenize(text)\n          {\n            morphology: [],\n            inflections: [],\n            semantic_relations: [],\n            word_forms: {},\n            concepts: [],\n            sentiment_words: [],\n            complexity_metrics: {\n              vocabulary_richness: calculate_basic_richness(words),\n              avg_word_length: words.sum(&:length).to_f / words.length,\n              lexical_diversity: words.uniq.length.to_f / words.length\n            },\n            fallback: true\n          }\n        end\n\n        def basic_tokenize(text)\n          text.downcase.scan(/\\b\\w+\\b/).select { |word| word.length > 2 }\n        end\n\n        def calculate_basic_richness(words)\n          unique_words = words.uniq.length\n          total_words = words.length\n          return 0.0 if total_words.zero?\n\n          unique_words.to_f / total_words\n        end\n\n        def build_morphology_trie\n          # Pre-populate with common morphological patterns\n          morphological_patterns = {\n            'running' => 'run',\n            'better' => 'good',\n            'best' => 'good',\n            'children' => 'child',\n            'mice' => 'mouse'\n          }\n\n          morphological_patterns.each { |inflected, base| @trie_index[inflected] = base }\n        end\n\n        def tokenize_advanced(text)\n          # Enhanced tokenization preserving linguistic features\n          words = text.downcase.scan(/\\b[a-zA-Z]+\\b/)\n          words.select { |word| word.length > 2 }.uniq\n        end\n\n        def extract_stem(word)\n          # Simple stemming algorithm - can be enhanced with Porter stemmer\n          word.gsub(/ing$|ed$|s$|ly$/, '')\n        end\n\n        def generate_past_tense(word)\n          # Basic past tense generation\n          case word\n          when /[^aeiou]y$/\n            word.gsub(/y$/, 'ied')\n          when /e$/\n            \"#{word}d\"\n          when /[^aeiou][aeiou][^aeiou]$/\n            \"#{word}#{word[-1]}ed\"\n          else\n            \"#{word}ed\"\n          end\n        end\n\n        def generate_present_participle(word)\n          # Basic present participle generation\n          case word\n          when /e$/\n            word.gsub(/e$/, 'ing')\n          when /[^aeiou][aeiou][^aeiou]$/\n            \"#{word}#{word[-1]}ing\"\n          else\n            \"#{word}ing\"\n          end\n        end\n\n        def generate_gerund(word)\n          generate_present_participle(word)\n        end\n\n        def extract_synonyms(synsets)\n          synonyms = []\n          synsets.each do |synset|\n            synset.words.each { |word| synonyms << word.lemma }\n          end\n          synonyms.uniq\n        end\n\n        def extract_hypernyms(synset)\n          synset.hypernyms.map(&:words).flatten.map(&:lemma)\n        end\n\n        def extract_hyponyms(synset)\n          synset.hyponyms.map(&:words).flatten.map(&:lemma)\n        end\n\n        def extract_meronyms(synset)\n          (synset.part_meronyms + synset.member_meronyms + synset.substance_meronyms)\n            .map(&:words).flatten.map(&:lemma)\n        end\n\n        def extract_holonyms(synset)\n          (synset.part_holonyms + synset.member_holonyms + synset.substance_holonyms)\n            .map(&:words).flatten.map(&:lemma)\n        end\n\n        def extract_antonyms(synsets)\n          antonyms = []\n          synsets.each do |synset|\n            synset.words.each do |word|\n              word.antonyms.each { |ant| antonyms << ant.lemma }\n            end\n          end\n          antonyms.uniq\n        end\n\n        def classify_semantic_field(synset)\n          # Basic semantic field classification\n          lexfile = synset.lexical_file_name\n          case lexfile\n          when /noun\\.person/\n            'person'\n          when /noun\\.animal/\n            'animal'\n          when /noun\\.plant/\n            'plant'\n          when /noun\\.object/\n            'object'\n          when /verb\\.motion/\n            'motion'\n          when /adj\\.all/\n            'quality'\n          else\n            'general'\n          end\n        end\n\n        def build_semantic_vectors(word, relations)\n          # Simple semantic vector based on relationship counts\n          vector = [\n            relations[:synonyms].length,\n            relations[:hypernyms].length,\n            relations[:hyponyms].length,\n            relations[:meronyms].length\n          ]\n\n          @kd_tree_data[word] = vector if vector.any?(&:positive?)\n        end\n\n        def get_lexical_category(synset)\n          synset.pos\n        end\n\n        def build_hypernym_chain(synset, max_depth: 5)\n          chain = []\n          current = synset\n          depth = 0\n\n          while current.hypernyms.any? && depth < max_depth\n            hypernym = current.hypernyms.first\n            chain << hypernym.words.first.lemma\n            current = hypernym\n            depth += 1\n          end\n\n          chain\n        end\n\n        def calculate_specificity(synset)\n          # Higher specificity = more hyponyms, fewer hypernyms\n          hyponym_count = synset.hyponyms.length\n          hypernym_count = synset.hypernyms.length\n\n          return 0.5 if (hyponym_count + hypernym_count).zero?\n\n          hyponym_count.to_f / (hyponym_count + hypernym_count + 1)\n        end\n\n        def analyze_word_sentiment(word)\n          # Basic sentiment analysis using WordNet\n\n          synsets = @wordnet.synsets(word)\n          return { word: word, sentiment: 'neutral', intensity: 0.0 } if synsets.empty?\n\n          # Simple sentiment scoring based on definition keywords\n          definition = synsets.first.definition.downcase\n\n          positive_indicators = %w[good great excellent positive beneficial\n            pleasant]\n          negative_indicators = %w[bad terrible negative harmful unpleasant\n            difficult]\n\n          pos_score = positive_indicators.count { |ind| definition.include?(ind) }\n          neg_score = negative_indicators.count { |ind| definition.include?(ind) }\n\n          if pos_score > neg_score\n            { word: word, sentiment: 'positive', intensity: pos_score.to_f / 6.0 }\n          elsif neg_score > pos_score\n            { word: word, sentiment: 'negative', intensity: neg_score.to_f / 6.0 }\n          else\n            { word: word, sentiment: 'neutral', intensity: 0.0 }\n          end\n        rescue StandardError\n          { word: word, sentiment: 'neutral', intensity: 0.0 }\n        end\n\n        def calculate_inflection_complexity(inflection_data)\n          complexity = 0.0\n\n          complexity += 0.2 if inflection_data[:past_tense] != inflection_data[:word]\n          complexity += 0.2 if inflection_data[:comparative]\n          complexity += 0.2 if inflection_data[:superlative]\n          complexity += 0.1 if inflection_data[:present_participle]\n\n          complexity\n        end\n\n        def calculate_vocabulary_richness(words)\n          # Type-token ratio\n          unique_words = words.uniq.length\n          total_words = words.length\n          return 0.0 if total_words.zero?\n\n          unique_words.to_f / total_words\n        end\n\n        def calculate_morphological_complexity(words)\n          # Average morphological operations per word\n          total_operations = words.sum do |word|\n            operations = 0\n            operations += 1 if word.en.plural?\n            operations += 1 if word != word.en.singular\n            operations\n          end\n\n          total_operations.to_f / words.length\n        end\n\n        def calculate_semantic_density(words)\n          # Proportion of words with rich semantic relationships\n          words_with_semantics = words.count do |word|\n            synsets = @wordnet.synsets(word)\n            synsets.any? && synsets.first.hypernyms.any?\n          rescue StandardError\n            false\n          end\n\n          words_with_semantics.to_f / words.length\n        end\n\n        def calculate_lexical_diversity(words)\n          # Measure of lexical variation\n          word_frequencies = words.tally\n          max_frequency = word_frequencies.values.max\n          return 0.0 if max_frequency.zero?\n\n          1.0 - (max_frequency.to_f / words.length)\n        end\n\n        def generate_cache_key(text)\n          \"linguistics_#{Digest::MD5.hexdigest(text[0..100])}\"\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/nlp/processors/"
    },
    {
      "filename": "spacy_processor.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'base_processor'\n\nbegin\n  require 'ruby-spacy'\n  SPACY_AVAILABLE = true\nrescue LoadError\n  SPACY_AVAILABLE = false\n  puts 'Warning: ruby-spacy gem not available. SpaCy processor will be disabled.'\nend\n\nmodule BlueprintsCLI\n  module NLP\n    module Processors\n      # SpaCy-powered NLP processor for advanced linguistic analysis\n      # Provides POS tagging, NER, dependency parsing, and sentence segmentation\n      class SpacyProcessor < BaseProcessor\n        attr_reader :nlp_model, :model_name\n\n        def initialize(model_name: 'en_core_web_sm')\n          super()\n          @model_name = model_name\n\n          if SPACY_AVAILABLE\n            @nlp_model = load_spacy_model\n            build_linguistic_trie\n          else\n            @nlp_model = nil\n            puts 'SpaCy processor initialized in fallback mode'\n          end\n        end\n\n        # Main processing method using SpaCy pipeline\n        def process(text)\n          start_time = Time.now\n\n          begin\n            # Check cache first\n            cache_key = generate_cache_key(text)\n            if (cached_result = get_cached_result(cache_key))\n              return cached_result\n            end\n\n            # Return fallback if SpaCy not available\n            return fallback_processing(text) unless SPACY_AVAILABLE && @nlp_model\n\n            # Process with SpaCy\n            doc = @nlp_model.call(text)\n\n            result = {\n              tokens: extract_tokens(doc),\n              entities: extract_entities(doc),\n              pos_tags: extract_pos_tags(doc),\n              dependencies: extract_dependencies(doc),\n              sentences: extract_sentences(doc),\n              noun_phrases: extract_noun_phrases(doc),\n              keywords: extract_spacy_keywords(doc)\n            }\n\n            # Cache the result\n            cache_result(cache_key, result, { model: @model_name, text_length: text.length })\n\n            duration = Time.now - start_time\n            update_metrics(:spacy_processing, duration, true)\n\n            result\n          rescue StandardError => e\n            duration = Time.now - start_time\n            update_metrics(:spacy_processing, duration, false)\n\n            # Return basic analysis on error\n            {\n              tokens: tokenize(text),\n              entities: [],\n              pos_tags: [],\n              dependencies: [],\n              sentences: [text],\n              noun_phrases: [],\n              keywords: [],\n              error: e.message\n            }\n          end\n        end\n\n        # Extract named entities with confidence scores\n        def extract_entities(doc)\n          entities = []\n\n          doc.ents.each do |entity|\n            entity_data = {\n              text: entity.text,\n              label: entity.label_,\n              start: entity.start_char,\n              end: entity.end_char,\n              confidence: entity._.get('confidence') || 0.8 # Default confidence\n            }\n\n            # Add to priority queue for ranking\n            @priority_queue.push(entity_data, entity_data[:confidence])\n            entities << entity_data\n\n            # Index in Trie for fast lookup\n            @trie_index[entity.text.downcase] = entity.label_\n          end\n\n          entities.sort_by { |e| -e[:confidence] }\n        end\n\n        # Extract POS tags with linguistic features\n        def extract_pos_tags(doc)\n          pos_data = []\n\n          doc.each do |token|\n            next if token.is_space || token.is_punct\n\n            pos_info = {\n              text: token.text,\n              lemma: token.lemma_,\n              pos: token.pos_,\n              tag: token.tag_,\n              is_alpha: token.is_alpha,\n              is_stop: token.is_stop,\n              shape: token.shape_,\n              dependency: token.dep_\n            }\n\n            pos_data << pos_info\n\n            # Store in Red-Black tree for ordered access by position\n            @cache[\"pos_#{token.i}\"] = pos_info\n          end\n\n          pos_data\n        end\n\n        # Extract syntactic dependencies\n        def extract_dependencies(doc)\n          dependencies = []\n\n          doc.each do |token|\n            next if token.head == token # Skip root\n\n            dep_info = {\n              token: token.text,\n              head: token.head.text,\n              relation: token.dep_,\n              children: token.children.map(&:text)\n            }\n\n            dependencies << dep_info\n          end\n\n          dependencies\n        end\n\n        # Extract noun phrases for concept identification\n        def extract_noun_phrases(doc)\n          noun_phrases = []\n\n          doc.noun_chunks.each do |chunk|\n            phrase_info = {\n              text: chunk.text,\n              root: chunk.root.text,\n              root_pos: chunk.root.pos_,\n              start: chunk.start,\n              end: chunk.end\n            }\n\n            noun_phrases << phrase_info\n\n            # Add to Trie for phrase lookup\n            @trie_index[chunk.text.downcase] = chunk.root.text\n          end\n\n          noun_phrases\n        end\n\n        # Extract keywords using SpaCy's linguistic features\n        def extract_spacy_keywords(doc)\n          keywords = []\n\n          # Score tokens based on linguistic features\n          doc.each do |token|\n            next if token.is_stop || token.is_punct || token.is_space\n            next if token.text.length < 3\n\n            score = calculate_spacy_score(token)\n\n            next unless score > 0.3 # Threshold for keyword inclusion\n\n            keyword = {\n              text: token.text,\n              lemma: token.lemma_,\n              pos: token.pos_,\n              score: score\n            }\n\n            keywords << keyword\n            @priority_queue.push(keyword, score)\n          end\n\n          # Return top keywords using priority queue\n          top_keywords = []\n          while !@priority_queue.empty? && top_keywords.length < 20\n            top_keywords << @priority_queue.pop\n          end\n\n          top_keywords\n        end\n\n        # Analyze text structure and complexity\n        def analyze_text_structure(text)\n          doc = @nlp_model.call(text)\n\n          {\n            sentence_count: doc.sents.count,\n            token_count: doc.length,\n            avg_sentence_length: doc.length.to_f / doc.sents.count,\n            complexity_score: calculate_complexity_score(doc),\n            readability: estimate_readability(doc)\n          }\n        end\n\n        private\n\n        def load_spacy_model\n          return nil unless SPACY_AVAILABLE\n\n          begin\n            Spacy::Language.new(@model_name)\n          rescue StandardError\n            # Fallback to basic English model\n            puts \"Warning: Could not load #{@model_name}, falling back to basic model\"\n            begin\n              Spacy::Language.new('en_core_web_sm')\n            rescue StandardError => e2\n              puts \"Warning: Could not load any SpaCy model: #{e2.message}\"\n              nil\n            end\n          end\n        end\n\n        def fallback_processing(text)\n          {\n            tokens: basic_tokenize(text),\n            entities: [],\n            pos_tags: [],\n            dependencies: [],\n            sentences: [text],\n            noun_phrases: [],\n            keywords: extract_basic_keywords(text),\n            fallback: true\n          }\n        end\n\n        def basic_tokenize(text)\n          text.split(/\\s+/).map do |word|\n            {\n              text: word,\n              lemma: word.downcase,\n              pos: 'UNKNOWN',\n              is_alpha: word.match?(/\\A[a-zA-Z]+\\z/),\n              is_stop: false\n            }\n          end\n        end\n\n        def extract_basic_keywords(text)\n          words = text.downcase.scan(/\\b\\w+\\b/)\n          word_freq = words.tally\n\n          # Simple keyword extraction based on frequency and length\n          word_freq.select { |word, freq| word.length > 3 && freq.positive? }\n                   .map do |word, freq|\n            { text: word, lemma: word, pos: 'UNKNOWN',\n              score: freq.to_f / words.length }\n          end\n                   .sort_by { |kw| -kw[:score] }\n                   .first(10)\n        end\n\n        def build_linguistic_trie\n          # Pre-populate Trie with common linguistic patterns\n          common_patterns = {\n            'artificial intelligence' => 'AI_CONCEPT',\n            'machine learning' => 'ML_CONCEPT',\n            'natural language processing' => 'NLP_CONCEPT',\n            'deep learning' => 'DL_CONCEPT',\n            'neural network' => 'NN_CONCEPT'\n          }\n\n          common_patterns.each { |pattern, label| @trie_index[pattern] = label }\n        end\n\n        def extract_tokens(doc)\n          tokens = []\n\n          doc.each do |token|\n            next if token.is_space\n\n            tokens << {\n              text: token.text,\n              lemma: token.lemma_,\n              pos: token.pos_,\n              is_alpha: token.is_alpha,\n              is_stop: token.is_stop\n            }\n          end\n\n          tokens\n        end\n\n        def extract_sentences(doc)\n          doc.sents.map(&:text)\n        end\n\n        def calculate_spacy_score(token)\n          score = 0.0\n\n          # Base score from token properties\n          score += 0.3 if token.is_alpha\n          score += 0.2 if token.pos_ == 'NOUN'\n          score += 0.15 if token.pos_ == 'VERB'\n          score += 0.1 if token.pos_ == 'ADJ'\n          score += 0.4 if token.ent_type_ != '' # Is part of named entity\n          score -= 0.2 if token.is_stop\n\n          # Length bonus\n          score += [token.text.length.to_f / 10.0, 0.3].min\n\n          # Frequency penalty (more common = lower score)\n          score -= token.prob * 0.1 if token.prob\n\n          score.clamp(0.0, 1.0)\n        end\n\n        def calculate_complexity_score(doc)\n          # Simple complexity based on sentence structure\n          avg_deps_per_token = doc.sum { |token| token.children.count }.to_f / doc.length\n          avg_deps_per_token / 3.0 # Normalize\n        end\n\n        def estimate_readability(doc)\n          # Simple readability estimate\n          avg_word_length = doc.select(&:is_alpha).sum { |t| t.text.length }.to_f /\n                            doc.count(&:is_alpha)\n\n          case avg_word_length\n          when 0..4 then 'easy'\n          when 4..6 then 'medium'\n          else 'hard'\n          end\n        end\n\n        def generate_cache_key(text)\n          \"spacy_#{@model_name}_#{Digest::MD5.hexdigest(text[0..100])}\"\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/nlp/processors/"
    },
    {
      "filename": "embedding_provider.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Providers\n    # Abstract base class for embedding providers\n    #\n    # This class defines the interface that all embedding providers must implement.\n    # It supports different providers (Informers, RubyLLM, etc.) with a unified API.\n    #\n    # @example Basic usage\n    #   provider = EmbeddingProvider.create(:informers)\n    #   embedding = provider.embed(\"sample text\")\n    #\n    # @example With options\n    #   embedding = provider.embed(\"code snippet\", normalize: true, model: \"custom-model\")\n    #\n    class EmbeddingProvider\n      # Registry of available providers\n      @providers = {}\n\n      # Error raised when a provider is not found\n      ProviderNotFoundError = Class.new(StandardError)\n\n      # Error raised when embedding generation fails\n      EmbeddingError = Class.new(StandardError)\n\n      class << self\n        # Register a provider class\n        #\n        # @param name [Symbol] Provider name\n        # @param provider_class [Class] Provider class\n        def register(name, provider_class)\n          @providers[name.to_sym] = provider_class\n        end\n\n        # Create a provider instance\n        #\n        # @param name [Symbol] Provider name\n        # @param options [Hash] Provider-specific options\n        # @return [EmbeddingProvider] Provider instance\n        # @raise [ProviderNotFoundError] If provider is not registered\n        def create(name, **options)\n          provider_class = @providers[name.to_sym]\n          raise ProviderNotFoundError, \"Unknown provider: #{name}\" unless provider_class\n\n          provider_class.new(**options)\n        end\n\n        # List available providers\n        #\n        # @return [Array<Symbol>] Available provider names\n        def available_providers\n          @providers.keys\n        end\n\n        # Check if provider is available\n        #\n        # @param name [Symbol] Provider name\n        # @return [Boolean] True if provider is registered\n        def provider_available?(name)\n          @providers.key?(name.to_sym)\n        end\n      end\n\n      # Initialize the provider\n      #\n      # @param options [Hash] Provider-specific configuration options\n      def initialize(**options)\n        @options = options\n        @cache = {}\n        @stats = { embeddings_generated: 0, cache_hits: 0 }\n\n        configure if respond_to?(:configure, true)\n      end\n\n      # Generate embeddings for given text\n      #\n      # This is the main interface method that must be implemented by subclasses.\n      #\n      # @param text [String] Text to embed\n      # @param options [Hash] Generation options\n      # @option options [Boolean] :normalize Whether to normalize the embedding vector\n      # @option options [String] :model Model name to use for embedding\n      # @option options [Boolean] :cache Whether to use caching (default: true)\n      # @return [Array<Float>] Embedding vector\n      # @raise [NotImplementedError] If not implemented by subclass\n      def embed(text, **options)\n        raise NotImplementedError, \"#{self.class.name} must implement #embed\"\n      end\n\n      # Generate embeddings for multiple texts (batch processing)\n      #\n      # Default implementation calls embed for each text individually.\n      # Subclasses can override for more efficient batch processing.\n      #\n      # @param texts [Array<String>] Array of texts to embed\n      # @param options [Hash] Generation options\n      # @return [Array<Array<Float>>] Array of embedding vectors\n      def embed_batch(texts, **options)\n        texts.map { |text| embed(text, **options) }\n      end\n\n      # Get embedding dimensions for this provider\n      #\n      # @return [Integer] Number of dimensions in embedding vectors\n      # @raise [NotImplementedError] If not implemented by subclass\n      def dimensions\n        raise NotImplementedError, \"#{self.class.name} must implement #dimensions\"\n      end\n\n      # Check if provider is ready/healthy\n      #\n      # @return [Boolean] True if provider is operational\n      def healthy?\n        true\n      end\n\n      # Get provider statistics\n      #\n      # @return [Hash] Statistics about provider usage\n      def stats\n        @stats.dup\n      end\n\n      # Clear embedding cache\n      #\n      # @return [Integer] Number of cache entries cleared\n      def clear_cache\n        cleared = @cache.size\n        @cache.clear\n        cleared\n      end\n\n      # Get cache statistics\n      #\n      # @return [Hash] Cache usage statistics\n      def cache_stats\n        {\n          size: @cache.size,\n          hit_rate: @stats[:cache_hits].to_f / [@stats[:embeddings_generated], 1].max\n        }\n      end\n\n      protected\n\n      # Get cached embedding or generate new one\n      #\n      # @param cache_key [String] Cache key\n      # @param options [Hash] Generation options\n      # @yield Block that generates the embedding\n      # @return [Array<Float>] Embedding vector\n      def with_cache(cache_key, **options)\n        use_cache = options.fetch(:cache, true)\n\n        if use_cache && @cache.key?(cache_key)\n          @stats[:cache_hits] += 1\n          BlueprintsCLI.logger.debug(\"Cache hit for embedding: #{cache_key[0..50]}...\")\n          return @cache[cache_key]\n        end\n\n        embedding = yield\n\n        @cache[cache_key] = embedding if use_cache\n        @stats[:embeddings_generated] += 1\n\n        embedding\n      end\n\n      # Generate cache key for text and options\n      #\n      # @param text [String] Input text\n      # @param options [Hash] Generation options\n      # @return [String] Cache key\n      def cache_key(text, **options)\n        # Include relevant options in cache key\n        key_options = options.slice(:model, :normalize)\n        \"#{text.hash}_#{key_options.hash}\"\n      end\n\n      # Log provider activity\n      #\n      # @param message [String] Log message\n      # @param level [Symbol] Log level\n      def log(message, level: :debug)\n        BlueprintsCLI.logger.send(level, \"[#{self.class.name}] #{message}\")\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/providers/"
    },
    {
      "filename": "informers_provider.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'informers'\nrequire_relative 'embedding_provider'\n\nmodule BlueprintsCLI\n  module Providers\n    # Informers-based embedding provider\n    #\n    # This provider uses the Informers gem for local embedding generation.\n    # It supports sentence transformers and feature extraction models.\n    #\n    # @example Basic usage\n    #   provider = InformersProvider.new\n    #   embedding = provider.embed(\"sample code\")\n    #\n    # @example With custom model\n    #   provider = InformersProvider.new(model: \"sentence-transformers/all-MiniLM-L6-v2\")\n    #   embedding = provider.embed(\"sample code\")\n    #\n    class InformersProvider < EmbeddingProvider\n      # Default model for embeddings\n      DEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'\n\n      # Default embedding dimensions for common models\n      MODEL_DIMENSIONS = {\n        'sentence-transformers/all-MiniLM-L6-v2' => 384,\n        'sentence-transformers/all-MiniLM-L12-v2' => 384,\n        'sentence-transformers/all-mpnet-base-v2' => 768,\n        'sentence-transformers/multi-qa-MiniLM-L6-cos-v1' => 384,\n        'thenlper/gte-small' => 384,\n        'thenlper/gte-base' => 768\n      }.freeze\n\n      # Initialize the Informers provider\n      #\n      # @param model [String] Model name to use for embeddings\n      # @param device [String] Device to run on ('cpu', 'cuda', etc.)\n      # @param quantized [Boolean] Whether to use quantized models\n      # @param max_length [Integer] Maximum input length\n      # @param options [Hash] Additional options\n      def initialize(model: DEFAULT_MODEL, device: 'cpu', quantized: true, max_length: 512,\n                     **options)\n        @model_name = model\n        @device = device\n        @quantized = quantized\n        @max_length = max_length\n        @pipeline = nil\n        @model_dimensions = nil\n\n        super(**options)\n\n        log(\"Initialized Informers provider with model: #{@model_name}\", level: :info)\n      end\n\n      # Generate embedding for given text\n      #\n      # @param text [String] Text to embed\n      # @param options [Hash] Generation options\n      # @option options [Boolean] :normalize Whether to normalize the embedding\n      # @option options [String] :model Override model for this request\n      # @option options [Boolean] :cache Whether to use caching\n      # @return [Array<Float>] Embedding vector\n      # @raise [EmbeddingError] If embedding generation fails\n      def embed(text, **options)\n        return [] if text.nil? || text.strip.empty?\n\n        # Truncate text if too long\n        processed_text = truncate_text(text, @max_length)\n        cache_key_str = cache_key(processed_text, **options)\n\n        with_cache(cache_key_str, **options) do\n          ensure_pipeline_loaded\n\n          # Generate embedding using Informers pipeline\n          result = @pipeline.call(processed_text)\n          embedding = extract_embedding(result)\n\n          # Normalize if requested\n          embedding = normalize_vector(embedding) if options[:normalize]\n\n          log(\"Generated embedding for text (#{processed_text.length} chars): #{embedding.size} dimensions\")\n          embedding\n        rescue StandardError => e\n          error_msg = \"Failed to generate embedding: #{e.message}\"\n          log(error_msg, level: :error)\n          raise EmbeddingError, error_msg\n        end\n      end\n\n      # Generate embeddings for multiple texts\n      #\n      # @param texts [Array<String>] Array of texts to embed\n      # @param options [Hash] Generation options\n      # @return [Array<Array<Float>>] Array of embedding vectors\n      def embed_batch(texts, **options)\n        return [] if texts.nil? || texts.empty?\n\n        begin\n          ensure_pipeline_loaded\n\n          # Process all texts in batch for efficiency\n          processed_texts = texts.map { |text| truncate_text(text, @max_length) }\n\n          # For single text, wrap in array; for multiple, pass as-is\n          input = processed_texts.length == 1 ? processed_texts.first : processed_texts\n\n          result = @pipeline.call(input)\n          embeddings = extract_batch_embeddings(result, processed_texts.length)\n\n          # Normalize if requested\n          embeddings = embeddings.map { |emb| normalize_vector(emb) } if options[:normalize]\n\n          @stats[:embeddings_generated] += processed_texts.length\n          log(\"Generated batch embeddings for #{processed_texts.length} texts\")\n\n          embeddings\n        rescue StandardError => e\n          error_msg = \"Failed to generate batch embeddings: #{e.message}\"\n          log(error_msg, level: :error)\n          raise EmbeddingError, error_msg\n        end\n      end\n\n      # Get embedding dimensions for current model\n      #\n      # @return [Integer] Number of dimensions\n      def dimensions\n        @dimensions ||= begin\n          # Try to get from known models first\n          known_dims = MODEL_DIMENSIONS[@model_name]\n          return known_dims if known_dims\n\n          # If unknown model, generate a test embedding to determine dimensions\n          begin\n            ensure_pipeline_loaded\n            test_embedding = embed('test', cache: false)\n            test_embedding.length\n          rescue StandardError => e\n            log(\"Could not determine dimensions for model #{@model_name}: #{e.message}\",\n                level: :warn)\n            384 # Default fallback\n          end\n        end\n      end\n\n      # Check if provider is ready\n      #\n      # @return [Boolean] True if Informers pipeline is loaded successfully\n      def healthy?\n        ensure_pipeline_loaded\n        true\n      rescue StandardError => e\n        log(\"Health check failed: #{e.message}\", level: :error)\n        false\n      end\n\n      # Get provider info\n      #\n      # @return [Hash] Provider information\n      def info\n        {\n          name: 'Informers',\n          model: @model_name,\n          device: @device,\n          quantized: @quantized,\n          dimensions: dimensions,\n          max_length: @max_length,\n          pipeline_loaded: !@pipeline.nil?\n        }\n      end\n\n      private\n\n      # Ensure the Informers pipeline is loaded\n      def ensure_pipeline_loaded\n        return if @pipeline\n\n        log(\"Loading Informers pipeline: #{@model_name}\")\n\n        begin\n          @pipeline = Informers.pipeline(\n            'embedding',\n            @model_name,\n            quantized: @quantized,\n            device: @device\n          )\n\n          log('Successfully loaded Informers pipeline', level: :info)\n        rescue StandardError => e\n          error_msg = \"Failed to load Informers pipeline: #{e.message}\"\n          log(error_msg, level: :error)\n          raise EmbeddingError, error_msg\n        end\n      end\n\n      # Extract embedding from pipeline result\n      #\n      # @param result [Object] Pipeline result\n      # @return [Array<Float>] Embedding vector\n      def extract_embedding(result)\n        case result\n        when Array\n          # If array of arrays, take the first one\n          result.first.is_a?(Array) ? result.first : result\n        when Hash\n          # Look for common embedding keys\n          result[:embedding] || result['embedding'] ||\n            result[:sentence_embedding] || result['sentence_embedding'] ||\n            result[:pooler_output] || result['pooler_output'] ||\n            (raise EmbeddingError, \"Could not extract embedding from result: #{result.keys}\")\n        else\n          # Assume it's the embedding directly\n          result.to_a\n        end\n      end\n\n      # Extract embeddings from batch result\n      #\n      # @param result [Object] Pipeline batch result\n      # @param expected_count [Integer] Expected number of embeddings\n      # @return [Array<Array<Float>>] Array of embedding vectors\n      def extract_batch_embeddings(result, _expected_count)\n        case result\n        when Array\n          # Check if it's a nested array (batch of embeddings)\n          if result.first.is_a?(Array)\n            result\n          else\n            # Single embedding, wrap in array\n            [result]\n          end\n        else\n          # Single result, extract and wrap\n          [extract_embedding(result)]\n        end\n      end\n\n      # Truncate text to maximum length\n      #\n      # @param text [String] Input text\n      # @param max_length [Integer] Maximum length\n      # @return [String] Truncated text\n      def truncate_text(text, max_length)\n        return text if text.length <= max_length\n\n        # Try to truncate at word boundaries\n        words = text.split\n        truncated = ''\n\n        words.each do |word|\n          break unless \"#{truncated} #{word}\".length <= max_length\n\n          truncated += (truncated.empty? ? '' : ' ') + word\n        end\n\n        # If we couldn't fit any words, just slice the text\n        truncated = text[0, max_length] if truncated.empty?\n\n        if text.length != truncated.length\n          log(\"Truncated text from #{text.length} to #{truncated.length} characters\")\n        end\n        truncated\n      end\n\n      # Normalize embedding vector to unit length\n      #\n      # @param vector [Array<Float>] Input vector\n      # @return [Array<Float>] Normalized vector\n      def normalize_vector(vector)\n        magnitude = Math.sqrt(vector.sum { |x| x * x })\n        return vector if magnitude.zero?\n\n        vector.map { |x| x / magnitude }\n      end\n\n      # Configure the provider (called during initialization)\n      def configure\n        log('Configuring Informers provider')\n\n        # Set device if CUDA is requested but not available\n        return unless @device == 'cuda'\n\n        log('CUDA device requested - ensure ONNX CUDA providers are available', level: :warn)\n      end\n    end\n\n    # Register the Informers provider\n    EmbeddingProvider.register(:informers, InformersProvider)\n  end\nend\n",
      "path": "/lib/blueprintsCLI/providers/"
    },
    {
      "filename": "ruby_llm_provider.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\nrequire_relative 'embedding_provider'\n\nmodule BlueprintsCLI\n  module Providers\n    # RubyLLM-based embedding provider\n    #\n    # This provider uses the RubyLLM gem for cloud-based embedding generation.\n    # It supports multiple cloud providers (OpenAI, Google, Anthropic, etc.).\n    #\n    # @example Basic usage\n    #   provider = RubyLLMProvider.new\n    #   embedding = provider.embed(\"sample code\")\n    #\n    # @example With custom configuration\n    #   provider = RubyLLMProvider.new(\n    #     provider: :openai,\n    #     model: 'text-embedding-3-small'\n    #   )\n    #   embedding = provider.embed(\"sample code\")\n    #\n    class RubyLLMProvider < EmbeddingProvider\n      # Default embedding dimensions for common models\n      MODEL_DIMENSIONS = {\n        'text-embedding-004' => 768, # Google\n        'text-embedding-3-small' => 1536,     # OpenAI\n        'text-embedding-3-large' => 3072,     # OpenAI\n        'text-embedding-ada-002' => 1536      # OpenAI (legacy)\n      }.freeze\n\n      # Initialize the RubyLLM provider\n      #\n      # @param provider [Symbol] Cloud provider (:openai, :google, :anthropic, etc.)\n      # @param model [String] Model name for embeddings\n      # @param dimensions [Integer] Override embedding dimensions\n      # @param options [Hash] Additional options\n      def initialize(provider: nil, model: nil, dimensions: nil, **options)\n        @provider = provider\n        @model = model\n        @custom_dimensions = dimensions\n        @last_error = nil\n\n        super(**options)\n\n        log(\"Initialized RubyLLM provider#{\" with #{@provider}\" if @provider}\", level: :info)\n      end\n\n      # Generate embedding for given text\n      #\n      # @param text [String] Text to embed\n      # @param options [Hash] Generation options\n      # @option options [String] :model Override model for this request\n      # @option options [Boolean] :cache Whether to use caching\n      # @return [Array<Float>] Embedding vector\n      # @raise [EmbeddingError] If embedding generation fails\n      def embed(text, **options)\n        return [] if text.nil? || text.strip.empty?\n\n        cache_key_str = cache_key(text, **options)\n\n        with_cache(cache_key_str, **options) do\n          # Use model override if provided\n          embed_options = {}\n          embed_options[:model] = options[:model] if options[:model]\n\n          result = RubyLLM.embed(text, **embed_options)\n\n          # Extract the vector array from RubyLLM result\n          embedding = result.vectors\n\n          log(\"Generated embedding via RubyLLM: #{embedding.size} dimensions\")\n          @last_error = nil\n\n          embedding\n        rescue StandardError => e\n          @last_error = e\n          error_msg = \"RubyLLM embedding failed: #{e.message}\"\n          log(error_msg, level: :error)\n          raise EmbeddingError, error_msg\n        end\n      end\n\n      # Generate embeddings for multiple texts\n      #\n      # @param texts [Array<String>] Array of texts to embed\n      # @param options [Hash] Generation options\n      # @return [Array<Array<Float>>] Array of embedding vectors\n      def embed_batch(texts, **options)\n        return [] if texts.nil? || texts.empty?\n\n        begin\n          # RubyLLM doesn't have native batch support, so we process individually\n          # This could be optimized in the future if RubyLLM adds batch support\n          embeddings = texts.map { |text| embed(text, **options) }\n\n          log(\"Generated batch embeddings via RubyLLM for #{texts.length} texts\")\n          embeddings\n        rescue StandardError => e\n          @last_error = e\n          error_msg = \"RubyLLM batch embedding failed: #{e.message}\"\n          log(error_msg, level: :error)\n          raise EmbeddingError, error_msg\n        end\n      end\n\n      # Get embedding dimensions for current model\n      #\n      # @return [Integer] Number of dimensions\n      def dimensions\n        return @custom_dimensions if @custom_dimensions\n\n        # Try to determine from model name\n        return MODEL_DIMENSIONS[@model] if @model && MODEL_DIMENSIONS[@model]\n\n        # Try to get from RubyLLM configuration\n        begin\n          # Generate a test embedding to determine dimensions\n          test_embedding = embed('test', cache: false)\n          test_embedding.length\n        rescue StandardError => e\n          log(\"Could not determine dimensions: #{e.message}\", level: :warn)\n          768 # Default fallback\n        end\n      end\n\n      # Check if provider is ready\n      #\n      # @return [Boolean] True if RubyLLM is properly configured\n      def healthy?\n        # Try a minimal embedding to test configuration\n        embed('health check', cache: false)\n        @last_error = nil\n        true\n      rescue StandardError => e\n        @last_error = e\n        log(\"Health check failed: #{e.message}\", level: :error)\n        false\n      end\n\n      # Get provider info\n      #\n      # @return [Hash] Provider information\n      def info\n        {\n          name: 'RubyLLM',\n          provider: @provider,\n          model: @model,\n          dimensions: dimensions,\n          last_error: @last_error&.message,\n          healthy: healthy?\n        }\n      end\n\n      # Get last error for debugging\n      #\n      # @return [Exception, nil] Last error encountered\n      attr_reader :last_error\n\n      private\n\n      # Configure the provider (called during initialization)\n      def configure\n        log('Configuring RubyLLM provider')\n\n        # Check if RubyLLM is properly configured\n        begin\n          # Verify that at least one API key is available\n          config = BlueprintsCLI.configuration\n          has_key = %i[openai anthropic gemini deepseek].any? do |provider|\n            config.ai_api_key(provider)\n          end\n\n          log('Warning: No API keys found for RubyLLM providers', level: :warn) unless has_key\n        rescue StandardError => e\n          log(\"Configuration check failed: #{e.message}\", level: :warn)\n        end\n      end\n    end\n\n    # Register the RubyLLM provider\n    EmbeddingProvider.register(:ruby_llm, RubyLLMProvider)\n  end\nend\n",
      "path": "/lib/blueprintsCLI/providers/"
    },
    {
      "filename": "ollama.rb",
      "content": "# frozen_string_literal: true\n\nmodule Sublayer\n  module Providers\n    class Ollama\n      ##\n      # Makes a POST request to an Ollama API endpoint to process a prompt and returns the adapted response.\n      #\n      # This method sends a user prompt to a specified model hosted at a given endpoint,\n      # processes the response through an output adapter, and returns the adapted result.\n      # It's designed to work with Ollama-compatible APIs that support function calling.\n      #\n      # @param host [String] The base URL of the API endpoint to send the request to\n      # @param model [String] The identifier of the model to use for processing the prompt\n      # @param prompt [String] The user input or question to be processed by the model\n      # @param output_adapter [Object] An adapter object that must respond to:\n      #   - +format_properties+: Returns properties hash for the response format\n      #   - +format_required+: Returns array of required fields\n      #   - +name+: Returns the name of the expected response field\n      #\n      # @return [Object] The adapted response from the API, specifically the value\n      #   associated with the output_adapter's name in the function call arguments\n      #\n      # @raise [RuntimeError] If no function is called in the API response (message doesn't contain tool_calls)\n      #\n      # @example Basic usage with a JSON output adapter\n      #   class JsonAdapter\n      #     def self.format_properties\n      #       { data: { type: \"object\" } }\n      #     end\n      #\n      #     def self.format_required\n      #       [\"data\"]\n      #     end\n      #\n      #     def self.name\n      #       \"json_response\"\n      #     end\n      #   end\n      #\n      #   response = Sublayer::Providers::Ollama.call(\n      #     host: \"https://api.ollama.example.com\",\n      #     model: \"text-model-001\",\n      #     prompt: \"Explain Ruby modules\",\n      #     output_adapter: JsonAdapter\n      #   )\n      #\n      # @example Handling the response\n      #   begin\n      #     response = Sublayer::Providers::Ollama.call(\n      #       host: \"https://api.ollama.example.com\",\n      #       model: \"text-model-001\",\n      #       prompt: \"What's the weather today?\",\n      #       output_adapter: WeatherAdapter\n      #     )\n      #     puts \"API Response: #{response}\"\n      #   rescue => e\n      #     puts \"Error processing request: #{e.message}\"\n      #   end\n      #\n      # @note The output_adapter parameter must be an object that implements the required interface\n      #   (format_properties, format_required, and name methods)\n      #\n      # @note This method expects the API to return a response with a message containing tool_calls\n      def self.call(host:, model:, prompt:, output_adapter:)\n        response = HTTParty.post(\n          \"#{host}\",\n          body: {\n            model: '#{model}',\n            messages: [\n              {\n                role: 'user',\n                content: prompt\n              }\n            ],\n            stream: false,\n            tools: [\n              {\n                type: 'function',\n                function: {\n                  name: 'response',\n                  parameters: {\n                    type: 'object',\n                    properties: output_adapter.format_properties,\n                    required: output_adapter.format_required\n                  }\n                }\n              }\n            ]\n          }.to_json\n        )\n\n        message = response['message']\n\n        raise 'No function called' unless message['tool_calls'].length > 0\n\n        function_body = message.dig('tool_calls', 0, 'function', 'arguments')\n        function_body[output_adapter.name]\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/providers/sublayer/"
    },
    {
      "filename": "openrouter.rb",
      "content": "# frozen_string_literal: true\n\nmodule Sublayer\n  module Providers\n    class OpenRouter\n      def self.call(prompt:, output_adapter:)\n        client = ::OpenAI::Client.new(access_token: ENV.fetch('OPENAI_ACCESS_TOKEN'), uri_base: 'https://openrouter.ai/api/v1')\n\n        request_id = SecureRandom.uuid\n\n        Sublayer.configuration.logger.log(\n          :info, 'OpenRouter API request', {\n            model: Sublayer.configuration.ai_model,\n            prompt: prompt,\n            request_id: request_id\n          }\n        )\n\n        before_request = Time.now\n\n        response = client.chat(\n          parameters: {\n            model: Sublayer.configuration.ai_model,\n            messages: [\n              {\n                role: 'user',\n                content: prompt\n              }\n            ],\n            tool_choice: { type: 'function', function: { name: output_adapter.name } },\n            tools: [\n              {\n                type: 'function',\n                function: {\n                  name: output_adapter.name,\n                  description: output_adapter.description,\n                  parameters: {\n                    type: 'object',\n                    properties: output_adapter.format_properties\n                  },\n                  required: output_adapter.format_required\n                }\n              }\n            ]\n          }\n        )\n\n        after_request = Time.now\n        response_time = after_request - before_request\n\n        Sublayer.configuration.logger.log(\n          :info, 'OpenRouter API response', {\n            request_id: request_id,\n            response_time: response_time,\n            usage: {\n              input_tokens: response['usage']['prompt_tokens'],\n              output_tokens: response['usage']['completion_tokens'],\n              total_tokens: response['usage']['total_tokens']\n            }\n          }\n        )\n\n        message = response.dig('choices', 0, 'message')\n\n        raise 'No function called' unless message['tool_calls']\n\n        function_body = message.dig('tool_calls', 0, 'function', 'arguments')\n\n        raise \"Error generating with OpenRouter. Empty response. Try rewording your output adapter params to be from the perspective of the model. Full Response: #{response}\" if function_body == '{}'\n        raise 'Error generating with OpenRouter. Error: Max tokens exceeded. Try breaking your problem up into smaller pieces.' if response['choices'][0]['finish_reason'] == 'length'\n\n        results = JSON.parse(function_body)[output_adapter.name]\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/providers/sublayer/"
    },
    {
      "filename": "blueprint_service.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative '../models/blueprint'\nrequire_relative '../models/category'\nrequire 'ruby_llm'\nrequire 'pgvector'\n\n# This service encapsulates the business logic for managing blueprints.\n# It handles the creation and searching of blueprints, interacting with\n# the database models and the LLM for embedding generation.\nclass BlueprintService\n  # Searches for blueprints based on a query.\n  #\n  # @param query [String, nil] The search term.\n  # @return [Array<Hash>] An array of blueprint data.\n  def search(query)\n    Blueprint.search(query).map(&:to_hash)\n  end\n\n  # Creates a new blueprint with the given parameters.\n  #\n  # @param params [Hash] A hash containing the blueprint data.\n  #   - \"name\" [String] The name of the blueprint.\n  #   - \"description\" [String] The description of the blueprint.\n  #   - \"code\" [String] The code of the blueprint.\n  #   - \"categories\" [Array<String>] A list of category names.\n  # @return [Hash] The created blueprint data.\n  def create(params)\n    # The creation process is wrapped in a database transaction to ensure atomicity.\n    # If any step fails, all changes are rolled back.\n    DB.transaction do\n      # Create a new Blueprint instance.\n      blueprint = Blueprint.new(\n        name: params['name'],\n        description: params['description'],\n        code: params['code']\n      )\n\n      # Generate a vector embedding from the name and description for semantic search.\n      embedding_text = \"#{params['name']} #{params['description']}\"\n      begin\n        embedding_result = RubyLLM.embed(embedding_text)\n        embedding_vector = embedding_result.vectors\n        blueprint.embedding = Pgvector.encode(embedding_vector)\n      rescue RubyLLM::Error => e\n        # Log the error but continue with nil embedding\n        puts \"Warning: Embedding generation failed: #{e.message}\"\n        blueprint.embedding = nil\n      end\n\n      # Save the blueprint to the database.\n      blueprint.save\n\n      # Process and associate categories if they are provided.\n      if params['categories'] && params['categories'].is_a?(Array)\n        params['categories'].each do |category_name|\n          # Find an existing category or create a new one.\n          # This prevents duplicate categories.\n          category = Category.find_or_create(name: category_name)\n          # Associate the category with the blueprint.\n          blueprint.add_category(category)\n        end\n      end\n\n      # Reload the blueprint to include associations and return its hash representation.\n      blueprint.refresh.to_hash.merge(categories: blueprint.categories.map(&:to_hash))\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/services/"
    },
    {
      "filename": "informers_embedding_service.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'singleton'\nrequire_relative '../providers/embedding_provider'\nrequire_relative '../providers/informers_provider'\nrequire_relative '../providers/ruby_llm_provider'\n\nmodule BlueprintsCLI\n  module Services\n    # Singleton service for managing embedding generation\n    #\n    # This service provides a thread-safe, memory-efficient way to generate embeddings\n    # using different providers (Informers, RubyLLM). It includes provider fallback,\n    # caching, and performance monitoring.\n    #\n    # @example Basic usage\n    #   service = InformersEmbeddingService.instance\n    #   embedding = service.embed(\"sample code\")\n    #\n    # @example With provider selection\n    #   service = InformersEmbeddingService.instance\n    #   embedding = service.embed(\"sample code\", provider: :informers)\n    #\n    # @example Batch processing\n    #   texts = [\"code1\", \"code2\", \"code3\"]\n    #   embeddings = service.embed_batch(texts)\n    #\n    class InformersEmbeddingService\n      include Singleton\n\n      # Default provider priority order\n      DEFAULT_PROVIDERS = %i[informers ruby_llm].freeze\n\n      # Service configuration\n      attr_reader :config, :stats\n\n      # Initialize the singleton instance\n      def initialize\n        @providers = {}\n        @config = load_configuration\n        @stats = {\n          total_requests: 0,\n          successful_requests: 0,\n          failed_requests: 0,\n          provider_usage: {},\n          cache_hits: 0,\n          average_response_time: 0.0\n        }\n        @mutex = Mutex.new\n\n        BlueprintsCLI.logger.info('InformersEmbeddingService initialized')\n      end\n\n      # Generate embedding for given text\n      #\n      # @param text [String] Text to embed\n      # @param provider [Symbol, nil] Specific provider to use\n      # @param options [Hash] Generation options\n      # @option options [Boolean] :normalize Whether to normalize the embedding\n      # @option options [Boolean] :cache Whether to use caching (default: true)\n      # @option options [Array<Symbol>] :fallback_providers Alternative providers to try\n      # @return [Array<Float>] Embedding vector\n      # @raise [Providers::EmbeddingProvider::EmbeddingError] If all providers fail\n      def embed(text, provider: nil, **options)\n        start_time = Time.now\n\n        @mutex.synchronize do\n          @stats[:total_requests] += 1\n        end\n\n        begin\n          result = generate_embedding(text, provider, **options)\n\n          @mutex.synchronize do\n            @stats[:successful_requests] += 1\n            update_response_time(Time.now - start_time)\n          end\n\n          result\n        rescue StandardError => e\n          @mutex.synchronize do\n            @stats[:failed_requests] += 1\n          end\n\n          BlueprintsCLI.logger.error(\"Embedding generation failed: #{e.message}\")\n          raise\n        end\n      end\n\n      # Generate embeddings for multiple texts\n      #\n      # @param texts [Array<String>] Array of texts to embed\n      # @param provider [Symbol, nil] Specific provider to use\n      # @param options [Hash] Generation options\n      # @return [Array<Array<Float>>] Array of embedding vectors\n      def embed_batch(texts, provider: nil, **options)\n        return [] if texts.nil? || texts.empty?\n\n        start_time = Time.now\n\n        @mutex.synchronize do\n          @stats[:total_requests] += texts.length\n        end\n\n        begin\n          # Try to use batch processing if available\n          selected_provider = get_provider(provider || @config[:default_provider])\n\n          result = if selected_provider.respond_to?(:embed_batch)\n                     selected_provider.embed_batch(texts, **options)\n                   else\n                     # Fallback to individual processing\n                     texts.map { |text| selected_provider.embed(text, **options) }\n                   end\n\n          @mutex.synchronize do\n            @stats[:successful_requests] += texts.length\n            @stats[:provider_usage][selected_provider.class.name] ||= 0\n            @stats[:provider_usage][selected_provider.class.name] += texts.length\n            update_response_time(Time.now - start_time)\n          end\n\n          result\n        rescue StandardError => e\n          @mutex.synchronize do\n            @stats[:failed_requests] += texts.length\n          end\n\n          BlueprintsCLI.logger.error(\"Batch embedding generation failed: #{e.message}\")\n          raise\n        end\n      end\n\n      # Get embedding dimensions for a provider\n      #\n      # @param provider [Symbol, nil] Provider name\n      # @return [Integer] Number of dimensions\n      def dimensions(provider: nil)\n        selected_provider = get_provider(provider || @config[:default_provider])\n        selected_provider.dimensions\n      end\n\n      # Check service health\n      #\n      # @return [Hash] Health status of all providers\n      def health_check\n        results = {}\n\n        available_providers.each do |provider_name|\n          provider = get_provider(provider_name)\n          results[provider_name] = {\n            healthy: provider.healthy?,\n            info: provider.respond_to?(:info) ? provider.info : {},\n            stats: provider.respond_to?(:stats) ? provider.stats : {}\n          }\n        rescue StandardError => e\n          results[provider_name] = {\n            healthy: false,\n            error: e.message\n          }\n        end\n\n        results\n      end\n\n      # Get available providers\n      #\n      # @return [Array<Symbol>] List of available provider names\n      def available_providers\n        Providers::EmbeddingProvider.available_providers\n      end\n\n      # Reset service statistics\n      def reset_stats\n        @mutex.synchronize do\n          @stats = {\n            total_requests: 0,\n            successful_requests: 0,\n            failed_requests: 0,\n            provider_usage: {},\n            cache_hits: 0,\n            average_response_time: 0.0\n          }\n        end\n\n        # Reset provider caches\n        @providers.each_value do |provider|\n          provider.clear_cache if provider.respond_to?(:clear_cache)\n        end\n      end\n\n      # Get service statistics\n      #\n      # @return [Hash] Service usage statistics\n      def service_stats\n        @mutex.synchronize do\n          @stats.merge(\n            success_rate: success_rate,\n            provider_count: @providers.size,\n            cache_stats: aggregate_cache_stats\n          )\n        end\n      end\n\n      # Clear all provider caches\n      #\n      # @return [Hash] Cache clearing results per provider\n      def clear_caches\n        results = {}\n\n        @providers.each do |name, provider|\n          results[name] = provider.clear_cache if provider.respond_to?(:clear_cache)\n        end\n\n        results\n      end\n\n      private\n\n      # Generate embedding with provider fallback\n      def generate_embedding(text, provider_name, **options)\n        providers_to_try = determine_providers(provider_name, options[:fallback_providers])\n        last_error = nil\n\n        providers_to_try.each do |prov_name|\n          provider = get_provider(prov_name)\n          result = provider.embed(text, **options)\n\n          @mutex.synchronize do\n            @stats[:provider_usage][provider.class.name] ||= 0\n            @stats[:provider_usage][provider.class.name] += 1\n          end\n\n          return result\n        rescue StandardError => e\n          last_error = e\n          BlueprintsCLI.logger.warn(\"Provider #{prov_name} failed: #{e.message}\")\n          next\n        end\n\n        raise last_error || Providers::EmbeddingProvider::EmbeddingError.new('All providers failed')\n      end\n\n      # Get or create provider instance\n      def get_provider(name)\n        return @providers[name] if @providers[name]\n\n        @mutex.synchronize do\n          # Double-check pattern for thread safety\n          return @providers[name] if @providers[name]\n\n          provider_config = @config[:providers][name] || {}\n          @providers[name] = Providers::EmbeddingProvider.create(name, **provider_config)\n        end\n      end\n\n      # Determine which providers to try\n      def determine_providers(requested_provider, fallback_providers)\n        if requested_provider\n          providers = [requested_provider]\n          providers.concat(fallback_providers) if fallback_providers\n          providers.concat(@config[:fallback_providers] - providers)\n        else\n          [@config[:default_provider]].concat(@config[:fallback_providers])\n        end\n\n        providers.compact.uniq\n      end\n\n      # Load configuration from BlueprintsCLI configuration\n      def load_configuration\n        config = BlueprintsCLI.configuration\n\n        {\n          default_provider: config.fetch(:embedding, :default_provider, default: :informers),\n          fallback_providers: config.fetch(:embedding, :fallback_providers, default: [:ruby_llm]),\n          providers: {\n            informers: {\n              model: config.fetch(:embedding, :informers, :model,\n                                  default: 'sentence-transformers/all-MiniLM-L6-v2'),\n              device: config.fetch(:embedding, :informers, :device, default: 'cpu'),\n              quantized: config.fetch(:embedding, :informers, :quantized, default: true),\n              max_length: config.fetch(:embedding, :informers, :max_length, default: 512)\n            },\n            ruby_llm: {\n              model: config.fetch(:embedding, :ruby_llm, :model, default: nil),\n              provider: config.fetch(:embedding, :ruby_llm, :provider, default: nil)\n            }\n          }\n        }\n      end\n\n      # Calculate success rate\n      def success_rate\n        total = @stats[:total_requests]\n        return 0.0 if total.zero?\n\n        (@stats[:successful_requests].to_f / total * 100).round(2)\n      end\n\n      # Aggregate cache statistics from all providers\n      def aggregate_cache_stats\n        total_cache_size = 0\n        total_hit_rate = 0.0\n        provider_count = 0\n\n        @providers.each_value do |provider|\n          next unless provider.respond_to?(:cache_stats)\n\n          stats = provider.cache_stats\n          total_cache_size += stats[:size] || 0\n          total_hit_rate += stats[:hit_rate] || 0.0\n          provider_count += 1\n        end\n\n        {\n          total_cache_size: total_cache_size,\n          average_hit_rate: provider_count.positive? ? (total_hit_rate / provider_count).round(3) : 0.0\n        }\n      end\n\n      # Update average response time\n      def update_response_time(duration)\n        current_avg = @stats[:average_response_time]\n        total_requests = @stats[:total_requests]\n\n        # Calculate running average\n        @stats[:average_response_time] =\n          ((current_avg * (total_requests - 1)) + duration) / total_requests\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/services/"
    },
    {
      "filename": "yardoc_service.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\nrequire 'tty-box'\nrequire 'tty-prompt'\nrequire 'tty-spinner'\n\nmodule BlueprintsCLI\n  module Services\n    # Service to generate YARD documentation for a Ruby file using an LLM.\n    class YardocService\n      # The prompt template for generating YARD documentation.\n      PROMPT_TEMPLATE = <<~'PROMPT'\n        # SFL-Framework YARD Documentation Generation System Prompt\n\n        ## Context\n\n        **Register Variables:**\n\n        - **Field**: Transforming Ruby code into clear, actionable developer documentation\n        - **Tenor**: Developer-to-developer communication with practical, helpful guidance\n        - **Mode**: YARD comment format optimized for API comprehension and usage\n\n        **Communicative Purpose**: Produce clear, comprehensive YARD documentation that makes Ruby code immediately understandable and usable by other developers through precise explanation of behavior, parameters, and context.\n\n        Here is the Ruby code to document:\n\n        <ruby_code>\n        {{RUBY_CODE}}\n        </ruby_code>\n\n        ## Field (Content/Subject Matter)\n\n        **Experiential Function**: Transform Ruby code into practical developer guidance through:\n\n        **Grounding in Usage Context:**\n\n        - Begin with clear method/class purpose that answers \"why would I use this?\"\n        - Connect abstract code behavior to concrete use cases and developer workflows\n        - Ground technical implementation in practical problem-solving scenarios\n\n        **Integrating Code Behavior:**\n\n        - Reference specific parameter relationships and their effects on method behavior\n        - Include realistic usage examples that demonstrate practical application\n        - Document edge cases, error conditions, and important behavioral nuances\n        - Connect method behavior to broader class or module functionality\n\n        **Documentation Completeness:**\n\n        - Link individual methods to overall class/module purpose and design patterns\n        - Connect parameter choices to common Ruby idioms and conventions\n        - Bridge specific implementation details to general Ruby best practices\n\n        ## Tenor (Relationship/Voice)\n\n        **Interpersonal Function**: Establish helpful developer support through:\n\n        **Practical Developer Roles:**\n\n        - **API Explainer**: Clear description of what the method does and how to use it\n        - **Usage Guide**: Concrete examples that show proper implementation\n        - **Warning System**: Proactive alerts about potential issues or edge cases\n        - **Future Helper**: Context that aids debugging and maintenance\n\n        **Balanced Communication:**\n\n        - **Clarity Focus (80%)**: Straightforward explanation of behavior, parameters, and returns\n        - **Contextual Insight (20%)**: Strategic notes about usage patterns, gotchas, and best practices\n\n        **Developer-Centric Power Dynamics:**\n\n        - Respect reader's Ruby knowledge while providing essential implementation details\n        - Offer clear guidance without over-explaining basic Ruby concepts\n        - Use inclusive language that assumes collaborative code maintenance\n\n        ## Mode (Organization/Texture)\n\n        **Textual Function**: Structure precise, YARD-compliant documentation through:\n\n        **YARD Format Adherence:**\n\n        - **Method Description**: Concise opening that clearly states purpose and behavior\n        - **Parameter Documentation**: `@param [Type] name description` with specific type information\n        - **Return Documentation**: `@return [Type] description` explaining what the method produces\n        - **Example Usage**: `@example` blocks showing realistic implementation scenarios\n\n        **Information Hierarchy:**\n\n        - Lead with method purpose and high-level behavior\n        - Follow with parameter details in logical order\n        - Include return value description with type information\n        - Conclude with examples and special considerations\n\n        **Documentation Patterns:**\n\n        - Use active voice for method descriptions: \"Validates user input\" not \"User input is validated\"\n        - Employ specific type annotations: `[String, nil]` not just `[Object]`\n        - Include realistic parameter examples in descriptions\n        - Maintain consistent terminology throughout related methods\n\n        ## Implementation Guidelines\n\n        **YARD Comment Structure:**\n\n        ```ruby\n        ##\n        # Brief method description explaining primary purpose\n        #\n        # Optional longer description providing context, usage notes,\n        # or important behavioral details\n        #\n        # @param [Type] param_name Description of parameter and its role\n        # @param [Type, nil] optional_param Description with default behavior\n        # @return [Type] Description of return value and its structure\n        # @raise [ExceptionClass] When and why this exception occurs\n        # @example Basic usage\n        #   method_call(param1, param2)\n        #   # => expected_result\n        # @example Advanced usage\n        #   method_call(complex_param) do |block_param|\n        #     # block implementation\n        #   end\n        # @since 1.2.0\n        # @see RelatedClass#related_method\n        def method_name(params)\n        ```\n\n        **Documentation Process:**\n\n        1. **Analyze Method Purpose**: What problem does this method solve?\n        2. **Identify Parameter Relationships**: How do parameters interact to produce the result?\n        3. **Document Return Behavior**: What does the method produce and under what conditions?\n        4. **Consider Edge Cases**: What exceptional conditions or error states exist?\n        5. **Provide Usage Examples**: What realistic scenarios demonstrate proper usage?\n\n        **Type Documentation Standards:**\n\n        - Use specific Ruby types: `String`, `Integer`, `Hash`, `Array`\n        - Document hash structures: `Hash{String => Object}` or `Hash{Symbol => String}`\n        - Include nil possibilities: `String, nil` for optional returns\n        - Use duck typing when appropriate: `#to_s` for objects that respond to `to_s`\n\n        **Example Quality Requirements:**\n\n        - Show realistic parameter values, not `foo` and `bar`\n        - Demonstrate actual method calls with expected outputs\n        - Include block usage when relevant\n        - Show both simple and complex usage scenarios\n\n        **Output Requirements:**\n\n        - Complete YARD comment block ready for insertion above the method\n        - Accurate type annotations based on code analysis\n        - Clear, actionable descriptions that help developers use the method correctly\n        - Realistic examples that demonstrate practical usage patterns\n        - Proper YARD tag usage following established conventions\n\n        **Anti-Patterns to Avoid:**\n\n        - Vague descriptions that don't explain actual behavior\n        - Missing or incorrect type annotations\n        - Examples that don't work or use unrealistic data\n        - Over-documentation of obvious Ruby concepts\n        - Inconsistent terminology across related methods\n        - Missing documentation of important edge cases or exceptions\n\n        Generate YARD documentation for the provided ruby code.\n        Your output should be the complete, original Ruby code with the new YARD comment blocks inserted directly above the corresponding class and method definitions.\n        Do not return only the comments.\n      PROMPT\n\n      # Initializes the YardocService.\n      # @param file_path [String] The path to the Ruby file to document.\n      # @param preview [Boolean] Whether to show preview before writing (default: true)\n      def initialize(file_path, preview: true)\n        @file_path = file_path\n        @preview = preview\n        @prompt = TTY::Prompt.new if preview\n        \n        # Configure RubyLLM with available API keys\n        configure_rubyllm\n        \n        # Initialize chat with appropriate model and provider\n        @chat = create_chat_instance\n      end\n\n      # Generates YARD documentation for the file.\n      # @return [Boolean] true if successful, false otherwise.\n      def call\n        puts \"Generating YARD documentation for #{@file_path}...\"\n        \n        unless File.exist?(@file_path)\n          puts \"Error: File not found at #{@file_path}\"\n          return false\n        end\n\n        file_content = File.read(@file_path)\n        \n        # Show before preview if enabled\n        if @preview\n          show_before_preview(file_content)\n        end\n\n        llm_prompt = PROMPT_TEMPLATE.gsub('{{RUBY_CODE}}', file_content)\n\n        begin\n          # Set up spinner for AI generation feedback\n          spinner = TTY::Spinner.new(\"[:spinner] Generating YARD documentation with AI...\", \n                                     format: :dots)\n          \n          # Set up callback for streaming response feedback\n          @chat.on_new_message do\n            spinner.spin\n          end\n          \n          spinner.auto_spin\n          response_message = @chat.ask(llm_prompt)\n          spinner.success('Documentation generated!')\n          \n          if response_message && response_message.content && !response_message.content.strip.empty?\n            documented_content = response_message.content\n            \n            # Show after preview and confirm if preview enabled\n            if @preview\n              return false unless show_after_preview_and_confirm(file_content, documented_content)\n            end\n            \n            File.write(@file_path, documented_content)\n            show_success_message\n            true\n          else\n            spinner.error('Empty response from AI') if defined?(spinner)\n            puts \"Error: Received empty response from LLM.\"\n            false\n          end\n        rescue => e\n          spinner.error('Generation failed') if defined?(spinner)\n          puts \"Error generating documentation: #{e.message}\"\n          false\n        end\n      end\n\n      private\n\n      # Shows a preview of the original code before documentation generation\n      def show_before_preview(file_content)\n        preview_content = file_content.lines.first(15).join\n        preview_content += \"\\n...\" if file_content.lines.length > 15\n\n        before_box = TTY::Box.frame(\n          preview_content,\n          title: { top_left: '📜 Original Code' },\n          style: { border: { fg: :blue } },\n          padding: 1\n        )\n        \n        puts before_box\n        @prompt.keypress('Press any key to start YARD generation...')\n        print TTY::Cursor.clear_screen_down if defined?(TTY::Cursor)\n      end\n\n      # Shows before/after preview and asks for confirmation\n      def show_after_preview_and_confirm(original_content, documented_content)\n        # Show original preview\n        original_preview = original_content.lines.first(10).join\n        original_preview += \"\\n...\" if original_content.lines.length > 10\n\n        original_box = TTY::Box.frame(\n          original_preview,\n          title: { top_left: '📜 Before (Original)' },\n          style: { border: { fg: :blue } },\n          width: 80,\n          padding: 1\n        )\n\n        # Show documented preview\n        documented_preview = documented_content.lines.first(15).join\n        documented_preview += \"\\n...\" if documented_content.lines.length > 15\n\n        documented_box = TTY::Box.frame(\n          documented_preview,\n          title: { top_left: '📚 After (With YARD Documentation)' },\n          style: { border: { fg: :green } },\n          width: 80,\n          padding: 1\n        )\n\n        # Display both boxes\n        puts original_box\n        puts documented_box\n\n        # Ask for confirmation\n        @prompt.yes?('Apply YARD documentation to file?')\n      end\n\n      # Configure RubyLLM with available API keys\n      def configure_rubyllm\n        RubyLLM.configure do |config|\n          # Use Gemini if available\n          if ENV['GEMINI_API_KEY']\n            config.gemini_api_key = ENV['GEMINI_API_KEY']\n          # Use OpenRouter if available\n          elsif ENV['OPENROUTER_API_KEY']\n            config.openai_api_key = ENV['OPENROUTER_API_KEY']\n            config.openai_api_base = 'https://openrouter.ai/api/v1'\n          # Use OpenAI if available\n          elsif ENV['OPENAI_API_KEY']\n            config.openai_api_key = ENV['OPENAI_API_KEY']\n          end\n        end\n      end\n\n      # Create chat instance with appropriate model and provider\n      def create_chat_instance\n        if ENV['GEMINI_API_KEY']\n          RubyLLM.chat(model: 'gemini-2.0-flash', provider: :gemini)\n        elsif ENV['OPENROUTER_API_KEY']\n          RubyLLM.chat(model: 'gemini-2.0-flash', provider: :openai)\n        elsif ENV['OPENAI_API_KEY']\n          RubyLLM.chat(model: 'gpt-4o-mini', provider: :openai)\n        else\n          raise 'No AI provider configured. Please set GEMINI_API_KEY, OPENROUTER_API_KEY, or OPENAI_API_KEY environment variable.'\n        end\n      end\n\n      # Shows success message with styled box\n      def show_success_message\n        success_box = TTY::Box.frame(\n          \"Successfully generated YARD documentation for:\\n#{@file_path}\",\n          title: { top_left: '✅ Documentation Generated' },\n          style: { border: { fg: :green } },\n          padding: 1,\n          align: :center\n        )\n        puts success_box\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/services/"
    },
    {
      "filename": "config_generator.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'yaml'\nrequire 'fileutils'\n\nmodule BlueprintsCLI\n  module Setup\n    # ConfigGenerator creates the final configuration file based on setup data.\n    # It takes all the collected setup information and generates a comprehensive\n    # config.yml file that can be used by the BlueprintsCLI application.\n    class ConfigGenerator\n      # Configuration template structure\n      CONFIG_TEMPLATE = {\n        database: {},\n        ai: {\n          sublayer: {},\n          rubyllm: {},\n          openai: { log_errors: true }\n        },\n        logger: {},\n        editor: {},\n        ui: {},\n        features: {\n          auto_description: true,\n          auto_categorize: true,\n          improvement_analysis: true\n        },\n        search: {\n          default_limit: 10,\n          semantic_search: true,\n          text_search_fallback: true\n        },\n        export: {\n          include_metadata: false,\n          auto_detect_extension: true\n        },\n        performance: {\n          batch_size: 100,\n          connection_pool_size: 5\n        }\n      }.freeze\n\n      # Initialize the config generator\n      #\n      # @param config [BlueprintsCLI::Configuration] Configuration instance\n      # @param setup_data [Hash] Setup data collected during wizard\n      def initialize(config, setup_data)\n        @config = config\n        @setup_data = setup_data\n        @logger = BlueprintsCLI.logger\n        @generated_config = {}\n      end\n\n      # Generate and save the configuration\n      #\n      # @return [Boolean] True if configuration was generated and saved successfully\n      def generate_and_save\n        @logger.info('Generating configuration file...')\n\n        begin\n          build_configuration\n          validate_configuration\n          backup_existing_config\n          save_configuration\n          update_environment_instructions\n\n          @logger.success('Configuration file generated successfully!')\n          true\n        rescue StandardError => e\n          @logger.failure(\"Failed to generate configuration: #{e.message}\")\n          @logger.debug(e.backtrace.join(\"\\n\")) if ENV['DEBUG']\n          false\n        end\n      end\n\n      private\n\n      # Build the complete configuration from setup data\n      def build_configuration\n        @generated_config = CONFIG_TEMPLATE.dup\n\n        build_database_config\n        build_ai_config\n        build_logger_config\n        build_editor_config\n        build_ui_config\n        build_performance_config\n\n        @logger.info('Configuration structure built')\n      end\n\n      # Build database configuration section\n      def build_database_config\n        return unless @setup_data[:database]\n\n        @generated_config[:database] = {\n          url: @setup_data[:database][:url],\n          pool_size: 5\n        }\n\n        # Add pgvector-specific settings if available\n        if @setup_data[:database][:pgvector_enabled]\n          @generated_config[:search][:semantic_search] = true\n          @generated_config[:features][:vector_search] = true\n        else\n          @generated_config[:search][:semantic_search] = false\n          @generated_config[:features][:vector_search] = false\n        end\n      end\n\n      # Build AI configuration section\n      def build_ai_config\n        build_sublayer_config\n        build_rubyllm_config\n        build_provider_specific_config\n      end\n\n      # Build Sublayer AI configuration\n      def build_sublayer_config\n        primary_provider = @setup_data[:primary_provider]\n        return unless primary_provider\n\n        provider_map = {\n          openai: 'OpenAI',\n          openrouter: 'OpenAI', # OpenRouter uses OpenAI format\n          anthropic: 'Anthropic',\n          gemini: 'Gemini',\n          deepseek: 'DeepSeek'\n        }\n\n        @generated_config[:ai][:sublayer] = {\n          provider: provider_map[primary_provider] || 'Gemini',\n          model: @setup_data[:models]&.dig(:chat, :id) || 'gemini-2.0-flash',\n          project_name: 'BlueprintsCLI',\n          template: 'default',\n          project_template: 'CLI'\n        }\n      end\n\n      # Build RubyLLM configuration\n      def build_rubyllm_config\n        default_model = @setup_data[:models]&.dig(:chat, :id) || 'gemini-2.0-flash'\n        embedding_model = @setup_data[:models]&.dig(:embedding, :id) || 'text-embedding-004'\n\n        @generated_config[:ai][:rubyllm] = {\n          default_model: default_model,\n          default_embedding_model: embedding_model,\n          default_image_model: 'imagen-3.0-generate-002',\n          request_timeout: 120,\n          max_retries: 3,\n          retry_interval: 0.5,\n          retry_backoff_factor: 2,\n          retry_interval_randomness: 0.5,\n          log_level: 'info',\n          log_assume_model_exists: false\n        }\n\n        # Add OpenRouter API base if using OpenRouter\n        if @setup_data[:providers]&.key?(:openrouter)\n          @generated_config[:ai][:rubyllm][:openai_api_base] = 'https://openrouter.ai/api/v1'\n        end\n\n        # Set embedding model from configuration\n        @generated_config[:ai][:embedding_model] = embedding_model\n      end\n\n      # Build provider-specific configuration\n      def build_provider_specific_config\n        # Add any provider-specific settings\n        if @setup_data[:providers]&.key?(:openai) || @setup_data[:providers]&.key?(:openrouter)\n          @generated_config[:ai][:openai] = { log_errors: true }\n        end\n      end\n\n      # Build logger configuration section\n      def build_logger_config\n        logger_config = @setup_data[:logger] || {}\n\n        @generated_config[:logger] = {\n          level: logger_config[:level] || 'info',\n          file_logging: logger_config[:file_logging] || false,\n          file_level: logger_config[:file_level] || 'debug',\n          file_path: logger_config[:file_path] || default_log_path,\n          context_enabled: logger_config[:context_enabled] || true,\n          context_detail_level: logger_config[:context_detail_level] || 'full',\n          context_cache_size: logger_config[:context_cache_size] || 1000\n        }\n      end\n\n      # Build editor configuration section\n      def build_editor_config\n        editor_config = @setup_data[:editor] || {}\n\n        @generated_config[:editor] = {\n          default: editor_config[:default] || ENV['EDITOR'] || ENV['VISUAL'] || 'vim',\n          auto_save: editor_config[:auto_save] || true,\n          temp_dir: editor_config[:temp_dir] || '/tmp'\n        }\n      end\n\n      # Build UI configuration section\n      def build_ui_config\n        ui_config = @setup_data[:ui] || {}\n\n        @generated_config[:ui] = {\n          colors: ui_config[:colors] || true,\n          interactive: ui_config[:interactive] || true,\n          pager: ui_config[:pager] || 'most',\n          auto_pager: ui_config[:auto_pager] || true\n        }\n      end\n\n      # Build performance configuration section\n      def build_performance_config\n        # Use existing performance config or defaults\n        @generated_config[:performance] = {\n          batch_size: 100,\n          connection_pool_size: 5\n        }\n      end\n\n      # Validate the generated configuration\n      def validate_configuration\n        @logger.info('Validating configuration...')\n\n        # Check required sections\n        required_sections = %i[database ai logger]\n        required_sections.each do |section|\n          unless @generated_config[section]\n            raise StandardError, \"Missing required configuration section: #{section}\"\n          end\n        end\n\n        # Validate database URL\n        if @generated_config[:database][:url].nil? || @generated_config[:database][:url].empty?\n          raise StandardError, 'Database URL is required'\n        end\n\n        # Validate AI provider configuration\n        unless @generated_config[:ai][:sublayer][:provider]\n          raise StandardError, 'AI provider must be specified'\n        end\n\n        @logger.success('Configuration validation passed')\n      end\n\n      # Backup existing configuration if it exists\n      def backup_existing_config\n        config_path = @config.config_file_path\n        return unless config_path && File.exist?(config_path)\n\n        backup_path = \"#{config_path}.backup.#{Time.now.strftime('%Y%m%d_%H%M%S')}\"\n        FileUtils.cp(config_path, backup_path)\n        @logger.info(\"Existing configuration backed up to: #{backup_path}\")\n      end\n\n      # Save the configuration to file\n      def save_configuration\n        # Ensure config directory exists\n        config_dir = File.dirname(target_config_path)\n        FileUtils.mkdir_p(config_dir)\n\n        # Write configuration file\n        File.write(target_config_path, generate_yaml_content)\n\n        @logger.success(\"Configuration saved to: #{target_config_path}\")\n      end\n\n      # Generate YAML content with comments\n      #\n      # @return [String] YAML content with helpful comments\n      def generate_yaml_content\n        content = \"---\\n\"\n        content += \"# BlueprintsCLI Configuration\\n\"\n        content += \"# Generated by setup wizard on #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\"\n\n        # Add database section with comments\n        content += \"# Database Configuration\\n\"\n        content += \"database:\\n\"\n        content += \"  url: #{@generated_config[:database][:url]}\\n\"\n        content += \"  pool_size: #{@generated_config[:database][:pool_size]}\\n\\n\"\n\n        # Add AI section with comments\n        content += \"# AI Provider Configuration\\n\"\n        content += generate_ai_yaml_section\n\n        # Add logger section with comments\n        content += \"# Logging Configuration\\n\"\n        content += generate_logger_yaml_section\n\n        # Add other sections\n        content += generate_remaining_yaml_sections\n\n        content\n      end\n\n      # Generate AI configuration YAML section\n      #\n      # @return [String] AI section YAML\n      def generate_ai_yaml_section\n        content = \"ai:\\n\"\n        content += \"  sublayer:\\n\"\n        @generated_config[:ai][:sublayer].each do |key, value|\n          content += \"    #{key}: #{value}\\n\"\n        end\n\n        content += \"  rubyllm:\\n\"\n        @generated_config[:ai][:rubyllm].each do |key, value|\n          content += \"    #{key}: #{value}\\n\"\n        end\n\n        content += \"  openai:\\n\"\n        content += \"    log_errors: #{@generated_config[:ai][:openai][:log_errors]}\\n\"\n        content += \"  embedding_model: #{@generated_config[:ai][:embedding_model]}\\n\\n\"\n\n        content\n      end\n\n      # Generate logger configuration YAML section\n      #\n      # @return [String] Logger section YAML\n      def generate_logger_yaml_section\n        content = \"logger:\\n\"\n        @generated_config[:logger].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        content\n      end\n\n      # Generate remaining configuration YAML sections\n      #\n      # @return [String] Remaining sections YAML\n      def generate_remaining_yaml_sections\n        content = ''\n\n        # Editor configuration\n        content += \"editor:\\n\"\n        @generated_config[:editor].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        # UI configuration\n        content += \"ui:\\n\"\n        @generated_config[:ui].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        # Features configuration\n        content += \"features:\\n\"\n        @generated_config[:features].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        # Search configuration\n        content += \"search:\\n\"\n        @generated_config[:search].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        # Export configuration\n        content += \"export:\\n\"\n        @generated_config[:export].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n        content += \"\\n\"\n\n        # Performance configuration\n        content += \"performance:\\n\"\n        @generated_config[:performance].each do |key, value|\n          content += \"  #{key}: #{value}\\n\"\n        end\n\n        content\n      end\n\n      # Get target configuration file path\n      #\n      # @return [String] Path where config should be saved\n      def target_config_path\n        # Try to use existing path, fallback to default user config location\n        @config.config_file_path || File.join(Dir.home, '.config', 'BlueprintsCLI', 'config.yml')\n      end\n\n      # Get default log file path\n      #\n      # @return [String] Default path for log file\n      def default_log_path\n        state_home = ENV['XDG_STATE_HOME'] || File.expand_path('~/.local/state')\n        File.join(state_home, 'BlueprintsCLI', 'app.log')\n      end\n\n      # Provide instructions for environment variables\n      def update_environment_instructions\n        return unless @setup_data[:providers]\n\n        puts \"\\n📝 Environment Variables Required:\"\n        puts 'Add these environment variables to your shell profile:'\n        puts ''\n\n        @setup_data[:providers].each_value do |provider_config|\n          env_var = provider_config[:env_var]\n          puts \"export #{env_var}='your_api_key_here'\"\n        end\n\n        puts ''\n        puts '💡 Tip: Create a .env file in your project directory with these variables.'\n        puts 'The application will automatically load them on startup.'\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/setup/"
    },
    {
      "filename": "database_setup.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'sequel'\nrequire 'pg'\nrequire 'uri'\n\nmodule BlueprintsCLI\n  module Setup\n    # DatabaseSetup handles PostgreSQL database configuration, connection testing,\n    # and migration setup for BlueprintsCLI. It guides users through database\n    # setup including connection string configuration and pgvector extension setup.\n    class DatabaseSetup\n      # Database configuration templates\n      DATABASE_TEMPLATES = {\n        local: {\n          name: 'Local PostgreSQL',\n          description: 'PostgreSQL running on localhost (default setup)',\n          template: :local_default,\n          requirements: ['PostgreSQL server running locally', 'pgvector extension available']\n        },\n        docker: {\n          name: 'Docker PostgreSQL',\n          description: 'PostgreSQL running in Docker container (auto-managed)',\n          template: :docker_default,\n          requirements: ['Docker installed and running'],\n          features: ['Automatic container management', 'pgvector pre-installed',\n            'Isolated environment']\n        },\n        remote: {\n          name: 'Remote PostgreSQL',\n          description: 'PostgreSQL running on remote server or cloud',\n          template: :remote_example,\n          requirements: ['Network access to database', 'pgvector extension installed']\n        },\n        custom: {\n          name: 'Custom Configuration',\n          description: 'Enter your own database connection string',\n          template: '',\n          requirements: ['Valid PostgreSQL connection string']\n        }\n      }.freeze\n\n      # Initialize the database setup\n      #\n      # @param prompt [TTY::Prompt] TTY prompt instance\n      # @param setup_data [Hash] Setup data storage\n      def initialize(prompt, setup_data)\n        @prompt = prompt\n        @setup_data = setup_data\n        @logger = BlueprintsCLI.logger\n        @database_url = nil\n        @connection = nil\n      end\n\n      # Get template URL for a given template type\n      #\n      # @param template_type [Symbol] Template identifier\n      # @return [String] Database URL template\n      def get_template_url(template_type)\n        case template_type\n        when :local_default\n          'postgresql://postgres:password@localhost:5432/blueprints'\n        when :docker_default\n          BlueprintsCLI.configuration.build_database_url\n        when :remote_example\n          'postgresql://username:password@hostname:5432/database_name'\n        else\n          ''\n        end\n      end\n\n      # Configure and test database connection\n      #\n      # @return [Boolean] True if database setup completed successfully\n      def configure_and_test\n        @logger.info('Setting up database configuration...')\n\n        detect_existing_database\n        configure_database_connection\n        test_database_connection\n        setup_database_schema\n        finalize_database_setup\n\n        true\n      rescue StandardError => e\n        @logger.failure(\"Database setup failed: #{e.message}\")\n        @logger.debug(e.backtrace.join(\"\\n\")) if ENV['DEBUG']\n        false\n      end\n\n      private\n\n      # Handle Docker PostgreSQL setup\n      #\n      # @param template [Hash] Docker template configuration\n      def handle_docker_setup(_template)\n        @logger.info('Setting up Docker PostgreSQL...')\n\n        # Check if Docker is available\n        unless docker_available?\n          @logger.failure('Docker is not available or not running')\n          handle_docker_not_available\n          return\n        end\n\n        # Check if container already exists and is running\n        if docker_container_running?\n          @logger.success('PostgreSQL container is already running')\n          use_existing = @prompt.yes?('Use existing Docker PostgreSQL container?', default: true)\n\n          if use_existing\n            @database_url = get_docker_database_url\n            return\n          elsif @prompt.yes?('Stop and recreate container?',\n                             default: false)\n\n            stop_and_remove_container\n          end\n        end\n\n        # Start new Docker container\n        start_docker_postgres\n      end\n\n      # Check if Docker is available and running\n      #\n      # @return [Boolean] True if Docker is available\n      def docker_available?\n        system('docker --version > /dev/null 2>&1') && system('docker info > /dev/null 2>&1')\n      end\n\n      # Check if PostgreSQL container is running\n      #\n      # @return [Boolean] True if container is running\n      def docker_container_running?\n        system('docker ps --filter \"name=blueprintscli_postgres\" --filter \"status=running\" | grep -q blueprintscli_postgres')\n      end\n\n      # Handle case when Docker is not available\n      def handle_docker_not_available\n        puts \"\\n❌ Docker Not Available\"\n        puts 'Docker is required for the Docker PostgreSQL option.'\n        puts ''\n        puts 'Installation options:'\n        puts '1. Install Docker Desktop: https://www.docker.com/products/docker-desktop'\n        puts '2. Install Docker Engine: https://docs.docker.com/engine/install/'\n        puts '3. Choose a different database configuration'\n        puts ''\n\n        retry_with_different = @prompt.yes?('Choose a different database configuration?',\n                                            default: true)\n        unless retry_with_different\n          raise StandardError, 'Docker is required for Docker PostgreSQL setup'\n        end\n\n        configure_database_connection\n      end\n\n      # Start Docker PostgreSQL container\n      def start_docker_postgres\n        @logger.info('Starting Docker PostgreSQL container...')\n\n        docker_compose_path = File.join(BlueprintsCLI.root, 'docker', 'docker-compose.yml')\n\n        unless File.exist?(docker_compose_path)\n          @logger.failure(\"Docker Compose file not found at: #{docker_compose_path}\")\n          raise StandardError, 'Docker Compose configuration missing'\n        end\n\n        # Start the container\n        @logger.info('Running: docker compose up -d')\n        success = system(\"cd #{File.dirname(docker_compose_path)} && docker compose up -d\")\n\n        unless success\n          @logger.failure('Failed to start Docker PostgreSQL container')\n          raise StandardError, 'Docker container startup failed'\n        end\n\n        # Wait for container to be ready\n        wait_for_docker_postgres\n\n        @database_url = get_docker_database_url\n        @logger.success('Docker PostgreSQL container started successfully!')\n      end\n\n      # Wait for Docker PostgreSQL to be ready\n      def wait_for_docker_postgres\n        @logger.info('Waiting for PostgreSQL container to be ready...')\n\n        max_attempts = 30\n        attempt = 0\n\n        while attempt < max_attempts\n          attempt += 1\n\n          if docker_postgres_ready?\n            @logger.success('PostgreSQL container is ready!')\n            return\n          end\n\n          print '.'\n          sleep 2\n        end\n\n        puts ''\n        @logger.failure('PostgreSQL container did not become ready in time')\n        raise StandardError, 'PostgreSQL container startup timeout'\n      end\n\n      # Check if Docker PostgreSQL is ready to accept connections\n      #\n      # @return [Boolean] True if PostgreSQL is ready\n      def docker_postgres_ready?\n        system('docker exec blueprintscli_postgres pg_isready -U postgres -d blueprints > /dev/null 2>&1')\n      end\n\n      # Get database URL for Docker PostgreSQL\n      #\n      # @return [String] Database connection URL\n      def get_docker_database_url\n        BlueprintsCLI.configuration.build_database_url\n      end\n\n      # Stop and remove existing Docker container\n      def stop_and_remove_container\n        @logger.info('Stopping and removing existing container...')\n\n        system('docker stop blueprintscli_postgres > /dev/null 2>&1')\n        system('docker rm blueprintscli_postgres > /dev/null 2>&1')\n\n        @logger.success('Existing container removed')\n      end\n\n      # Detect existing database configuration\n      def detect_existing_database\n        existing_url = ENV['DATABASE_URL'] || ENV.fetch('BLUEPRINT_DATABASE_URL', nil)\n\n        if existing_url\n          @logger.info('Found existing database URL in environment')\n          use_existing = @prompt.yes?('Use existing database configuration?', default: true)\n\n          if use_existing\n            @database_url = existing_url\n            @logger.success('Using existing database configuration')\n            return\n          end\n        end\n\n        prompt_database_configuration\n      end\n\n      # Prompt user for database configuration\n      def prompt_database_configuration\n        puts \"\\n🗄️  Database Configuration\"\n        puts 'BlueprintsCLI requires PostgreSQL with pgvector extension for vector search.'\n        puts ''\n\n        display_database_templates\n        template_choice = prompt_template_selection\n        configure_from_template(template_choice)\n      end\n\n      # Display available database templates\n      def display_database_templates\n        puts 'Available database configurations:'\n        DATABASE_TEMPLATES.each_value do |template|\n          puts \"\\n  #{template[:name]}:\"\n          puts \"    #{template[:description]}\"\n          puts \"    Requirements: #{template[:requirements].join(', ')}\"\n\n          puts \"    Features: #{template[:features].join(', ')}\" if template[:features]\n        end\n        puts ''\n      end\n\n      # Prompt user to select database template\n      #\n      # @return [Symbol] Selected template key\n      def prompt_template_selection\n        choices = DATABASE_TEMPLATES.map do |key, template|\n          { name: template[:name], value: key }\n        end\n\n        @prompt.select('Select database configuration:', choices)\n      end\n\n      # Configure database from selected template\n      #\n      # @param template_key [Symbol] Template identifier\n      def configure_from_template(template_key)\n        template = DATABASE_TEMPLATES[template_key]\n\n        case template_key\n        when :custom\n          @database_url = @prompt.ask('Enter database URL:')\n        when :docker\n          handle_docker_setup(template)\n        else\n          @database_url = prompt_template_customization(template)\n        end\n\n        validate_database_url\n      end\n\n      # Prompt user to customize template\n      #\n      # @param template [Hash] Database template\n      # @return [String] Customized database URL\n      def prompt_template_customization(template)\n        template_url = get_template_url(template[:template])\n        puts \"\\nTemplate: #{template_url}\"\n\n        use_template = @prompt.yes?('Use this template as-is?', default: true)\n        return template_url if use_template\n\n        # Parse template and prompt for customization\n        uri = URI.parse(template_url)\n\n        host = @prompt.ask('Database host:', default: uri.host)\n        port = @prompt.ask('Database port:', default: uri.port.to_s).to_i\n        username = @prompt.ask('Username:', default: uri.user)\n        password = @prompt.mask('Password:', default: uri.password || '')\n        database = @prompt.ask('Database name:', default: uri.path[1..]) # Remove leading slash\n\n        \"postgresql://#{username}:#{password}@#{host}:#{port}/#{database}\"\n      end\n\n      # Validate database URL format\n      def validate_database_url\n        return if @database_url.nil? || @database_url.empty?\n\n        begin\n          uri = URI.parse(@database_url)\n          unless %w[postgresql postgres].include?(uri.scheme)\n            raise ArgumentError, 'URL must use postgresql:// or postgres:// scheme'\n          end\n        rescue URI::InvalidURIError => e\n          @logger.failure(\"Invalid database URL: #{e.message}\")\n          retry_database_config\n        rescue ArgumentError => e\n          @logger.failure(\"Invalid database URL: #{e.message}\")\n          retry_database_config\n        end\n      end\n\n      # Retry database configuration on validation failure\n      def retry_database_config\n        retry_setup = @prompt.yes?('Retry database configuration?', default: true)\n        raise StandardError, 'Database configuration failed' unless retry_setup\n\n        configure_database_connection\n      end\n\n      # Test database connection\n      #\n      # @return [Boolean] True if connection successful\n      def test_database_connection\n        @logger.info('Testing database connection...')\n\n        begin\n          @connection = Sequel.connect(@database_url)\n\n          # Test basic connectivity\n          @connection.test_connection\n          @logger.success('✓ Database connection successful')\n\n          # Check PostgreSQL version\n          version_result = @connection.fetch('SELECT version()').first\n          @logger.info(\"PostgreSQL version: #{version_result[:version]}\")\n\n          # Test pgvector extension\n          test_pgvector_extension\n\n          true\n        rescue Sequel::DatabaseConnectionError => e\n          @logger.failure(\"Database connection failed: #{e.message}\")\n          handle_connection_failure(e)\n        rescue PG::ConnectionBad => e\n          @logger.failure(\"PostgreSQL connection failed: #{e.message}\")\n          handle_connection_failure(e)\n        end\n      end\n\n      # Test pgvector extension availability\n      def test_pgvector_extension\n        @logger.info('Checking pgvector extension...')\n\n        begin\n          # Check if pgvector extension exists\n          extension_check = @connection.fetch(\n            \"SELECT * FROM pg_available_extensions WHERE name = 'vector'\"\n          ).first\n\n          if extension_check\n            @logger.success('✓ pgvector extension available')\n\n            # Check if it's installed\n            installed_check = @connection.fetch(\n              \"SELECT * FROM pg_extension WHERE extname = 'vector'\"\n            ).first\n\n            if installed_check\n              @logger.success('✓ pgvector extension already installed')\n            else\n              install_pgvector_extension\n            end\n          else\n            @logger.failure('✗ pgvector extension not available')\n            handle_pgvector_missing\n          end\n        rescue StandardError => e\n          @logger.warn(\"Could not check pgvector extension: #{e.message}\")\n        end\n      end\n\n      # Install pgvector extension\n      def install_pgvector_extension\n        @logger.info('Installing pgvector extension...')\n\n        begin\n          @connection.run('CREATE EXTENSION IF NOT EXISTS vector')\n          @logger.success('✓ pgvector extension installed')\n        rescue Sequel::DatabaseError => e\n          @logger.failure(\"Failed to install pgvector: #{e.message}\")\n          @logger.warn('You may need to install pgvector manually or contact your DBA')\n        end\n      end\n\n      # Handle missing pgvector extension\n      def handle_pgvector_missing\n        puts \"\\n⚠️  pgvector Extension Missing\"\n        puts 'BlueprintsCLI requires the pgvector extension for vector similarity search.'\n        puts ''\n        puts 'Installation options:'\n        puts '1. Install pgvector using your package manager'\n        puts '2. Use Docker with a pgvector-enabled PostgreSQL image'\n        puts '3. Contact your database administrator'\n        puts ''\n        puts 'See: https://github.com/pgvector/pgvector for installation instructions'\n\n        continue_anyway = @prompt.yes?(\n          'Continue setup without pgvector? (vector search will be disabled)', default: false\n        )\n        return if continue_anyway\n\n        raise StandardError, 'pgvector extension required'\n      end\n\n      # Handle database connection failure\n      #\n      # @param error [StandardError] Connection error\n      def handle_connection_failure(error)\n        puts \"\\n❌ Database Connection Failed\"\n        puts \"Error: #{error.message}\"\n        puts ''\n        puts 'Common solutions:'\n        puts '1. Ensure PostgreSQL server is running'\n        puts '2. Check host, port, username, and password'\n        puts '3. Verify database exists'\n        puts '4. Check firewall settings'\n        puts ''\n\n        retry_connection = @prompt.yes?('Retry with different configuration?', default: true)\n        raise StandardError, 'Database connection failed' unless retry_connection\n\n        configure_database_connection\n        test_database_connection\n      end\n\n      # Setup database schema\n      def setup_database_schema\n        @logger.info('Setting up database schema...')\n\n        begin\n          # Check if migrations are needed\n          migration_needed = check_migration_status\n\n          if migration_needed\n            run_migrations\n          else\n            @logger.success('Database schema is up to date')\n          end\n        rescue StandardError => e\n          @logger.failure(\"Schema setup failed: #{e.message}\")\n          handle_schema_failure(e)\n        end\n      end\n\n      # Check if database migrations are needed\n      #\n      # @return [Boolean] True if migrations are needed\n      def check_migration_status\n        # Check if blueprints table exists\n        tables = @connection.tables\n        blueprint_table_exists = tables.include?(:blueprints)\n\n        if blueprint_table_exists\n          @logger.info('Existing database schema detected')\n          false\n        else\n          @logger.info('New database - migrations needed')\n          true\n        end\n      rescue StandardError\n        # Assume migrations are needed if we can't check\n        true\n      end\n\n      # Run database migrations\n      def run_migrations\n        @logger.info('Running database migrations...')\n\n        begin\n          # This would typically use the application's migration system\n          # For now, we'll create a basic schema\n          create_basic_schema\n          @logger.success('✓ Database migrations completed')\n        rescue StandardError => e\n          @logger.failure(\"Migration failed: #{e.message}\")\n          raise e\n        end\n      end\n\n      # Create basic database schema\n      def create_basic_schema\n        @logger.info('Creating basic database schema...')\n\n        # Create categories table\n        @connection.run <<~SQL\n          CREATE TABLE IF NOT EXISTS categories (\n            id SERIAL PRIMARY KEY,\n            title VARCHAR(255) UNIQUE NOT NULL,\n            description TEXT,\n            color VARCHAR(7),\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n          )\n        SQL\n\n        # Handle schema migration: rename 'name' column to 'title' if it exists\n        migrate_categories_schema\n\n        # Create blueprints table with vector column\n        @connection.run <<~SQL\n          CREATE TABLE IF NOT EXISTS blueprints (\n            id SERIAL PRIMARY KEY,\n            name VARCHAR(255) NOT NULL,\n            description TEXT,\n            code TEXT NOT NULL,\n            language VARCHAR(50),\n            tags TEXT[],\n            embedding vector(768),\n            metadata JSONB DEFAULT '{}',\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n          )\n        SQL\n\n        # Create junction table for categories\n        @connection.run <<~SQL\n          CREATE TABLE IF NOT EXISTS blueprints_categories (\n            blueprint_id INTEGER REFERENCES blueprints(id) ON DELETE CASCADE,\n            category_id INTEGER REFERENCES categories(id) ON DELETE CASCADE,\n            PRIMARY KEY (blueprint_id, category_id)\n          )\n        SQL\n\n        # Create indexes\n        @connection.run 'CREATE INDEX IF NOT EXISTS idx_blueprints_embedding ON blueprints USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100)'\n        @connection.run 'CREATE INDEX IF NOT EXISTS idx_blueprints_language ON blueprints(language)'\n        @connection.run 'CREATE INDEX IF NOT EXISTS idx_blueprints_created_at ON blueprints(created_at)'\n\n        @logger.success('✓ Basic schema created')\n      end\n\n      # Handle schema setup failure\n      #\n      # @param error [StandardError] Schema error\n      def handle_schema_failure(error)\n        puts \"\\n❌ Database Schema Setup Failed\"\n        puts \"Error: #{error.message}\"\n\n        continue_anyway = @prompt.yes?('Continue setup? (you can run migrations manually later)',\n                                       default: true)\n        return if continue_anyway\n\n        raise error\n      end\n\n      # Finalize database setup\n      def finalize_database_setup\n        @setup_data[:database] = {\n          url: @database_url,\n          configured: true,\n          pgvector_enabled: pgvector_available?,\n          schema_ready: true\n        }\n\n        @logger.success('Database setup completed!')\n        display_database_summary\n      end\n\n      # Check if pgvector is available\n      #\n      # @return [Boolean] True if pgvector is installed\n      def pgvector_available?\n        return false unless @connection\n\n        begin\n          result = @connection.fetch(\"SELECT * FROM pg_extension WHERE extname = 'vector'\").first\n          !result.nil?\n        rescue StandardError\n          false\n        end\n      end\n\n      # Display database configuration summary\n      def display_database_summary\n        puts \"\\n📊 Database Configuration Summary:\"\n\n        uri = URI.parse(@database_url)\n        puts \"  Host: #{uri.host}:#{uri.port}\"\n        puts \"  Database: #{uri.path[1..]}\"\n        puts \"  Username: #{uri.user}\"\n        puts \"  pgvector: #{pgvector_available? ? 'Enabled' : 'Disabled'}\"\n        puts ''\n      end\n\n      # Configure database connection (entry point)\n      def configure_database_connection\n        detect_existing_database unless @database_url\n      end\n\n      # Migrate categories schema from 'name' to 'title' column\n      def migrate_categories_schema\n        @logger.info('Checking for categories schema migration...')\n\n        begin\n          # Check if 'name' column exists (old schema)\n          name_exists = @connection.fetch(\n            \"SELECT column_name FROM information_schema.columns WHERE table_name = 'categories' AND column_name = 'name'\"\n          ).first\n\n          # Check if 'title' column exists (new schema)\n          title_exists = @connection.fetch(\n            \"SELECT column_name FROM information_schema.columns WHERE table_name = 'categories' AND column_name = 'title'\"\n          ).first\n\n          if name_exists && !title_exists\n            @logger.info('Migrating categories table: renaming \"name\" column to \"title\"')\n            @connection.run('ALTER TABLE categories RENAME COLUMN name TO title')\n            @logger.success('✓ Categories schema migration completed')\n          elsif title_exists\n            @logger.info('Categories schema is already up to date')\n          else\n            @logger.info('Categories table not found or has unexpected schema')\n          end\n        rescue StandardError => e\n          @logger.warn(\"Categories schema migration failed: #{e.message}\")\n          # Don't fail the entire setup for migration issues\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/setup/"
    },
    {
      "filename": "model_configurator.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\n\nmodule BlueprintsCLI\n  module Setup\n    # ModelConfigurator handles AI model discovery, selection, and configuration.\n    # It uses RubyLLM's model registry to discover available models from configured\n    # providers and helps users select appropriate models for different tasks.\n    class ModelConfigurator\n      # Model categories and their purposes\n      MODEL_CATEGORIES = {\n        chat: {\n          name: 'Chat Models',\n          description: 'For conversational AI, code generation, and general tasks',\n          required: true\n        },\n        embedding: {\n          name: 'Embedding Models',\n          description: 'For vector search and semantic similarity',\n          required: true\n        },\n        image: {\n          name: 'Image Generation Models',\n          description: 'For creating images from text descriptions',\n          required: false\n        }\n      }.freeze\n\n      # Initialize the model configurator\n      #\n      # @param prompt [TTY::Prompt] TTY prompt instance\n      # @param setup_data [Hash] Setup data storage\n      def initialize(prompt, setup_data)\n        @prompt = prompt\n        @setup_data = setup_data\n        @logger = BlueprintsCLI.logger\n        @available_models = {}\n        @selected_models = {}\n      end\n\n      # Discover and configure AI models\n      #\n      # @return [Boolean] True if model configuration completed successfully\n      def discover_and_configure\n        return false unless providers_configured?\n\n        @logger.info('Discovering available AI models...')\n\n        configure_rubyllm_from_setup\n        discover_models\n        display_model_summary\n        configure_model_preferences\n        finalize_model_configuration\n\n        true\n      end\n\n      private\n\n      # Check if AI providers are configured\n      #\n      # @return [Boolean] True if providers are available\n      def providers_configured?\n        if @setup_data[:providers]&.any?\n          true\n        else\n          @logger.failure('No AI providers configured. Please run provider setup first.')\n          false\n        end\n      end\n\n      # Configure RubyLLM with setup data\n      def configure_rubyllm_from_setup\n        @logger.info('Configuring RubyLLM with detected providers...')\n\n        RubyLLM.configure do |config|\n          @setup_data[:providers].each do |provider_key, provider_config|\n            case provider_key\n            when :openai\n              config.openai_api_key = provider_config[:api_key]\n            when :openrouter\n              config.openai_api_key = provider_config[:api_key]\n              config.openai_api_base = 'https://openrouter.ai/api/v1'\n            when :anthropic\n              config.anthropic_api_key = provider_config[:api_key]\n            when :gemini\n              config.gemini_api_key = provider_config[:api_key]\n            when :deepseek\n              config.deepseek_api_key = provider_config[:api_key]\n            end\n          end\n        end\n      end\n\n      # Discover available models from configured providers\n      def discover_models\n        @logger.info('Refreshing model registry...')\n        RubyLLM.models.refresh!\n\n        # Categorize available models\n        @available_models[:chat] = filter_chat_models\n        @available_models[:embedding] = filter_embedding_models\n        @available_models[:image] = filter_image_models\n\n        @logger.success('Model discovery completed!')\n      rescue StandardError => e\n        @logger.failure(\"Model discovery failed: #{e.message}\")\n        @logger.debug(e.backtrace.join(\"\\n\")) if ENV['DEBUG']\n        fallback_to_default_models\n      end\n\n      # Filter chat models from available providers\n      #\n      # @return [Array<Hash>] Available chat models with metadata\n      def filter_chat_models\n        provider_keys = @setup_data[:providers].keys\n\n        models = RubyLLM.models.chat_models.select do |model|\n          provider_symbol = model.provider.to_sym\n          # Map openrouter to openai for filtering\n          provider_symbol = :openrouter if provider_symbol == :openai &&\n                                           @setup_data[:providers].key?(:openrouter) &&\n                                           !@setup_data[:providers].key?(:openai)\n\n          provider_keys.include?(provider_symbol)\n        end\n\n        models.map do |model|\n          {\n            id: model.id,\n            name: model.name,\n            provider: model.provider,\n            context_window: model.context_window,\n            supports_vision: model.supports_vision?,\n            supports_tools: model.supports_functions?,\n            input_price: model.input_price_per_million,\n            output_price: model.output_price_per_million,\n            family: model.family\n          }\n        end\n      end\n\n      # Filter embedding models from available providers\n      #\n      # @return [Array<Hash>] Available embedding models with metadata\n      def filter_embedding_models\n        provider_keys = @setup_data[:providers].keys\n\n        models = RubyLLM.models.embedding_models.select do |model|\n          provider_symbol = model.provider.to_sym\n          provider_keys.include?(provider_symbol)\n        end\n\n        models.map do |model|\n          {\n            id: model.id,\n            name: model.name,\n            provider: model.provider,\n            dimensions: model.respond_to?(:dimensions) ? model.dimensions : 'Unknown',\n            input_price: model.input_price_per_million\n          }\n        end\n      end\n\n      # Filter image generation models from available providers\n      #\n      # @return [Array<Hash>] Available image models with metadata\n      def filter_image_models\n        provider_keys = @setup_data[:providers].keys\n\n        # NOTE: RubyLLM may not have a specific image_models filter\n        # This is a placeholder implementation\n        all_models = begin\n          RubyLLM.models.all.select do |model|\n            model.respond_to?(:type) &&\n              model.type == 'image' &&\n              provider_keys.include?(model.provider.to_sym)\n          end\n        rescue StandardError\n          []\n        end\n\n        all_models.map do |model|\n          {\n            id: model.id,\n            name: model.name,\n            provider: model.provider,\n            max_resolution: model.respond_to?(:max_resolution) ? model.max_resolution : 'Unknown'\n          }\n        end\n      end\n\n      # Display summary of discovered models\n      def display_model_summary\n        puts \"\\n📊 Model Discovery Summary:\"\n\n        MODEL_CATEGORIES.each do |category, info|\n          models = @available_models[category] || []\n          status = models.any? ? '✓' : '✗'\n          count = models.size\n\n          puts \"  #{status} #{info[:name]}: #{count} models available\"\n\n          if models.any? && count <= 5\n            models.each do |model|\n              provider_name = get_provider_display_name(model[:provider])\n              puts \"    - #{model[:name]} (#{provider_name})\"\n            end\n          elsif count > 5\n            puts \"    - #{models.first(3).map do |m|\n              m[:name]\n            end.join(', ')}, and #{count - 3} more...\"\n          end\n        end\n        puts ''\n      end\n\n      # Configure model preferences interactively\n      def configure_model_preferences\n        MODEL_CATEGORIES.each do |category, info|\n          models = @available_models[category] || []\n\n          if models.empty?\n            if info[:required]\n              @logger.warn(\"No #{info[:name].downcase} available. Some features may not work.\")\n            end\n            next\n          end\n\n          configure_category_models(category, info, models)\n        end\n      end\n\n      # Configure models for a specific category\n      #\n      # @param category [Symbol] Model category\n      # @param info [Hash] Category information\n      # @param models [Array] Available models for category\n      def configure_category_models(category, info, models)\n        puts \"\\n🤖 #{info[:name]} Configuration\"\n        puts \"Purpose: #{info[:description]}\"\n\n        if models.size == 1\n          # Auto-select single model\n          model = models.first\n          @selected_models[category] = model\n          @logger.info(\"Auto-selected: #{model[:name]} (#{model[:provider]})\")\n          return\n        end\n\n        # Group models by provider\n        models_by_provider = group_models_by_provider(models)\n\n        if models_by_provider.size == 1\n          # Only one provider, show models directly\n          provider_key = models_by_provider.keys.first\n          select_model_from_provider(category, info, provider_key, models_by_provider[provider_key])\n        else\n          # Multiple providers, let user choose provider first\n          select_model_with_provider_separation(category, info, models_by_provider)\n        end\n\n        # Show additional model info\n        return unless @selected_models[category]\n\n        display_model_details(@selected_models[category]) if @prompt.yes?('Show model details?',\n                                                                          default: false)\n      end\n\n      # Group models by provider for organized selection\n      #\n      # @param models [Array] Available models\n      # @return [Hash] Models grouped by provider\n      def group_models_by_provider(models)\n        models.group_by { |model| model[:provider] }\n      end\n\n      # Select model when only one provider is available\n      #\n      # @param category [Symbol] Model category\n      # @param info [Hash] Category information\n      # @param provider [String] Provider name\n      # @param provider_models [Array] Models from this provider\n      def select_model_from_provider(category, info, provider, provider_models)\n        provider_name = get_provider_display_name(provider)\n        puts \"\\nAvailable #{info[:name].downcase} from #{provider_name}:\"\n\n        choices = build_model_choices(provider_models)\n\n        selected = @prompt.select(\n          \"Choose #{info[:name].downcase}:\",\n          choices,\n          cycle: true,\n          filter: true,\n          help: '(Use ↑/↓ arrows to navigate, Enter to select, type to filter)'\n        )\n\n        @selected_models[category] = selected\n      end\n\n      # Select model with provider separation for multiple providers\n      #\n      # @param category [Symbol] Model category\n      # @param info [Hash] Category information\n      # @param models_by_provider [Hash] Models grouped by provider\n      def select_model_with_provider_separation(category, info, models_by_provider)\n        # First, let user choose provider\n        provider_choices = models_by_provider.map do |provider, provider_models|\n          provider_name = get_provider_display_name(provider)\n          model_count = provider_models.size\n          {\n            name: \"#{provider_name} (#{model_count} models)\",\n            value: provider\n          }\n        end\n\n        selected_provider = @prompt.select(\n          \"Choose AI provider for #{info[:name].downcase}:\",\n          provider_choices,\n          cycle: true,\n          help: '(Use ↑/↓ arrows to navigate, Enter to select)'\n        )\n\n        # Then select model from chosen provider\n        select_model_from_provider(category, info, selected_provider,\n                                   models_by_provider[selected_provider])\n      end\n\n      # Build model choices with pricing and capability info\n      #\n      # @param models [Array] Models to build choices for\n      # @return [Array] Formatted choices for TTY::Prompt\n      def build_model_choices(models)\n        models.map do |model|\n          price_info = if model[:input_price]\n                         \" ($#{model[:input_price]}/1M tokens)\"\n                       else\n                         ''\n                       end\n\n          # Add capability indicators\n          capabilities = []\n          capabilities << '👁️' if model[:supports_vision]\n          capabilities << '🔧' if model[:supports_tools]\n          capability_info = capabilities.any? ? \" #{capabilities.join(' ')}\" : ''\n\n          description = \"#{model[:name]}#{price_info}#{capability_info}\"\n          { name: description, value: model }\n        end\n      end\n\n      # Display detailed information about a model\n      #\n      # @param model [Hash] Model information\n      def display_model_details(model)\n        puts \"\\n📋 Model Details:\"\n        puts \"  ID: #{model[:id]}\"\n        puts \"  Provider: #{model[:provider]}\"\n\n        if model[:context_window]\n          formatted_window = model[:context_window].to_s.reverse.gsub(/(\\d{3})(?=\\d)/,\n                                                                      '\\\\1,').reverse\n          puts \"  Context Window: #{formatted_window} tokens\"\n        end\n\n        puts '  Vision Support: Yes' if model[:supports_vision]\n\n        puts '  Function Calling: Yes' if model[:supports_tools]\n\n        puts \"  Input Cost: $#{model[:input_price]}/1M tokens\" if model[:input_price]\n\n        puts \"  Output Cost: $#{model[:output_price]}/1M tokens\" if model[:output_price]\n\n        puts ''\n      end\n\n      # Finalize model configuration\n      def finalize_model_configuration\n        @setup_data[:models] = {}\n\n        @selected_models.each do |category, model|\n          @setup_data[:models][category] = {\n            id: model[:id],\n            name: model[:name],\n            provider: model[:provider],\n            capabilities: extract_model_capabilities(model)\n          }\n        end\n\n        # Set default models for AI configuration\n        if @selected_models[:chat]\n          @setup_data[:ai] ||= {}\n          @setup_data[:ai][:default_model] = @selected_models[:chat][:id]\n          @setup_data[:ai][:default_provider] = @selected_models[:chat][:provider]\n        end\n\n        if @selected_models[:embedding]\n          @setup_data[:ai] ||= {}\n          @setup_data[:ai][:default_embedding_model] = @selected_models[:embedding][:id]\n        end\n\n        @logger.success('Model configuration completed!')\n        display_final_model_summary\n      end\n\n      # Extract capabilities from model information\n      #\n      # @param model [Hash] Model information\n      # @return [Array<String>] List of capabilities\n      def extract_model_capabilities(model)\n        capabilities = []\n        capabilities << 'vision' if model[:supports_vision]\n        capabilities << 'tools' if model[:supports_tools]\n        capabilities << 'embedding' if model[:dimensions]\n        capabilities\n      end\n\n      # Display final model configuration summary\n      def display_final_model_summary\n        puts \"\\n✅ Selected Models:\"\n        @selected_models.each do |category, model|\n          provider_name = get_provider_display_name(model[:provider])\n          puts \"  #{category.to_s.capitalize}: #{model[:name]} (#{provider_name})\"\n        end\n        puts ''\n      end\n\n      # Fallback to default models if discovery fails\n      def fallback_to_default_models\n        @logger.warn('Using fallback default models...')\n\n        primary_provider = @setup_data[:primary_provider]\n        @setup_data[:providers][primary_provider]\n\n        case primary_provider\n        when :openai, :openrouter\n          @available_models[:chat] = [{\n            id: 'gpt-4o-mini',\n            name: 'GPT-4o Mini',\n            provider: 'openai',\n            supports_vision: true,\n            supports_tools: true\n          }]\n          @available_models[:embedding] = [{\n            id: 'text-embedding-3-small',\n            name: 'Text Embedding 3 Small',\n            provider: 'openai'\n          }]\n        when :anthropic\n          @available_models[:chat] = [{\n            id: 'claude-3-haiku-20240307',\n            name: 'Claude 3 Haiku',\n            provider: 'anthropic',\n            supports_tools: true\n          }]\n        when :gemini\n          @available_models[:chat] = [{\n            id: 'gemini-2.0-flash',\n            name: 'Gemini 2.0 Flash',\n            provider: 'gemini',\n            supports_vision: true,\n            supports_tools: true\n          }]\n          @available_models[:embedding] = [{\n            id: 'text-embedding-004',\n            name: 'Text Embedding 004',\n            provider: 'gemini'\n          }]\n        when :deepseek\n          @available_models[:chat] = [{\n            id: 'deepseek-chat',\n            name: 'DeepSeek Chat',\n            provider: 'deepseek',\n            supports_tools: true\n          }]\n        end\n\n        @available_models[:image] = []\n      end\n\n      # Get display name for a provider, handling mismatches safely\n      #\n      # @param provider [String, Symbol] Provider identifier from model\n      # @return [String] Human-readable provider name\n      def get_provider_display_name(provider)\n        provider_key = map_provider_to_key(provider)\n\n        if @setup_data[:providers] && @setup_data[:providers][provider_key]\n          @setup_data[:providers][provider_key][:name]\n        else\n          # Fallback to capitalized provider name\n          provider.to_s.capitalize\n        end\n      end\n\n      # Map model provider to setup data key\n      #\n      # @param provider [String, Symbol] Provider from model\n      # @return [Symbol] Provider key for setup data\n      def map_provider_to_key(provider)\n        case provider.to_s.downcase\n        when 'openai'\n          # Could be either openai or openrouter\n          if @setup_data[:providers]&.key?(:openrouter) && !@setup_data[:providers]&.key?(:openai)\n            :openrouter\n          else\n            :openai\n          end\n        when 'google', 'gemini'\n          :gemini\n        when 'anthropic'\n          :anthropic\n        when 'deepseek'\n          :deepseek\n        else\n          provider.to_sym\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/setup/"
    },
    {
      "filename": "provider_detector.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'ruby_llm'\n\nmodule BlueprintsCLI\n  module Setup\n    # ProviderDetector handles AI provider detection, configuration, and testing.\n    # It scans environment variables for API keys, guides users through provider\n    # selection, and tests connections to ensure providers are working correctly.\n    class ProviderDetector\n      # Provider information including environment variables and capabilities\n      PROVIDERS = {\n        openai: {\n          name: 'OpenAI',\n          env_vars: %w[OPENAI_API_KEY],\n          description: 'Industry-leading GPT models with excellent performance',\n          models: ['gpt-4o', 'gpt-4o-mini', 'gpt-3.5-turbo'],\n          capabilities: %w[chat embedding image_generation tools],\n          pricing: 'Mid-range',\n          notes: 'Direct OpenAI API access'\n        },\n        openrouter: {\n          name: 'OpenRouter',\n          env_vars: %w[OPENROUTER_API_KEY],\n          description: 'Access to multiple providers through single API',\n          models: ['gpt-4o', 'claude-3-5-sonnet', 'llama-3.1-70b'],\n          capabilities: %w[chat embedding],\n          pricing: 'Variable by model',\n          notes: 'Unified access to multiple AI providers'\n        },\n        anthropic: {\n          name: 'Anthropic',\n          env_vars: %w[ANTHROPIC_API_KEY],\n          description: 'Claude models known for safety and reasoning',\n          models: ['claude-3-5-sonnet', 'claude-3-haiku', 'claude-3-opus'],\n          capabilities: %w[chat tools],\n          pricing: 'Mid-range',\n          notes: 'Direct Anthropic API access'\n        },\n        gemini: {\n          name: 'Google Gemini',\n          env_vars: %w[GEMINI_API_KEY GOOGLE_API_KEY],\n          description: 'Google\\'s multimodal AI with competitive pricing',\n          models: ['gemini-2.0-flash', 'gemini-1.5-pro', 'gemini-1.5-flash'],\n          capabilities: %w[chat embedding image_generation tools vision],\n          pricing: 'Low-cost',\n          notes: 'Excellent for cost-conscious applications'\n        },\n        deepseek: {\n          name: 'DeepSeek',\n          env_vars: %w[DEEPSEEK_API_KEY],\n          description: 'High-performance reasoning models at low cost',\n          models: %w[deepseek-chat deepseek-coder],\n          capabilities: %w[chat tools],\n          pricing: 'Very low-cost',\n          notes: 'Excellent reasoning capabilities'\n        }\n      }.freeze\n\n      # Initialize the provider detector\n      #\n      # @param prompt [TTY::Prompt] TTY prompt instance\n      # @param setup_data [Hash] Setup data storage\n      def initialize(prompt, setup_data)\n        @prompt = prompt\n        @setup_data = setup_data\n        @logger = BlueprintsCLI.logger\n        @detected_providers = {}\n      end\n\n      # Detect available providers and guide user through configuration\n      #\n      # @return [Boolean] True if at least one provider was configured\n      def detect_and_configure\n        @logger.info('Scanning for AI provider API keys...')\n\n        scan_environment_variables\n        display_detected_providers\n\n        if @detected_providers.any?\n          configure_detected_providers\n        else\n          guide_manual_configuration\n        end\n\n        finalize_provider_configuration\n      end\n\n      private\n\n      # Scan environment variables for provider API keys\n      def scan_environment_variables\n        PROVIDERS.each do |provider_key, provider_info|\n          provider_info[:env_vars].each do |env_var|\n            next unless ENV[env_var] && !ENV[env_var].empty?\n\n            @detected_providers[provider_key] = {\n              info: provider_info,\n              api_key: ENV.fetch(env_var, nil),\n              env_var: env_var\n            }\n            @logger.success(\"Found #{provider_info[:name]} API key (#{env_var})\")\n            break # Use first found key for this provider\n          end\n        end\n      end\n\n      # Display information about detected providers\n      def display_detected_providers\n        if @detected_providers.any?\n          puts \"\\n🔍 Detected AI Providers:\"\n          @detected_providers.each_value do |config|\n            info = config[:info]\n            puts \"  ✓ #{info[:name]} - #{info[:description]}\"\n            puts \"    Models: #{info[:models].join(', ')}\"\n            puts \"    Pricing: #{info[:pricing]}\"\n            puts ''\n          end\n        else\n          puts \"\\n❌ No AI provider API keys found in environment variables.\"\n          puts \"Don't worry! We'll help you configure providers manually.\"\n        end\n      end\n\n      # Configure detected providers\n      #\n      # @return [Boolean] True if configuration completed\n      def configure_detected_providers\n        selected_providers = {}\n\n        if @detected_providers.size == 1\n          # Auto-select single provider\n          provider_key = @detected_providers.keys.first\n          selected_providers[provider_key] = @detected_providers[provider_key]\n          @logger.info(\"Auto-selecting #{@detected_providers[provider_key][:info][:name]}\")\n        else\n          # Let user choose from detected providers\n          selected_providers = prompt_provider_selection\n        end\n\n        configure_providers(selected_providers)\n      end\n\n      # Prompt user to select from detected providers\n      #\n      # @return [Hash] Selected providers configuration\n      def prompt_provider_selection\n        selected = {}\n\n        puts \"\\n🤖 Multiple AI providers detected. Choose which ones to configure:\"\n\n        @detected_providers.each do |provider_key, config|\n          info = config[:info]\n          use_provider = @prompt.yes?(\"Configure #{info[:name]}?\", default: true)\n\n          next unless use_provider\n\n          selected[provider_key] = config\n\n          # Test the provider connection\n          if test_provider_connection(provider_key, config[:api_key])\n            @logger.success(\"#{info[:name]} connection verified!\")\n          else\n            @logger.failure(\"#{info[:name]} connection failed\")\n            use_anyway = @prompt.yes?(\"Continue with #{info[:name]} anyway?\", default: false)\n            selected.delete(provider_key) unless use_anyway\n          end\n        end\n\n        selected\n      end\n\n      # Guide user through manual provider configuration\n      #\n      # @return [Boolean] True if manual configuration completed\n      def guide_manual_configuration\n        puts \"\\n🔧 Manual Provider Configuration\"\n        puts 'Please choose an AI provider to configure:'\n\n        # Display all available providers\n        provider_choices = PROVIDERS.map do |key, info|\n          { name: \"#{info[:name]} - #{info[:description]}\", value: key }\n        end\n        provider_choices << { name: 'Skip provider setup for now', value: :skip }\n\n        selected_provider = @prompt.select('Select a provider:', provider_choices)\n        return true if selected_provider == :skip\n\n        configure_manual_provider(selected_provider)\n      end\n\n      # Configure a provider manually\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @return [Boolean] True if configuration completed\n      def configure_manual_provider(provider_key)\n        provider_info = PROVIDERS[provider_key]\n\n        puts \"\\n📋 Configuring #{provider_info[:name]}\"\n        puts \"Description: #{provider_info[:description]}\"\n        puts \"Required environment variable: #{provider_info[:env_vars].first}\"\n        puts ''\n\n        api_key = @prompt.mask(\"Enter your #{provider_info[:name]} API key:\")\n\n        if api_key.empty?\n          @logger.warn(\"No API key provided for #{provider_info[:name]}\")\n          return false\n        end\n\n        # Test the connection\n        if test_provider_connection(provider_key, api_key)\n          @logger.success(\"#{provider_info[:name]} connection verified!\")\n          store_manual_provider(provider_key, api_key)\n          true\n        else\n          @logger.failure(\"Failed to connect to #{provider_info[:name]}\")\n          retry_config = @prompt.yes?('Retry configuration?', default: true)\n          retry_config ? configure_manual_provider(provider_key) : false\n        end\n      end\n\n      # Store manually configured provider\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @param api_key [String] API key\n      def store_manual_provider(provider_key, api_key)\n        @detected_providers[provider_key] = {\n          info: PROVIDERS[provider_key],\n          api_key: api_key,\n          env_var: PROVIDERS[provider_key][:env_vars].first\n        }\n      end\n\n      # Test provider connection\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @param api_key [String] API key to test\n      # @return [Boolean] True if connection successful\n      def test_provider_connection(provider_key, api_key)\n        @logger.info(\"Testing #{PROVIDERS[provider_key][:name]} connection...\")\n\n        # Configure RubyLLM for testing\n        original_config = backup_rubyllm_config\n        configure_rubyllm_for_test(provider_key, api_key)\n\n        begin\n          # Simple test request\n          chat = RubyLLM.chat(\n            model: get_test_model(provider_key),\n            provider: map_provider_for_rubyllm(provider_key)\n          )\n          response = chat.ask(\"Hello! Please respond with just 'OK'\")\n\n          success = response&.content&.include?('OK')\n          @logger.debug(\"Test response: #{response&.content}\") if ENV['DEBUG']\n          success\n        rescue StandardError => e\n          @logger.debug(\"Connection test failed: #{e.message}\") if ENV['DEBUG']\n          false\n        ensure\n          restore_rubyllm_config(original_config)\n        end\n      end\n\n      # Get appropriate test model for provider\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @return [String] Model name for testing\n      def get_test_model(provider_key)\n        case provider_key\n        when :openai, :openrouter\n          'gpt-4o-mini'\n        when :anthropic\n          'claude-3-haiku-20240307'\n        when :gemini\n          'gemini-2.0-flash'\n        when :deepseek\n          'deepseek-chat'\n        else\n          'gpt-4o-mini'\n        end\n      end\n\n      # Map provider key to RubyLLM provider format\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @return [Symbol] RubyLLM provider symbol\n      def map_provider_for_rubyllm(provider_key)\n        case provider_key\n        when :openrouter\n          :openai # OpenRouter uses OpenAI API format\n        else\n          provider_key\n        end\n      end\n\n      # Configure RubyLLM for testing\n      #\n      # @param provider_key [Symbol] Provider identifier\n      # @param api_key [String] API key\n      def configure_rubyllm_for_test(provider_key, api_key)\n        RubyLLM.configure do |config|\n          case provider_key\n          when :openai\n            config.openai_api_key = api_key\n          when :openrouter\n            config.openai_api_key = api_key\n            config.openai_api_base = 'https://openrouter.ai/api/v1'\n          when :anthropic\n            config.anthropic_api_key = api_key\n          when :gemini\n            config.gemini_api_key = api_key\n          when :deepseek\n            config.deepseek_api_key = api_key\n          end\n        end\n      end\n\n      # Backup current RubyLLM configuration\n      #\n      # @return [Hash] Current configuration\n      def backup_rubyllm_config\n        {\n          openai_api_key: RubyLLM.config.openai_api_key,\n          openai_api_base: RubyLLM.config.openai_api_base,\n          anthropic_api_key: RubyLLM.config.anthropic_api_key,\n          gemini_api_key: RubyLLM.config.gemini_api_key,\n          deepseek_api_key: RubyLLM.config.deepseek_api_key\n        }\n      end\n\n      # Restore RubyLLM configuration\n      #\n      # @param config [Hash] Configuration to restore\n      def restore_rubyllm_config(config)\n        RubyLLM.configure do |rubyllm_config|\n          config.each do |key, value|\n            rubyllm_config.public_send(\"#{key}=\", value) if value\n          end\n        end\n      end\n\n      # Configure selected providers\n      #\n      # @param providers [Hash] Selected providers configuration\n      def configure_providers(providers)\n        @setup_data[:providers] = {}\n\n        providers.each do |provider_key, config|\n          @setup_data[:providers][provider_key] = {\n            name: config[:info][:name],\n            api_key: config[:api_key],\n            env_var: config[:env_var],\n            capabilities: config[:info][:capabilities],\n            models: config[:info][:models]\n          }\n        end\n      end\n\n      # Finalize provider configuration\n      #\n      # @return [Boolean] True if at least one provider configured\n      def finalize_provider_configuration\n        if @setup_data[:providers]&.any?\n          # Select primary provider\n          if @setup_data[:providers].size == 1\n            primary_provider = @setup_data[:providers].keys.first\n          else\n            choices = @setup_data[:providers].map do |key, config|\n              { name: config[:name], value: key }\n            end\n            primary_provider = @prompt.select('Select primary AI provider:', choices)\n          end\n\n          @setup_data[:primary_provider] = primary_provider\n          @logger.success('Provider configuration completed!')\n          @logger.info(\"Primary provider: #{@setup_data[:providers][primary_provider][:name]}\")\n\n          true\n        else\n          @logger.warn('No AI providers configured. Some features may not work.')\n          false\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/setup/"
    },
    {
      "filename": "setup_manager.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-prompt'\nrequire 'tty-box'\n\nmodule BlueprintsCLI\n  module Setup\n    # SetupManager orchestrates the complete first-time setup process for BlueprintsCLI.\n    # It guides users through provider configuration, database setup, and application preferences.\n    #\n    # @example Run complete setup\n    #   setup = BlueprintsCLI::Setup::SetupManager.new\n    #   setup.run\n    #\n    # @example Run specific setup steps\n    #   setup = BlueprintsCLI::Setup::SetupManager.new\n    #   setup.setup_providers\n    #   setup.setup_database\n    class SetupManager\n      # Error raised when setup is cancelled by user\n      SetupCancelledError = Class.new(StandardError)\n\n      # Error raised when setup validation fails\n      SetupValidationError = Class.new(StandardError)\n\n      # Initialize the setup manager\n      #\n      # @param prompt [TTY::Prompt] Optional prompt instance for testing\n      # @param config [BlueprintsCLI::Configuration] Optional configuration instance\n      def initialize(prompt: nil, config: nil)\n        @prompt = prompt || TTY::Prompt.new\n        @config = config || BlueprintsCLI::Configuration.new(auto_load: false)\n        @setup_data = {}\n        @logger = BlueprintsCLI.logger\n      end\n\n      # Run the complete setup process\n      #\n      # @return [Boolean] True if setup completed successfully\n      def run\n        display_welcome\n        return false unless confirm_continue\n\n        begin\n          run_setup_phases\n          display_completion\n          true\n        rescue SetupCancelledError\n          display_cancellation\n          false\n        rescue StandardError => e\n          handle_setup_error(e)\n          false\n        end\n      end\n\n      # Run only the provider setup phase\n      #\n      # @return [Boolean] True if provider setup completed successfully\n      def setup_providers\n        @logger.step('Setting up AI providers...')\n        provider_detector = ProviderDetector.new(@prompt, @setup_data)\n        provider_detector.detect_and_configure\n      end\n\n      # Run only the database setup phase\n      #\n      # @return [Boolean] True if database setup completed successfully\n      def setup_database\n        @logger.step('Setting up database...')\n        database_setup = DatabaseSetup.new(@prompt, @setup_data)\n        database_setup.configure_and_test\n      end\n\n      # Run only the model configuration phase\n      #\n      # @return [Boolean] True if model configuration completed successfully\n      def setup_models\n        @logger.step('Configuring AI models...')\n        model_configurator = ModelConfigurator.new(@prompt, @setup_data)\n        model_configurator.discover_and_configure\n      end\n\n      # Generate and save the final configuration\n      #\n      # @return [Boolean] True if configuration was saved successfully\n      def generate_config\n        @logger.step('Generating configuration...')\n        config_generator = ConfigGenerator.new(@config, @setup_data)\n        config_generator.generate_and_save\n      end\n\n      # Check if this is a first-time setup\n      #\n      # @return [Boolean] True if no configuration exists\n      def first_time_setup?\n        !@config.exist? || missing_critical_config?\n      end\n\n      # Check if setup is required\n      #\n      # @return [Boolean] True if setup should be run\n      def setup_required?\n        first_time_setup? || @prompt.yes?('Configuration exists. Run setup anyway?')\n      end\n\n      private\n\n      # Display welcome message with ASCII art\n      def display_welcome\n        welcome_box = TTY::Box.frame(\n          \"🚀 Welcome to BlueprintsCLI Setup! 🚀\\n\\n\" \\\n          \"This wizard will guide you through the initial configuration\\n\" \\\n          \"including AI providers, database setup, and preferences.\\n\\n\" \\\n          'Setup typically takes 2-5 minutes.',\n          padding: 1,\n          align: :center,\n          style: { border: { fg: :cyan } }\n        )\n        puts welcome_box\n      end\n\n      # Confirm user wants to continue with setup\n      #\n      # @return [Boolean] True if user confirms\n      def confirm_continue\n        if first_time_setup?\n          @prompt.yes?('Ready to begin setup?', default: true)\n        else\n          @prompt.yes?('Existing configuration found. Overwrite?', default: false)\n        end\n      end\n\n      # Run all setup phases in order\n      def run_setup_phases\n        phases = [\n          { name: 'Prerequisites Check', method: :check_prerequisites },\n          { name: 'AI Providers', method: :setup_providers },\n          { name: 'Model Configuration', method: :setup_models },\n          { name: 'Database Setup', method: :setup_database },\n          { name: 'Application Preferences', method: :setup_preferences },\n          { name: 'Configuration Generation', method: :generate_config },\n          { name: 'Setup Verification', method: :verify_setup }\n        ]\n\n        phases.each_with_index do |phase, index|\n          @logger.step(\"Phase #{index + 1}/#{phases.length}: #{phase[:name]}\")\n\n          success = send(phase[:method])\n          raise SetupValidationError, \"Setup failed at phase: #{phase[:name]}\" unless success\n\n          display_phase_completion(phase[:name])\n        end\n      end\n\n      # Check system prerequisites\n      #\n      # @return [Boolean] True if prerequisites are met\n      def check_prerequisites\n        @logger.info('Checking Ruby version...')\n        ruby_version = RUBY_VERSION\n        @logger.success(\"Ruby #{ruby_version} detected\")\n\n        @logger.info('Checking required gems...')\n        required_gems = %w[tty-prompt tty-config ruby_llm sequel pg]\n\n        required_gems.each do |gem_name|\n          require gem_name.tr('-', '/')\n          @logger.success(\"✓ #{gem_name}\")\n        rescue LoadError\n          @logger.failure(\"✗ #{gem_name} (please run: bundle install)\")\n          return false\n        end\n\n        true\n      end\n\n      # Setup application preferences\n      #\n      # @return [Boolean] True if preferences setup completed\n      def setup_preferences\n        @logger.info('Configuring application preferences...')\n\n        # Editor preference\n        current_editor = ENV['EDITOR'] || ENV['VISUAL'] || 'vim'\n        editor = @prompt.ask('Default editor:', default: current_editor)\n        @setup_data[:editor] = { default: editor, auto_save: true }\n\n        # Logging preferences\n        log_level = @prompt.select('Console log level:', %w[debug info warn error])\n        file_logging = @prompt.yes?('Enable file logging?', default: true)\n\n        @setup_data[:logger] = {\n          level: log_level,\n          file_logging: file_logging,\n          context_enabled: true,\n          context_detail_level: 'full'\n        }\n\n        # UI preferences\n        colors = @prompt.yes?('Enable colored output?', default: true)\n        interactive = @prompt.yes?('Enable interactive prompts?', default: true)\n\n        @setup_data[:ui] = {\n          colors: colors,\n          interactive: interactive,\n          pager: 'most'\n        }\n\n        true\n      end\n\n      # Verify the complete setup\n      #\n      # @return [Boolean] True if verification passes\n      def verify_setup\n        @logger.info('Verifying setup...')\n\n        # Test database connection\n        if @setup_data[:database]\n          @logger.info('Testing database connection...')\n          # Database verification logic here\n          @logger.success('Database connection verified')\n        end\n\n        # Test AI provider connections\n        if @setup_data[:providers]\n          @logger.info('Testing AI provider connections...')\n          @setup_data[:providers].each do |provider, config|\n            next unless config[:api_key]\n\n            @logger.info(\"Testing #{provider} connection...\")\n            # Provider verification logic here\n            @logger.success(\"#{provider} connection verified\")\n          end\n        end\n\n        @logger.success('Setup verification completed!')\n        true\n      end\n\n      # Display phase completion message\n      #\n      # @param phase_name [String] Name of completed phase\n      def display_phase_completion(phase_name)\n        @logger.success(\"✓ #{phase_name} completed\")\n        puts # Add spacing\n      end\n\n      # Display setup completion message\n      def display_completion\n        completion_box = TTY::Box.frame(\n          \"🎉 Setup Complete! 🎉\\n\\n\" \\\n          \"BlueprintsCLI has been successfully configured.\\n\" \\\n          \"You can now start using the application.\\n\\n\" \\\n          \"Next steps:\\n\" \\\n          \"• Run 'bin/blueprintsCLI' to access the interactive menu\\n\" \\\n          \"• Try 'bin/blueprintsCLI blueprint list' to see existing blueprints\\n\" \\\n          '• Visit the documentation for more features',\n          padding: 1,\n          align: :center,\n          style: { border: { fg: :green } }\n        )\n        puts completion_box\n      end\n\n      # Display setup cancellation message\n      def display_cancellation\n        @logger.info('Setup cancelled by user.')\n        puts 'You can run setup again anytime with: bin/blueprintsCLI setup'\n      end\n\n      # Handle setup errors\n      #\n      # @param error [StandardError] The error that occurred\n      def handle_setup_error(error)\n        @logger.failure(\"Setup failed: #{error.message}\")\n        @logger.debug(error.backtrace.join(\"\\n\")) if ENV['DEBUG']\n\n        puts \"\\nSetup encountered an error. Please check the logs and try again.\"\n        puts 'If the problem persists, please create an issue at:'\n        puts 'https://github.com/your-org/blueprintsCLI/issues'\n      end\n\n      # Check if critical configuration is missing\n      #\n      # @return [Boolean] True if critical config is missing\n      def missing_critical_config?\n        return true unless @config.exist?\n\n        # Check for essential configuration\n        required_keys = [\n          %i[database url],\n          %i[ai sublayer provider]\n        ]\n\n        required_keys.any? do |keys|\n          @config.fetch(*keys).nil?\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/setup/"
    },
    {
      "filename": "simple_enhanced_menu.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative 'slash_command_parser'\n\nmodule BlueprintsCLI\n  # SimpleEnhancedMenu provides slash command functionality without CLI-UI conflicts\n  class SimpleEnhancedMenu\n    def initialize\n      @running = true\n    end\n\n    # Start the enhanced interactive session\n    def start\n      show_welcome_banner\n\n      loop do\n        break unless @running\n\n        begin\n          handle_user_input\n        rescue Interrupt, EOFError\n          handle_exit\n          break\n        rescue StandardError => e\n          puts \"\\e[31mError: #{e.message}\\e[0m\"\n          BlueprintsCLI.logger.error(\"Enhanced menu error: #{e.message}\")\n        end\n      end\n    end\n\n    private\n\n    def show_welcome_banner\n      puts \"\\e[36m#{'=' * 70}\\e[0m\"\n      puts \"\\e[36m🚀 BlueprintsCLI Enhanced Interactive Mode\\e[0m\"\n      puts \"\\e[36m#{'=' * 70}\\e[0m\"\n      puts ''\n      puts \"\\e[32mWelcome to BlueprintsCLI!\\e[0m\"\n      puts ''\n      puts \"\\e[33m💡 Tips:\\e[0m\"\n      puts \"  • Use slash commands: \\e[34m/blueprint submit\\e[0m, \\e[34m/search ruby\\e[0m\"\n      puts \"  • Type \\e[34m/help\\e[0m for available commands\"\n      puts \"  • Type \\e[34m/exit\\e[0m or press \\e[34mCtrl+C\\e[0m to quit\"\n      puts ''\n    end\n\n    def handle_user_input\n      # Get user input with support for slash commands\n      input = get_user_input\n\n      return if input.nil? || input.empty?\n\n      # Check if it's a slash command\n      parser = SlashCommandParser.new(input)\n\n      if parser.slash_command?\n        if parser.valid?\n          result = parser.execute\n          unless result\n            puts \"\\e[33mCommand failed or incomplete. Try \\e[34m/help\\e[0m for assistance.\\e[0m\"\n          end\n        else\n          handle_invalid_slash_command(parser)\n        end\n      else\n        # Handle regular text input (could be used for search, etc.)\n        handle_regular_input(input)\n      end\n    end\n\n    def get_user_input\n      # Custom prompt with slash command support\n      puts ''\n      print \"\\e[36mblueprintsCLI\\e[0m \\e[34m>\\e[0m \"\n\n      input = $stdin.gets\n      if input.nil?\n        # EOF reached, exit gracefully\n        @running = false\n        return nil\n      end\n\n      input.chomp.strip\n    end\n\n    def handle_invalid_slash_command(parser)\n      puts \"\\e[31mInvalid command: #{parser.input}\\e[0m\"\n\n      # Suggest completions if available\n      completions = parser.completions\n      if completions.any?\n        puts \"\\e[33mDid you mean:\\e[0m\"\n        completions.first(5).each do |completion|\n          puts \"  \\e[34m#{completion}\\e[0m\"\n        end\n      else\n        puts \"Type \\e[34m/help\\e[0m to see available commands.\"\n      end\n    end\n\n    def handle_regular_input(input)\n      # If it's not a slash command, treat it as a search query\n      if input.strip.length > 2\n        puts \"\\e[33mSearching for: \\\"#{input}\\\"...\\e[0m\"\n\n        begin\n          blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new({})\n          blueprint_command.execute('search', input)\n        rescue StandardError => e\n          puts \"\\e[31mSearch failed: #{e.message}\\e[0m\"\n        end\n      else\n        puts \"\\e[33mEnter a slash command or search term. Type \\e[34m/help\\e[0m for assistance.\\e[0m\"\n      end\n    end\n\n    def handle_exit\n      puts ''\n      puts \"\\e[32m👋 Thank you for using BlueprintsCLI!\\e[0m\"\n      @running = false\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "slash_command_parser.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  # SlashCommandParser handles parsing and execution of slash commands\n  # Supports commands like /blueprint submit, /config show, /search query, etc.\n  class SlashCommandParser\n    # Command registry with their handlers\n    COMMANDS = {\n      'blueprint' => {\n        description: 'Manage code blueprints',\n        subcommands: %w[submit list browse view edit delete search export generate config],\n        handler: :handle_blueprint_command\n      },\n      'config' => {\n        description: 'Manage configuration',\n        subcommands: %w[setup show edit validate reset help],\n        handler: :handle_config_command\n      },\n      'docs' => {\n        description: 'Generate documentation',\n        subcommands: %w[generate help],\n        handler: :handle_docs_command\n      },\n      'setup' => {\n        description: 'Run setup wizard',\n        subcommands: %w[wizard providers database models verify help],\n        handler: :handle_setup_command\n      },\n      'search' => {\n        description: 'Quick search blueprints',\n        subcommands: [],\n        handler: :handle_search_command\n      },\n      'help' => {\n        description: 'Show help information',\n        subcommands: [],\n        handler: :handle_help_command\n      },\n      'exit' => {\n        description: 'Exit the application',\n        subcommands: [],\n        handler: :handle_exit_command\n      },\n      'clear' => {\n        description: 'Clear the screen',\n        subcommands: [],\n        handler: :handle_clear_command\n      }\n    }.freeze\n\n    attr_reader :input, :command, :subcommand, :args, :options\n\n    def initialize(input)\n      @input = input.to_s.strip\n      @command = nil\n      @subcommand = nil\n      @args = []\n      @options = {}\n      parse_input\n    end\n\n    # Check if the input is a valid slash command\n    def slash_command?\n      @input.start_with?('/')\n    end\n\n    # Parse the input into command components\n    def parse_input\n      return unless slash_command?\n\n      # Remove leading slash and split into parts\n      parts = @input[1..].split(/\\s+/)\n      return if parts.empty?\n\n      @command = parts[0]\n      remaining_parts = parts[1..]\n\n      # Check if first remaining part is a subcommand\n      if remaining_parts.any? && COMMANDS.dig(@command, :subcommands)&.include?(remaining_parts[0])\n        @subcommand = remaining_parts[0]\n        remaining_parts = remaining_parts[1..]\n      end\n\n      # Parse remaining parts into args and options\n      parse_args_and_options(remaining_parts)\n    end\n\n    # Execute the parsed command\n    def execute\n      return false unless valid?\n\n      handler_method = COMMANDS.dig(@command, :handler)\n      return false unless handler_method\n\n      send(handler_method)\n    rescue StandardError => e\n      CLIUIIntegration.puts(\"{{red:Error executing command: #{e.message}}}\")\n      false\n    end\n\n    # Check if the parsed command is valid\n    def valid?\n      slash_command? && COMMANDS.key?(@command)\n    end\n\n    # Get completion suggestions for the current input\n    def completions\n      return [] unless slash_command?\n\n      if @command.nil? || @command.empty?\n        # Complete command names\n        return COMMANDS.keys.map { |cmd| \"/#{cmd}\" }\n      end\n\n      # Find matching commands\n      matching_commands = COMMANDS.keys.select { |cmd| cmd.start_with?(@command) }\n\n      if matching_commands.size == 1 && matching_commands.first == @command\n        # Complete subcommands\n        subcommands = COMMANDS.dig(@command, :subcommands) || []\n        return subcommands.map { |sub| \"/#{@command} #{sub}\" }\n      elsif matching_commands.size > 1\n        # Complete command names\n        return matching_commands.map { |cmd| \"/#{cmd}\" }\n      end\n\n      []\n    end\n\n    # Get help text for commands\n    def help_text(cmd = nil)\n      if cmd && COMMANDS.key?(cmd)\n        command_help(cmd)\n      else\n        all_commands_help\n      end\n    end\n\n    private\n\n    def parse_args_and_options(parts)\n      parts.each do |part|\n        if part.start_with?('--')\n          # Long option\n          key_value = part[2..].split('=', 2)\n          key = key_value[0]\n          value = key_value.size > 1 ? key_value[1] : true\n          @options[key] = value\n        elsif part.start_with?('-')\n          # Short option\n          @options[part[1..]] = true\n        else\n          # Argument\n          @args << part\n        end\n      end\n    end\n\n    # Command handlers\n    def handle_blueprint_command\n      blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(@options)\n      if @subcommand\n        blueprint_command.execute(@subcommand, *@args)\n      else\n        blueprint_command.execute('help')\n      end\n      true\n    end\n\n    def handle_config_command\n      config_command = BlueprintsCLI::Commands::ConfigCommand.new(@options)\n      if @subcommand\n        config_command.execute(@subcommand, *@args)\n      else\n        config_command.execute('show')\n      end\n      true\n    end\n\n    def handle_docs_command\n      docs_command = BlueprintsCLI::Commands::DocsCommand.new(@options)\n      if @subcommand\n        docs_command.execute(@subcommand, *@args)\n      else\n        docs_command.execute('help')\n      end\n      true\n    end\n\n    def handle_setup_command\n      setup_command = BlueprintsCLI::Commands::SetupCommand.new(@options)\n      if @subcommand\n        setup_command.execute(@subcommand, *@args)\n      else\n        setup_command.execute('wizard')\n      end\n      true\n    end\n\n    def handle_search_command\n      if @args.empty?\n        CLIUIIntegration.puts('{{yellow:Usage: /search <query>}}')\n        return false\n      end\n\n      query = @args.join(' ')\n      blueprint_command = BlueprintsCLI::Commands::BlueprintCommand.new(@options)\n      blueprint_command.execute('search', query)\n      true\n    end\n\n    def handle_help_command\n      if @args.empty?\n        CLIUIIntegration.puts(help_text)\n      else\n        CLIUIIntegration.puts(help_text(@args.first))\n      end\n      true\n    end\n\n    def handle_exit_command\n      CLIUIIntegration.puts('{{green:👋 Goodbye!}}')\n      exit(0)\n    end\n\n    def handle_clear_command\n      system('clear') || system('cls')\n      true\n    end\n\n    def command_help(cmd)\n      command_info = COMMANDS[cmd]\n      help = \"{{cyan:#{cmd.upcase}}} - #{command_info[:description]}\\n\\n\"\n\n      subcommands = command_info[:subcommands]\n      if subcommands.any?\n        help += \"{{yellow:Subcommands:}}\\n\"\n        subcommands.each do |sub|\n          help += \"  /#{cmd} #{sub}\\n\"\n        end\n      end\n\n      help += \"\\nExample: {{blue:/#{cmd}#{\" #{subcommands.first}\" if subcommands.first}}}\"\n      help\n    end\n\n    def all_commands_help\n      help = \"{{cyan:🚀 BlueprintsCLI Slash Commands}}\\n\\n\"\n      help += \"{{yellow:Available Commands:}}\\n\"\n\n      COMMANDS.each do |cmd, info|\n        help += \"  {{blue:/#{cmd}}} - #{info[:description]}\\n\"\n      end\n\n      help += \"\\n{{yellow:Tips:}}\\n\"\n      help += \"  • Type {{blue:/}} and press TAB for autocomplete\\n\"\n      help += \"  • Use {{blue:/help <command>}} for detailed help\\n\"\n      help += \"  • Use {{blue:/clear}} to clear the screen\\n\"\n      help += '  • Use {{blue:/exit}} to quit the application'\n\n      help\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "cli_ui_viewer.rb",
      "content": "# frozen_string_literal: true\n\nrequire_relative '../cli_ui_integration'\nrequire_relative '../slash_command_parser'\n\nmodule BlueprintsCLI\n  module UI\n    # CLIUIViewer provides an enhanced blueprint viewing experience using CLI::UI\n    # with metadata/details on the left and scrollable code on the right\n    class CLIUIViewer\n      ACTIONS = {\n        'edit' => '✏️  Edit blueprint',\n        'preview' => '👀 Preview improvements',\n        'docs' => '📚 Generate documentation',\n        'export' => '💾 Export code',\n        'copy' => '📋 Copy to clipboard',\n        'analyze' => '🤖 AI analysis',\n        'back' => '⬅️  Back to list',\n        'quit' => '❌ Quit'\n      }.freeze\n\n      def initialize(blueprint, with_suggestions: false)\n        @blueprint = blueprint\n        @with_suggestions = with_suggestions\n        @code_scroll_position = 0\n        @code_lines = @blueprint[:code].split(\"\\n\")\n        @lines_per_page = 20 # Show 20 lines at a time\n\n        CLIUIIntegration.initialize!\n      end\n\n      # Display the CLI::UI based view\n      def display\n        show_blueprint_header\n        show_details_section\n        show_code_section\n        show_actions_menu\n        handle_interactions\n      end\n\n      private\n\n      def show_blueprint_header\n        CLIUIIntegration.frame(\"📋 Blueprint: #{@blueprint[:name]}\", color: :cyan) do\n          CLIUIIntegration.puts(\"{{blue:ID: #{@blueprint[:id]}}} | {{green:Language: #{@blueprint[:language] || 'Unknown'}}} | {{yellow:Size: #{@blueprint[:code].length} chars}}\")\n        end\n        CLIUIIntegration.puts('')\n      end\n\n      def show_details_section\n        CLIUIIntegration.frame('📋 Blueprint Details', color: :blue) do\n          show_metadata_info\n          CLIUIIntegration.puts('')\n          show_language_info\n          CLIUIIntegration.puts('')\n          show_description\n          CLIUIIntegration.puts('')\n          show_categories\n\n          if @blueprint[:ai_suggestions]\n            CLIUIIntegration.puts('')\n            show_ai_suggestions\n          end\n        end\n        CLIUIIntegration.puts('')\n      end\n\n      def show_metadata_info\n        CLIUIIntegration.puts(\"{{bold:📅 Created:}} #{format_date(@blueprint[:created_at])}\")\n        CLIUIIntegration.puts(\"{{bold:🔄 Updated:}} #{format_date(@blueprint[:updated_at])}\")\n        CLIUIIntegration.puts(\"{{bold:📏 Size:}} #{@blueprint[:code].length} characters\")\n      end\n\n      def show_language_info\n        CLIUIIntegration.puts(\"{{bold:🔤 Language:}} {{green:#{@blueprint[:language] || 'Unknown'}}}\")\n        CLIUIIntegration.puts(\"{{bold:📄 File Type:}} {{cyan:#{@blueprint[:file_type] || 'N/A'}}}\")\n        CLIUIIntegration.puts(\"{{bold:📦 Blueprint Type:}} {{magenta:#{@blueprint[:blueprint_type] || 'N/A'}}}\")\n        CLIUIIntegration.puts(\"{{bold:⚙️  Parser Type:}} {{yellow:#{@blueprint[:parser_type] || 'N/A'}}}\")\n      end\n\n      def show_description\n        description = @blueprint[:description] || 'No description available'\n        CLIUIIntegration.puts('{{bold:📝 Description:}}')\n        CLIUIIntegration.puts(description)\n      end\n\n      def show_categories\n        if @blueprint[:categories]&.any?\n          category_names = @blueprint[:categories].map { |cat| cat[:title] || cat[:name] }\n          categories_text = category_names.join(', ')\n          CLIUIIntegration.puts(\"{{bold:🏷️  Categories:}} {{blue:#{categories_text}}}\")\n        else\n          CLIUIIntegration.puts('{{bold:🏷️  Categories:}} {{gray:None}}')\n        end\n      end\n\n      def show_ai_suggestions\n        suggestions = @blueprint[:ai_suggestions]\n        CLIUIIntegration.puts('{{bold:🤖 AI Analysis:}}')\n\n        if suggestions[:improvements]\n          CLIUIIntegration.puts('{{green:💡 Improvements:}}')\n          suggestions[:improvements].each_with_index do |improvement, index|\n            CLIUIIntegration.puts(\"  {{blue:#{index + 1}.}} #{improvement}\")\n          end\n        end\n\n        return unless suggestions[:quality_assessment]\n\n        CLIUIIntegration.puts('')\n        CLIUIIntegration.puts('{{yellow:📊 Quality Assessment:}}')\n        CLIUIIntegration.puts(suggestions[:quality_assessment])\n      end\n\n      def show_code_section\n        visible_lines = get_visible_code_lines\n        scroll_info = get_scroll_info\n\n        CLIUIIntegration.frame(\"💻 Code (#{@blueprint[:language]}) - #{scroll_info}\",\n                               color: :green) do\n          if visible_lines.empty?\n            CLIUIIntegration.puts('{{gray:No code available}}')\n          else\n            visible_lines.each_with_index do |line, index|\n              line_num = (@code_scroll_position + index + 1).to_s.rjust(3)\n              formatted_line = line.length > 80 ? \"#{line[0...77]}...\" : line\n              CLIUIIntegration.puts(\"{{gray:#{line_num} |}} #{formatted_line}\")\n            end\n          end\n        end\n        CLIUIIntegration.puts('')\n      end\n\n      def show_actions_menu\n        actions_list = ACTIONS.map { |key, desc| \"{{blue:/#{key}}} - #{desc}\" }.join(\"\\n\")\n\n        CLIUIIntegration.frame('⚡ Quick Actions', color: :yellow) do\n          CLIUIIntegration.puts(actions_list)\n          CLIUIIntegration.puts('')\n          CLIUIIntegration.puts('{{bold:💡 Navigation:}} Use {{blue:/scroll up}}/{{blue:/scroll down}} to navigate code')\n          CLIUIIntegration.puts('{{bold:📖 Usage:}} Type a command (e.g., {{blue:/edit}}) or press Enter to continue')\n        end\n      end\n\n      def handle_interactions\n        loop do\n          CLIUIIntegration.puts('')\n          CLIUIIntegration.puts('{{blue:Enter command or press Enter to continue:}}')\n\n          input = $stdin.gets.chomp.strip\n\n          if input.empty?\n            break\n          elsif input.start_with?('/')\n            result = handle_slash_command(input)\n            break if %i[quit back].include?(result)\n          else\n            CLIUIIntegration.puts('{{yellow:⚠️  Unknown command. Use /help for available commands.}}')\n          end\n        end\n      end\n\n      def handle_slash_command(command)\n        command_parts = command[1..].split\n        action = command_parts.first&.downcase\n\n        case action\n        when 'edit'\n          handle_edit_action\n        when 'preview'\n          handle_preview_action\n        when 'docs'\n          handle_docs_action\n        when 'export'\n          handle_export_action\n        when 'copy'\n          handle_copy_action\n        when 'analyze'\n          handle_analyze_action\n        when 'scroll'\n          handle_scroll_action(command_parts[1])\n        when 'back'\n          :back\n        when 'quit', 'exit'\n          :quit\n        when 'help'\n          show_help\n        else\n          CLIUIIntegration.puts(\"{{red:❌ Unknown action: #{action}}}\")\n          CLIUIIntegration.puts(\"{{yellow:Available actions: #{ACTIONS.keys.join(', ')}}}\")\n        end\n      end\n\n      def handle_edit_action\n        CLIUIIntegration.puts(\"{{blue:🔄 Launching edit action for blueprint #{@blueprint[:id]}...}}\")\n        begin\n          result = BlueprintsCLI::Actions::Edit.new(id: @blueprint[:id]).call\n          CLIUIIntegration.puts(result ? '{{green:✅ Edit completed}}' : '{{red:❌ Edit failed}}')\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:❌ Edit failed: #{e.message}}}\")\n        end\n      end\n\n      def handle_preview_action\n        CLIUIIntegration.puts('{{blue:🔄 Generating preview improvements...}}')\n        if @blueprint[:ai_suggestions]\n          display_improvements_preview\n        else\n          generate_and_display_improvements\n        end\n      end\n\n      def handle_docs_action\n        CLIUIIntegration.puts('{{blue:🔄 Generating documentation...}}')\n        begin\n          # Create a temporary file with the blueprint code\n          require 'tempfile'\n          temp_file = Tempfile.new([\"blueprint_#{@blueprint[:id]}\",\n            @blueprint[:file_type] || '.rb'])\n          temp_file.write(@blueprint[:code])\n          temp_file.close\n\n          # Use the docs command to generate documentation\n          docs_command = BlueprintsCLI::Commands::DocsCommand.new({})\n          result = docs_command.execute('generate', temp_file.path)\n\n          CLIUIIntegration.puts(result ? '{{green:✅ Documentation generated}}' : '{{red:❌ Documentation generation failed}}')\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:❌ Documentation failed: #{e.message}}}\")\n        ensure\n          temp_file&.unlink # Clean up temp file\n        end\n      end\n\n      def handle_export_action\n        CLIUIIntegration.puts('{{blue:🔄 Exporting blueprint...}}')\n        begin\n          result = BlueprintsCLI::Actions::Export.new(\n            id: @blueprint[:id],\n            output_path: nil\n          ).call\n          CLIUIIntegration.puts(result ? '{{green:✅ Export completed}}' : '{{red:❌ Export failed}}')\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:❌ Export failed: #{e.message}}}\")\n        end\n      end\n\n      def handle_copy_action\n        if system('which pbcopy > /dev/null 2>&1') # macOS\n          IO.popen('pbcopy', 'w') { |pipe| pipe.write(@blueprint[:code]) }\n          CLIUIIntegration.puts('{{green:✅ Code copied to clipboard (macOS)}}')\n        elsif system('which xclip > /dev/null 2>&1') # Linux\n          IO.popen('xclip -selection clipboard', 'w') { |pipe| pipe.write(@blueprint[:code]) }\n          CLIUIIntegration.puts('{{green:✅ Code copied to clipboard (Linux)}}')\n        else\n          CLIUIIntegration.puts('{{yellow:⚠️  Clipboard not available. Code printed below:}}')\n          puts @blueprint[:code]\n        end\n      rescue StandardError => e\n        CLIUIIntegration.puts(\"{{red:❌ Copy failed: #{e.message}}}\")\n      end\n\n      def handle_analyze_action\n        CLIUIIntegration.puts('{{blue:🔄 Running AI analysis...}}')\n        begin\n          # Generate AI suggestions if not already available\n          @blueprint[:ai_suggestions] = generate_ai_suggestions unless @blueprint[:ai_suggestions]\n\n          # Refresh the display\n          CLIUIIntegration.puts('')\n          show_details_section\n          CLIUIIntegration.puts('{{green:✅ AI analysis completed}}')\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:❌ AI analysis failed: #{e.message}}}\")\n        end\n      end\n\n      def handle_scroll_action(direction)\n        case direction&.downcase\n        when 'up'\n          @code_scroll_position = [@code_scroll_position - 10, 0].max\n        when 'down'\n          max_scroll = [@code_lines.length - @lines_per_page, 0].max\n          @code_scroll_position = [@code_scroll_position + 10, max_scroll].min\n        when 'top'\n          @code_scroll_position = 0\n        when 'bottom'\n          @code_scroll_position = [@code_lines.length - @lines_per_page, 0].max\n        else\n          CLIUIIntegration.puts('{{yellow:Usage: /scroll [up|down|top|bottom]}}')\n          return\n        end\n\n        CLIUIIntegration.puts('')\n        show_code_section\n      end\n\n      def show_help\n        CLIUIIntegration.frame('🔧 Available Commands', color: :magenta) do\n          ACTIONS.each do |key, desc|\n            CLIUIIntegration.puts(\"{{blue:/#{key.ljust(8)}}} - #{desc}\")\n          end\n          CLIUIIntegration.puts('')\n          CLIUIIntegration.puts('{{bold:💡 Tips:}}')\n          CLIUIIntegration.puts('• Use {{blue:/scroll up}} and {{blue:/scroll down}} to navigate code')\n          CLIUIIntegration.puts('• Code panel automatically truncates long lines')\n          CLIUIIntegration.puts('• Language detection works for 25+ programming languages')\n        end\n      end\n\n      # Helper methods\n      def get_visible_code_lines\n        start_line = @code_scroll_position\n        end_line = [@code_scroll_position + @lines_per_page, @code_lines.length].min\n\n        @code_lines[start_line...end_line] || []\n      end\n\n      def get_scroll_info\n        if @code_lines.length <= @lines_per_page\n          \"#{@code_lines.length} lines\"\n        else\n          current_line = @code_scroll_position + 1\n          end_line = [@code_scroll_position + @lines_per_page, @code_lines.length].min\n          \"Lines #{current_line}-#{end_line} of #{@code_lines.length}\"\n        end\n      end\n\n      def format_date(timestamp)\n        return 'N/A' unless timestamp\n\n        Time.parse(timestamp.to_s).strftime('%Y-%m-%d %H:%M')\n      rescue StandardError\n        timestamp.to_s\n      end\n\n      def display_improvements_preview\n        suggestions = @blueprint[:ai_suggestions]\n        return unless suggestions[:improvements]\n\n        CLIUIIntegration.frame('🔮 AI Improvement Suggestions', color: :magenta) do\n          suggestions[:improvements].each_with_index do |improvement, index|\n            CLIUIIntegration.puts(\"{{green:#{index + 1}.}} #{improvement}\")\n            CLIUIIntegration.puts('')\n          end\n        end\n      end\n\n      def generate_and_display_improvements\n        suggestions = BlueprintsCLI::Generators::Improvement.new(\n          code: @blueprint[:code],\n          description: @blueprint[:description]\n        ).generate\n\n        @blueprint[:ai_suggestions] = { improvements: suggestions }\n        display_improvements_preview\n      rescue StandardError => e\n        CLIUIIntegration.puts(\"{{red:❌ Failed to generate improvements: #{e.message}}}\")\n        BlueprintsCLI.logger.error(\"AI improvement generation failed: #{e.message}\")\n      end\n\n      def generate_ai_suggestions\n        suggestions = BlueprintsCLI::Generators::Improvement.new(\n          code: @blueprint[:code],\n          description: @blueprint[:description]\n        ).generate\n\n        { improvements: suggestions }\n      rescue StandardError => e\n        BlueprintsCLI.logger.warn(\"AI suggestions failed: #{e.message}\")\n        CLIUIIntegration.puts(\"{{yellow:⚠️  AI suggestions unavailable: #{e.message}}}\")\n        nil\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/ui/"
    },
    {
      "filename": "preview_boxes.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire 'tty-screen'\nrequire_relative '../utils/code_formatter'\n\nmodule BlueprintsCLI\n  module UI\n    # Module for standardized preview box styling and creation\n    module PreviewBoxes\n      # Standard preview box styles\n      STYLES = {\n        info: { style: { border: { fg: :blue } } },\n        code: { style: { border: { fg: :green } } },\n        warning: { style: { border: { fg: :yellow } } },\n        error: { style: { border: { fg: :red } } },\n        diff: { style: { border: { fg: :cyan } } },\n        success: { style: { border: { fg: :green } } },\n        metadata: { style: { border: { fg: :blue } } },\n        description: { style: { border: { fg: :cyan } } },\n        suggestions: { style: { border: { fg: :magenta } } }\n      }.freeze\n\n      module_function\n\n      # Creates a standardized info box\n      # @param content [String] The content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def info_box(content, title: 'Information', **options)\n        create_box(content, title: title, style: :info, **options)\n      end\n\n      # Creates a standardized code preview box\n      # @param content [String] The code content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def code_box(content, title: 'Code', **options)\n        create_box(content, title: title, style: :code, **options)\n      end\n\n      # Creates a syntax-highlighted code preview box\n      # @param content [String] The code content to display\n      # @param title [String] The box title\n      # @param language [String, nil] Optional language override for syntax highlighting\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box with syntax highlighting\n      def highlighted_code_box(content, title: 'Code', language: nil, **options)\n        # Calculate optimal width based on terminal dimensions\n        terminal_width = TTY::Screen.width\n        content_width = calculate_content_width(content, terminal_width)\n        \n        highlighted_content = Utils::CodeFormatter.format_for_box(content, language: language)\n        \n        # Set width option if not provided and content fits nicely\n        box_options = options.dup\n        if !options.key?(:width) && content_width < terminal_width\n          box_options[:width] = \n            content_width\n        end\n        \n        create_box(highlighted_content, title: title, style: :code, **box_options)\n      end\n\n      # Creates a standardized warning box\n      # @param content [String] The warning content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def warning_box(content, title: 'Warning', **options)\n        create_box(content, title: title, style: :warning, **options)\n      end\n\n      # Creates a standardized error box\n      # @param content [String] The error content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def error_box(content, title: 'Error', **options)\n        create_box(content, title: title, style: :error, **options)\n      end\n\n      # Creates a standardized diff/comparison box\n      # @param content [String] The diff content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def diff_box(content, title: 'Comparison', **options)\n        create_box(content, title: title, style: :diff, **options)\n      end\n\n      # Creates a standardized success box\n      # @param content [String] The success content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def success_box(content, title: 'Success', **options)\n        create_box(content, title: title, style: :success, **options)\n      end\n\n      # Creates a metadata preview box\n      # @param content [String] The metadata content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def metadata_box(content, title: 'Metadata', **options)\n        create_box(content, title: title, style: :metadata, **options)\n      end\n\n      # Creates a description preview box\n      # @param content [String] The description content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def description_box(content, title: 'Description', **options)\n        create_box(content, title: title, style: :description, **options)\n      end\n\n      # Creates an AI suggestions preview box\n      # @param content [String] The suggestions content to display\n      # @param title [String] The box title\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def suggestions_box(content, title: 'AI Suggestions', **options)\n        create_box(content, title: title, style: :suggestions, **options)\n      end\n\n      # Creates a side-by-side comparison of two contents\n      # @param left_content [String] Content for the left box\n      # @param right_content [String] Content for the right box\n      # @param left_title [String] Title for the left box\n      # @param right_title [String] Title for the right box\n      # @param left_style [Symbol] Style for the left box\n      # @param right_style [Symbol] Style for the right box\n      # @return [String] The formatted side-by-side boxes\n      def side_by_side(left_content, right_content,\n                       left_title: 'Before', right_title: 'After',\n                       left_style: :error, right_style: :success)\n        # Calculate width for side-by-side display\n        terminal_width = TTY::Screen.width\n        box_width = [(terminal_width / 2) - 4, 40].max  # Minimum 40 chars per box\n        \n        left_box = create_box(left_content, title: left_title, style: left_style, width: box_width)\n        right_box = create_box(right_content, title: right_title, style: right_style, \n                                              width: box_width)\n\n        \"#{left_box}\\n#{right_box}\"\n      end\n\n      private_class_method\n\n      # Creates a TTY::Box with standardized styling\n      # @param content [String] The content to display\n      # @param title [String] The box title\n      # @param style [Symbol] The predefined style to use\n      # @param options [Hash] Additional TTY::Box options\n      # @return [String] The formatted box\n      def self.create_box(content, title:, style:, **options)\n        default_options = {\n          title: { top_left: title },\n          padding: 1\n        }\n\n        style_options = STYLES[style] || STYLES[:info]\n        box_options = default_options.merge(style_options).merge(options)\n\n        TTY::Box.frame(content, **box_options)\n      end\n\n      # Calculate optimal content width based on code and terminal dimensions\n      # @param content [String] The content to analyze\n      # @param terminal_width [Integer] The terminal width\n      # @return [Integer] The optimal content width\n      def self.calculate_content_width(content, terminal_width)\n        return terminal_width - 4 if content.nil? || content.empty?\n        \n        begin\n          # Get the longest line in the content (excluding ANSI codes)\n          max_line_length = content.lines.map { |line| strip_ansi_codes(line).length }.max || 0\n          \n          # Add padding for box borders and margins (roughly 6 characters)\n          content_width = max_line_length + 6\n          \n          # Ensure we don't exceed terminal width, but use at least 50% of terminal\n          min_width = [terminal_width * 0.5, 60].max.to_i\n          max_width = terminal_width - 4  # Leave some margin\n          \n          [[content_width, min_width].max, max_width].min\n        rescue StandardError\n          # Fallback to a reasonable default width\n          terminal_width - 4\n        end\n      end\n\n      # Strip ANSI escape codes from text for length calculation\n      # @param text [String] The text with potential ANSI codes\n      # @return [String] Plain text without ANSI codes\n      def self.strip_ansi_codes(text)\n        return '' if text.nil?\n        \n        text.to_s.gsub(/\\e\\[[0-9;]*m/, '').gsub(/\\[[0-9;]*m/, '')\n      rescue StandardError\n        text.to_s\n      end\n    end\n  end\nend",
      "path": "/lib/blueprintsCLI/ui/"
    },
    {
      "filename": "two_column_viewer.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'tty-box'\nrequire 'tty-cursor'\nrequire 'tty-screen'\nrequire_relative '../cli_ui_integration'\nrequire_relative '../slash_command_parser'\n\nmodule BlueprintsCLI\n  module UI\n    # TwoColumnViewer provides an enhanced blueprint viewing experience\n    # with metadata/details on the left and scrollable code on the right\n    class TwoColumnViewer\n      ACTIONS = {\n        'edit' => '✏️  Edit blueprint',\n        'preview' => '👀 Preview improvements',\n        'docs' => '📚 Generate documentation',\n        'export' => '💾 Export code',\n        'copy' => '📋 Copy to clipboard',\n        'analyze' => '🤖 AI analysis',\n        'back' => '⬅️  Back to list',\n        'quit' => '❌ Quit'\n      }.freeze\n\n      def initialize(blueprint, with_suggestions: false)\n        @blueprint = blueprint\n        @with_suggestions = with_suggestions\n        @cursor = TTY::Cursor\n        @screen_width = TTY::Screen.width\n        @screen_height = TTY::Screen.height\n\n        # Calculate column widths (left: 40%, right: 60%)\n        @left_width = (@screen_width * 0.4).to_i - 2\n        @right_width = (@screen_width * 0.6).to_i - 2\n        @content_height = @screen_height - 8 # Reserve space for title and menu\n\n        # Initialize scroll position for code\n        @code_scroll_position = 0\n        @code_lines = @blueprint[:code].split(\"\\n\")\n        @visible_code_lines = @content_height - 4 # Account for box borders\n      end\n\n      # Display the two-column view\n      def display\n        clear_screen\n        render_layout\n        handle_interactions\n      end\n\n      private\n\n      def clear_screen\n        print @cursor.clear_screen\n        print @cursor.move_to(0, 0)\n      end\n\n      def render_layout\n        render_header\n        render_columns\n        render_slash_menu\n      end\n\n      def render_header\n        title = \"📋 Blueprint: #{@blueprint[:name]}\"\n        header_box = TTY::Box.frame(\n          title,\n          align: :center,\n          width: @screen_width - 2,\n          style: { border: { fg: :bright_blue } },\n          padding: 0\n        )\n        puts header_box\n      end\n\n      def render_columns\n        left_content = build_left_column_content\n        right_content = build_right_column_content\n\n        # Create side-by-side boxes\n        left_box = TTY::Box.frame(\n          left_content,\n          title: { top_left: '📋 Details' },\n          width: @left_width,\n          height: @content_height,\n          style: { border: { fg: :cyan } },\n          padding: 1\n        )\n\n        right_box = TTY::Box.frame(\n          right_content,\n          title: {\n            top_left: \"💻 Code (#{@blueprint[:language]})\",\n            top_right: scrollable_indicator\n          },\n          width: @right_width,\n          height: @content_height,\n          style: { border: { fg: :green } },\n          padding: 1\n        )\n\n        # Display boxes side by side\n        left_lines = left_box.split(\"\\n\")\n        right_lines = right_box.split(\"\\n\")\n\n        max_lines = [left_lines.length, right_lines.length].max\n\n        (0...max_lines).each do |i|\n          left_line = left_lines[i] || (' ' * @left_width)\n          right_line = right_lines[i] || (' ' * @right_width)\n          puts \"#{left_line}#{right_line}\"\n        end\n      end\n\n      def build_left_column_content\n        content_parts = []\n\n        # Basic metadata\n        content_parts << build_metadata_section\n        content_parts << ''\n\n        # Language & file info (move up for visibility)\n        content_parts << build_language_info_section\n        content_parts << ''\n\n        # Description (more compact)\n        content_parts << build_description_section\n        content_parts << ''\n\n        # Categories\n        content_parts << build_categories_section\n\n        # AI suggestions if available\n        if @blueprint[:ai_suggestions]\n          content_parts << ''\n          content_parts << build_suggestions_section\n        end\n\n        # Truncate content to fit in box height\n        max_lines = @content_height - 4 # Account for padding and borders\n        content_lines = content_parts.join(\"\\n\").split(\"\\n\")\n\n        if content_lines.length > max_lines\n          content_lines = content_lines[0...(max_lines - 1)] + ['... (truncated)']\n        end\n\n        content_lines.join(\"\\n\")\n      end\n\n      def build_metadata_section\n        lines = []\n        lines << \"🆔 ID: #{@blueprint[:id]}\"\n        lines << \"📅 Created: #{format_date(@blueprint[:created_at])}\"\n        lines << \"🔄 Updated: #{format_date(@blueprint[:updated_at])}\"\n        lines << \"📏 Size: #{@blueprint[:code].length} chars\"\n        lines.join(\"\\n\")\n      end\n\n      def build_description_section\n        description = @blueprint[:description] || 'No description available'\n\n        # Truncate long descriptions to save space\n        description = \"#{description[0...147]}...\" if description.length > 150\n\n        wrapped_description = wrap_text(description, @left_width - 4)\n\n        \"📝 Description:\\n#{wrapped_description}\"\n      end\n\n      def build_language_info_section\n        lines = []\n        lines << \"🔤 Language: #{@blueprint[:language] || 'Unknown'}\"\n        lines << \"📄 File Type: #{@blueprint[:file_type] || 'N/A'}\"\n        lines << \"📦 Type: #{@blueprint[:blueprint_type] || 'N/A'}\"\n        lines << \"⚙️  Parser: #{@blueprint[:parser_type] || 'N/A'}\"\n        lines.join(\"\\n\")\n      end\n\n      def build_categories_section\n        if @blueprint[:categories]&.any?\n          category_names = @blueprint[:categories].map { |cat| cat[:title] || cat[:name] }\n          categories_text = category_names.join(', ')\n          wrapped_categories = wrap_text(categories_text, @left_width - 4)\n          \"🏷️  Categories:\\n#{wrapped_categories}\"\n        else\n          '🏷️  Categories: None'\n        end\n      end\n\n      def build_suggestions_section\n        suggestions = @blueprint[:ai_suggestions]\n        lines = []\n        lines << '🤖 AI Analysis:'\n\n        if suggestions[:improvements]\n          lines << 'Improvements:'\n          suggestions[:improvements].each do |improvement|\n            wrapped = wrap_text(\"• #{improvement}\", @left_width - 6)\n            lines << wrapped\n          end\n        end\n\n        if suggestions[:quality_assessment]\n          lines << ''\n          lines << 'Quality:'\n          wrapped_quality = wrap_text(suggestions[:quality_assessment], @left_width - 4)\n          lines << wrapped_quality\n        end\n\n        lines.join(\"\\n\")\n      end\n\n      def build_right_column_content\n        visible_lines = get_visible_code_lines\n        get_line_numbers(visible_lines.length)\n\n        # Add line numbers to code\n        numbered_lines = visible_lines.map.with_index do |line, index|\n          line_num = (@code_scroll_position + index + 1).to_s.rjust(3)\n          \"#{line_num} │ #{line}\"\n        end\n\n        # Ensure lines fit in the right column width\n        max_code_width = @right_width - 8 # Account for line numbers and padding\n        formatted_lines = numbered_lines.map do |line|\n          if line.length > max_code_width\n            \"#{line[0...(max_code_width - 3)]}...\"\n          else\n            line\n          end\n        end\n\n        formatted_lines.join(\"\\n\")\n      end\n\n      def get_visible_code_lines\n        start_line = @code_scroll_position\n        end_line = [@code_scroll_position + @visible_code_lines, @code_lines.length].min\n\n        @code_lines[start_line...end_line] || []\n      end\n\n      def get_line_numbers(count)\n        start_num = @code_scroll_position + 1\n        (start_num...(start_num + count)).to_a\n      end\n\n      def scrollable_indicator\n        if @code_lines.length > @visible_code_lines\n          total_lines = @code_lines.length\n          current_line = @code_scroll_position + 1\n          end_line = [@code_scroll_position + @visible_code_lines, total_lines].min\n          \"#{current_line}-#{end_line}/#{total_lines}\"\n        else\n          \"#{@code_lines.length} lines\"\n        end\n      end\n\n      def render_slash_menu\n        actions_text = ACTIONS.map { |key, desc| \"/#{key}: #{desc}\" }.join('  |  ')\n\n        menu_box = TTY::Box.frame(\n          \"#{actions_text}\\n\\n💡 Use arrow keys to scroll code, type /command to execute actions\",\n          title: { top_left: '⚡ Quick Actions' },\n          width: @screen_width - 2,\n          style: { border: { fg: :yellow } },\n          padding: 1\n        )\n        puts menu_box\n      end\n\n      def handle_interactions\n        CLIUIIntegration.puts('{{blue:Press Enter to continue or type a slash command...}}')\n\n        loop do\n          input = gets.chomp.strip\n\n          if input.empty?\n            break\n          elsif input.start_with?('/')\n            handle_slash_command(input)\n          else\n            CLIUIIntegration.puts('{{yellow:Unknown command. Use /help for available commands.}}')\n          end\n        end\n      end\n\n      def handle_slash_command(command)\n        command_parts = command[1..].split\n        action = command_parts.first&.downcase\n\n        case action\n        when 'edit'\n          handle_edit_action\n        when 'preview'\n          handle_preview_action\n        when 'docs'\n          handle_docs_action\n        when 'export'\n          handle_export_action\n        when 'copy'\n          handle_copy_action\n        when 'analyze'\n          handle_analyze_action\n        when 'back'\n          :back\n        when 'quit', 'exit'\n          :quit\n        when 'scroll'\n          handle_scroll_action(command_parts[1])\n        when 'help'\n          show_help\n        else\n          CLIUIIntegration.puts(\"{{red:Unknown action: #{action}}}\")\n          CLIUIIntegration.puts(\"{{yellow:Available actions: #{ACTIONS.keys.join(', ')}}}\")\n        end\n      end\n\n      def handle_edit_action\n        CLIUIIntegration.puts(\"{{blue:🔄 Launching edit action for blueprint #{@blueprint[:id]}...}}\")\n        # Integration with existing edit command\n        result = BlueprintsCLI::Actions::Edit.new(id: @blueprint[:id]).call\n        CLIUIIntegration.puts(result ? '{{green:✅ Edit completed}}' : '{{red:❌ Edit failed}}')\n      end\n\n      def handle_preview_action\n        CLIUIIntegration.puts('{{blue:🔄 Generating preview improvements...}}')\n        if @blueprint[:ai_suggestions]\n          display_improvements_preview\n        else\n          generate_and_display_improvements\n        end\n      end\n\n      def handle_docs_action\n        CLIUIIntegration.puts('{{blue:🔄 Generating documentation...}}')\n        begin\n          # Create a temporary file with the blueprint code\n          require 'tempfile'\n          temp_file = Tempfile.new([\"blueprint_#{@blueprint[:id]}\",\n            @blueprint[:file_type] || '.rb'])\n          temp_file.write(@blueprint[:code])\n          temp_file.close\n\n          # Use the docs command to generate documentation\n          docs_command = BlueprintsCLI::Commands::DocsCommand.new({})\n          result = docs_command.execute('generate', temp_file.path)\n\n          CLIUIIntegration.puts(result ? '{{green:✅ Documentation generated}}' : '{{red:❌ Documentation generation failed}}')\n        rescue StandardError => e\n          CLIUIIntegration.puts(\"{{red:❌ Documentation failed: #{e.message}}}\")\n        ensure\n          temp_file&.unlink # Clean up temp file\n        end\n      end\n\n      def handle_export_action\n        CLIUIIntegration.puts('{{blue:🔄 Exporting blueprint...}}')\n        result = BlueprintsCLI::Actions::Export.new(\n          id: @blueprint[:id],\n          output_path: nil\n        ).call\n        CLIUIIntegration.puts(result ? '{{green:✅ Export completed}}' : '{{red:❌ Export failed}}')\n      end\n\n      def handle_copy_action\n        if system('which pbcopy > /dev/null 2>&1') # macOS\n          IO.popen('pbcopy', 'w') { |pipe| pipe.write(@blueprint[:code]) }\n          CLIUIIntegration.puts('{{green:✅ Code copied to clipboard (macOS)}}')\n        elsif system('which xclip > /dev/null 2>&1') # Linux\n          IO.popen('xclip -selection clipboard', 'w') { |pipe| pipe.write(@blueprint[:code]) }\n          CLIUIIntegration.puts('{{green:✅ Code copied to clipboard (Linux)}}')\n        else\n          CLIUIIntegration.puts('{{yellow:⚠️  Clipboard not available. Code printed below:}}')\n          puts @blueprint[:code]\n        end\n      end\n\n      def handle_analyze_action\n        CLIUIIntegration.puts('{{blue:🔄 Running AI analysis...}}')\n        # Generate AI suggestions if not already available\n        @blueprint[:ai_suggestions] = generate_ai_suggestions unless @blueprint[:ai_suggestions]\n\n        clear_screen\n        render_layout # Re-render with suggestions\n      end\n\n      def handle_scroll_action(direction)\n        case direction&.downcase\n        when 'up'\n          @code_scroll_position = [@code_scroll_position - 5, 0].max\n        when 'down'\n          max_scroll = [@code_lines.length - @visible_code_lines, 0].max\n          @code_scroll_position = [@code_scroll_position + 5, max_scroll].min\n        when 'top'\n          @code_scroll_position = 0\n        when 'bottom'\n          @code_scroll_position = [@code_lines.length - @visible_code_lines, 0].max\n        else\n          CLIUIIntegration.puts('{{yellow:Usage: /scroll [up|down|top|bottom]}}')\n          return\n        end\n\n        clear_screen\n        render_layout\n      end\n\n      def show_help\n        help_text = <<~HELP\n          🔧 Available Commands:\n\n          /edit        - Edit this blueprint\n          /preview     - Preview AI improvements#{'  '}\n          /docs        - Generate documentation\n          /export      - Export code to file\n          /copy        - Copy code to clipboard\n          /analyze     - Run AI analysis\n          /scroll up   - Scroll code up\n          /scroll down - Scroll code down\n          /back        - Return to blueprint list\n          /quit        - Exit application\n\n          💡 Tips:\n          - Use arrow keys for navigation\n          - Code panel shows line numbers\n          - Scroll indicator shows current position\n        HELP\n\n        CLIUIIntegration.puts(help_text)\n      end\n\n      # Helper methods\n      def format_date(timestamp)\n        return 'N/A' unless timestamp\n\n        Time.parse(timestamp.to_s).strftime('%Y-%m-%d %H:%M')\n      rescue StandardError\n        timestamp.to_s\n      end\n\n      def wrap_text(text, width)\n        return '' if text.nil? || text.empty?\n\n        text.gsub(/(.{1,#{width - 1}})(\\s+|$)/, \"\\\\1\\n\").strip\n      end\n\n      def display_improvements_preview\n        suggestions = @blueprint[:ai_suggestions]\n        return unless suggestions[:improvements]\n\n        CLIUIIntegration.frame('🔮 AI Improvement Suggestions', color: :magenta) do\n          suggestions[:improvements].each_with_index do |improvement, index|\n            CLIUIIntegration.puts(\"{{green:#{index + 1}.}} #{improvement}\")\n            CLIUIIntegration.puts('')\n          end\n        end\n      end\n\n      def generate_and_display_improvements\n        suggestions = BlueprintsCLI::Generators::Improvement.new(\n          code: @blueprint[:code],\n          description: @blueprint[:description]\n        ).generate\n\n        @blueprint[:ai_suggestions] = { improvements: suggestions }\n        display_improvements_preview\n\n        # Re-render to show suggestions in left panel\n        clear_screen\n        render_layout\n      rescue StandardError => e\n        CLIUIIntegration.puts(\"{{red:❌ Failed to generate improvements: #{e.message}}}\")\n      end\n\n      def generate_ai_suggestions\n        suggestions = BlueprintsCLI::Generators::Improvement.new(\n          code: @blueprint[:code],\n          description: @blueprint[:description]\n        ).generate\n\n        { improvements: suggestions }\n      rescue StandardError => e\n        BlueprintsCLI.logger.warn(\"AI suggestions failed: #{e.message}\")\n        nil\n      end\n    end\n  end\nend\n",
      "path": "/lib/blueprintsCLI/ui/"
    },
    {
      "filename": "code_formatter.rb",
      "content": "# frozen_string_literal: true\n\nrequire 'rouge'\nrequire 'tty-screen'\nrequire_relative 'language_detector'\n\nmodule BlueprintsCLI\n  module Utils\n    # Utility class for formatting code with syntax highlighting\n    class CodeFormatter\n      class << self\n        # Format code with syntax highlighting using Rouge directly\n        # @param code [String] The raw code to format\n        # @param language [String, nil] Optional language override\n        # @return [String] The formatted code with syntax highlighting\n        def format(code, language: nil)\n          return '' if code.nil? || code.strip.empty?\n\n          # Detect language if not provided\n          detected_language = language || LanguageDetector.detect(code)\n\n          # Use Rouge for syntax highlighting\n          highlight_with_rouge(code, detected_language)\n        end\n\n        # Format code for display in a TTY::Box with syntax highlighting\n        # @param code [String] The raw code to format\n        # @param language [String, nil] Optional language override\n        # @return [String] The formatted code ready for TTY::Box display\n        def format_for_box(code, language: nil)\n          # Get highlighted code from Rouge\n          format(code, language: language)\n        end\n\n        private\n\n        # Highlight code using Rouge directly with Terminal256 formatter\n        # @param code [String] The code content\n        # @param language [String] The programming language\n        # @return [String] The highlighted code\n        def highlight_with_rouge(code, language)\n          # Find the appropriate lexer for the language\n          lexer = find_lexer(language)\n          \n          # Use Rouge's Terminal256 formatter for clean ANSI output\n          formatter = Rouge::Formatters::Terminal256.new\n          \n          # Highlight the code and clean up trailing reset codes\n          highlighted = formatter.format(lexer.lex(code.strip))\n          clean_trailing_codes(highlighted)\n        rescue StandardError => e\n          # If highlighting fails, return plain text\n          code.strip\n        end\n\n        # Clean up trailing reset codes that can appear after highlighting\n        # @param highlighted [String] The highlighted code with potential trailing codes\n        # @return [String] Cleaned highlighted code\n        def clean_trailing_codes(highlighted)\n          cleaned = highlighted\n            .gsub(/\\e\\[38;5;230m\\e\\[39m\\s*$/, '')                    # Remove trailing empty color sequences\n            .gsub(/\\e\\[38;5;230m\\e\\[39m\\n/, \"\\n\")                    # Remove empty color sequences before newlines\n            .gsub(/(\\e\\[39m)\\e\\[38;5;230m\\e\\[39m/, '\\1')              # Remove redundant color resets\n            .gsub(/\\]\\[0m/, ']')                                      # Fix corrupted closing brackets\n            .gsub(/\\[0m\\s*$/, '')                                     # Remove trailing reset codes\n            .gsub(/\\[0m(?=\\s*\\n)/, '')                               # Remove reset codes before newlines\n            .gsub(/(\\w+)\\[0m(\\s*$)/, '\\1\\2')                         # Fix words ending with reset codes\n            .gsub(/\\]\\[38;5;\\d+[;\\d]*m/, ']')                        # Fix corrupted bracket color codes\n            .gsub(/(\\w)\\[38;5;\\d+[;\\d]*m([^a-zA-Z])/, '\\1\\2')        # Fix mid-word color codes\n            .strip\n\n          # Final cleanup pass to remove any remaining malformed sequences\n          cleaned\n            .gsub(/\\[38;5;\\d+[;\\d]*m(?![a-zA-Z])/, '')               # Remove orphaned color codes\n            .gsub(/\\[39[;\\d]*m(?![a-zA-Z])/, '')                     # Remove orphaned reset codes\n        end\n\n        # Find the appropriate Rouge lexer for the given language\n        # @param language [String] The programming language\n        # @return [Rouge::Lexer] The lexer instance\n        def find_lexer(language)\n          # Map our language detection to Rouge lexer names\n          rouge_language = map_to_rouge_language(language)\n          \n          # Find the lexer, fallback to PlainText if not found\n          Rouge::Lexer.find(rouge_language) || Rouge::Lexers::PlainText.new\n        end\n\n        # Map our language names to Rouge lexer names\n        # @param language [String] Our detected language\n        # @return [String] Rouge lexer name\n        def map_to_rouge_language(language)\n          case language.to_s.downcase\n          when 'javascript' then 'js'\n          when 'typescript' then 'ts'\n          when 'cpp' then 'cpp'\n          when 'c' then 'c'\n          when 'python' then 'python'\n          when 'ruby' then 'ruby'\n          when 'java' then 'java'\n          when 'php' then 'php'\n          when 'shell' then 'shell'\n          when 'go' then 'go'\n          when 'rust' then 'rust'\n          when 'sql' then 'sql'\n          when 'yaml' then 'yaml'\n          when 'json' then 'json'\n          when 'html' then 'html'\n          when 'css' then 'css'\n          when 'xml' then 'xml'\n          else 'text'\n          end\n        end\n      end\n    end\n  end\nend",
      "path": "/lib/blueprintsCLI/utils/"
    },
    {
      "filename": "language_detector.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  module Utils\n    # Utility class for detecting programming languages from code content\n    class LanguageDetector\n      # Common file extensions mapped to language identifiers\n      EXTENSION_PATTERNS = {\n        python: /\\A\\s*(?:#.*\\n)*\\s*(?:def |class |import |from |print\\(|if __name__|@\\w+)/m,\n        ruby: /\\A\\s*(?:#.*\\n)*\\s*(?:class |module |def |require |puts |p |print |gem |bundle|end\\s*$|\\@\\w+\\s*=)/m,\n        javascript: /\\A\\s*(?:\\/\\/.*\\n|\\/\\*[\\s\\S]*?\\*\\/)*\\s*(?:function|const|let|var|=>|console\\.|document\\.|window\\.)/m,\n        java: /\\A\\s*(?:\\/\\/.*\\n|\\/\\*[\\s\\S]*?\\*\\/)*\\s*(?:public|private|protected|class|interface|import|package)/m,\n        php: /\\A\\s*<\\?php/m,\n        shell: /\\A\\s*#!.*\\/(?:bash|sh|zsh)/m,\n        go: /\\A\\s*(?:\\/\\/.*\\n)*\\s*(?:package |import |func |var |type |const )/m,\n        rust: /\\A\\s*(?:\\/\\/.*\\n)*\\s*(?:fn |let |use |mod |pub |struct |enum |impl )/m,\n        cpp: /\\A\\s*(?:\\/\\/.*\\n|\\/\\*[\\s\\S]*?\\*\\/)*\\s*(?:#include|using namespace|int main|class |template)/m,\n        c: /\\A\\s*(?:\\/\\/.*\\n|\\/\\*[\\s\\S]*?\\*\\/)*\\s*(?:#include|int main|void |struct |typedef)/m,\n        sql: /\\A\\s*(?:--.*\\n)*\\s*(?:SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)/im,\n        yaml: /\\A\\s*(?:#.*\\n)*\\s*(?:[a-zA-Z][a-zA-Z0-9_]*\\s*:|---|\\.\\.\\.|version\\s*:)/m,\n        json: /\\A\\s*[{\\[]/m,\n        html: /\\A\\s*(?:<!DOCTYPE|<html|<head|<body|<div|<span|<p|<script|<style)/im,\n        css: /\\A\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)*\\s*(?:[.#]?[a-zA-Z][a-zA-Z0-9_-]*\\s*\\{|@media|@import)/m,\n        xml: /\\A\\s*<\\?xml|<[a-zA-Z][a-zA-Z0-9_-]*[^>]*>/m\n      }.freeze\n\n      # Additional content-based patterns for better detection\n      KEYWORD_PATTERNS = {\n        ruby: %w[require gem bundle def class module end puts p],\n        python: %w[def class import from print __name__ __main__],\n        javascript: %w[function const let var console document window],\n        java: %w[public private protected class interface import package],\n        php: %w[<?php echo $_ $_GET $_POST function],\n        shell: %w[#!/bin/bash #!/bin/sh echo printf read if],\n        go: %w[package import func var type const],\n        rust: %w[fn let use mod pub struct enum impl],\n        cpp: %w[#include using namespace template class],\n        c: %w[#include stdio.h stdlib.h int main void],\n        sql: %w[SELECT INSERT UPDATE DELETE CREATE DROP ALTER],\n        yaml: %w[version name description dependencies],\n        html: %w[<!DOCTYPE <html <head <body <div <span],\n        css: %w[color background margin padding font],\n        xml: %w[<?xml version encoding]\n      }.freeze\n\n      class << self\n        # Detect the programming language of the given code\n        # @param code [String] The code content to analyze\n        # @return [String] The detected language identifier\n        def detect(code)\n          return 'text' if code.nil? || code.strip.empty?\n\n          normalized_code = code.strip.downcase\n\n          # First try pattern matching\n          EXTENSION_PATTERNS.each do |language, pattern|\n            return language.to_s if code.match?(pattern)\n          end\n\n          # Fallback to keyword scoring\n          detect_by_keywords(normalized_code)\n        end\n\n        private\n\n        # Detect language by counting keyword matches\n        # @param normalized_code [String] The normalized code content\n        # @return [String] The detected language identifier\n        def detect_by_keywords(normalized_code)\n          scores = {}\n\n          KEYWORD_PATTERNS.each do |language, keywords|\n            score = keywords.sum { |keyword| normalized_code.scan(keyword.downcase).size }\n            scores[language] = score if score > 0\n          end\n\n          # Return the language with the highest score, or 'text' if no matches\n          return 'text' if scores.empty?\n\n          scores.max_by { |_, score| score }.first.to_s\n        end\n      end\n    end\n  end\nend",
      "path": "/lib/blueprintsCLI/utils/"
    },
    {
      "filename": "version.rb",
      "content": "# frozen_string_literal: true\n\nmodule BlueprintsCLI\n  VERSION = '0.1.0'\nend\n",
      "path": "/lib/blueprintsCLI/"
    },
    {
      "filename": "ansi.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    module ANSI\n      extend T::Sig\n\n      ESC = \"\\x1b\"\n\n      class << self\n        extend T::Sig\n\n        # ANSI escape sequences (like \\x1b[31m) have zero width.\n        # when calculating the padding width, we must exclude them.\n        # This also implements a basic version of utf8 character width calculation like\n        # we could get for real from something like utf8proc.\n        #\n        sig { params(str: String).returns(Integer) }\n        def printing_width(str)\n          zwj = T.let(false, T::Boolean)\n          strip_codes(str).codepoints.reduce(0) do |acc, cp|\n            if zwj\n              zwj = false\n              next acc\n            end\n            case cp\n            when 0x200d # zero-width joiner\n              zwj = true\n              acc\n            when \"\\n\"\n              acc\n            else\n              acc + 1\n            end\n          end\n        end\n\n        # Strips ANSI codes from a str\n        #\n        # ==== Attributes\n        #\n        # - +str+ - The string from which to strip codes\n        #\n        sig { params(str: String).returns(String) }\n        def strip_codes(str)\n          str.gsub(/\\x1b\\[[\\d;]+[A-Za-z]|\\x1b\\][\\d;]+.*?\\x1b\\\\|\\r/, '')\n        end\n\n        # Returns an ANSI control sequence\n        #\n        # ==== Attributes\n        #\n        # - +args+ - Argument to pass to the ANSI control sequence\n        # - +cmd+ - ANSI control sequence Command\n        #\n        sig { params(args: String, cmd: String).returns(String) }\n        def control(args, cmd)\n          \"#{ESC}[#{args}#{cmd}\"\n        end\n\n        # https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        sig { params(params: String).returns(String) }\n        def sgr(params)\n          control(params, 'm')\n        end\n\n        # Cursor Movement\n\n        # Move the cursor up n lines\n        #\n        # ==== Attributes\n        #\n        # * +n+ - number of lines by which to move the cursor up\n        #\n        sig { params(n: Integer).returns(String) }\n        def cursor_up(n = 1)\n          return '' if n.zero?\n\n          control(n.to_s, 'A')\n        end\n\n        # Move the cursor down n lines\n        #\n        # ==== Attributes\n        #\n        # * +n+ - number of lines by which to move the cursor down\n        #\n        sig { params(n: Integer).returns(String) }\n        def cursor_down(n = 1)\n          return '' if n.zero?\n\n          control(n.to_s, 'B')\n        end\n\n        # Move the cursor forward n columns\n        #\n        # ==== Attributes\n        #\n        # * +n+ - number of columns by which to move the cursor forward\n        #\n        sig { params(n: Integer).returns(String) }\n        def cursor_forward(n = 1)\n          return '' if n.zero?\n\n          control(n.to_s, 'C')\n        end\n\n        # Move the cursor back n columns\n        #\n        # ==== Attributes\n        #\n        # * +n+ - number of columns by which to move the cursor back\n        #\n        sig { params(n: Integer).returns(String) }\n        def cursor_back(n = 1)\n          return '' if n.zero?\n\n          control(n.to_s, 'D')\n        end\n\n        # Move the cursor to a specific column\n        #\n        # ==== Attributes\n        #\n        # * +n+ - The column to move to\n        #\n        sig { params(n: Integer).returns(String) }\n        def cursor_horizontal_absolute(n = 1)\n          cmd = control(n.to_s, 'G')\n          cmd += cursor_back if CLI::UI::OS.current.shift_cursor_back_on_horizontal_absolute?\n          cmd\n        end\n\n        sig { returns(String) }\n        def enter_alternate_screen\n          control('?1049', 'h')\n        end\n\n        sig { returns(String) }\n        def exit_alternate_screen\n          control('?1049', 'l')\n        end\n\n        sig { returns(Regexp) }\n        def match_alternate_screen\n          /#{Regexp.escape(control('?1049', ''))}[hl]/\n        end\n\n        # Show the cursor\n        #\n        sig { returns(String) }\n        def show_cursor\n          control('', '?25h')\n        end\n\n        # Hide the cursor\n        #\n        sig { returns(String) }\n        def hide_cursor\n          control('', '?25l')\n        end\n\n        # Save the cursor position\n        #\n        sig { returns(String) }\n        def cursor_save\n          control('', 's')\n        end\n\n        # Restore the saved cursor position\n        #\n        sig { returns(String) }\n        def cursor_restore\n          control('', 'u')\n        end\n\n        # Move to the next line\n        #\n        sig { returns(String) }\n        def next_line\n          cursor_down + cursor_horizontal_absolute\n        end\n\n        # Move to the previous line\n        #\n        sig { returns(String) }\n        def previous_line\n          previous_lines(1)\n        end\n\n        # Move to the previous n lines\n        #\n        # ==== Attributes\n        #\n        # * +n+ - number of lines by which to move the cursor up\n        #\n        sig { params(n: Integer).returns(String) }\n        def previous_lines(n = 1)\n          cursor_up(n) + cursor_horizontal_absolute\n        end\n\n        sig { returns(String) }\n        def clear_to_end_of_line\n          control('', 'K')\n        end\n\n        sig { returns(String) }\n        def insert_line\n          insert_lines(1)\n        end\n\n        sig { params(n: Integer).returns(String) }\n        def insert_lines(n = 1)\n          control(n.to_s, 'L')\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "color.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    class Color\n      extend T::Sig\n\n      sig { returns(String) }\n      attr_reader :sgr, :code\n\n      sig { returns(Symbol) }\n      attr_reader :name\n\n      # Creates a new color mapping\n      # Signatures can be found here:\n      # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors\n      #\n      # ==== Attributes\n      #\n      # * +sgr+ - The color signature\n      # * +name+ - The name of the color\n      #\n      sig { params(sgr: String, name: Symbol).void }\n      def initialize(sgr, name)\n        @sgr  = sgr\n        @code = CLI::UI::ANSI.sgr(sgr)\n        @name = name\n      end\n\n      RED     = new('31', :red)\n      GREEN   = new('32', :green)\n      YELLOW  = new('33', :yellow)\n      # default blue is low-contrast against black in some default terminal color scheme\n      BLUE    = new('94', :blue) # 9x = high-intensity fg color x\n      MAGENTA = new('35', :magenta)\n      CYAN    = new('36', :cyan)\n      RESET   = new('0',  :reset)\n      BOLD    = new('1',  :bold)\n      WHITE   = new('97', :white)\n\n      # 240 is very dark gray; 255 is very light gray. 244 is somewhat dark.\n      GRAY = new('38;5;244', :gray)\n      # Using color 214 from the 256-color palette for a more distinct orange\n      ORANGE = new('38;5;214', :orange)\n\n      MAP = {\n        red: RED,\n        green: GREEN,\n        yellow: YELLOW,\n        blue: BLUE,\n        magenta: MAGENTA,\n        cyan: CYAN,\n        reset: RESET,\n        bold: BOLD,\n        gray: GRAY,\n        orange: ORANGE\n      }.freeze\n\n      class InvalidColorName < ArgumentError\n        extend T::Sig\n\n        sig { params(name: Symbol).void }\n        def initialize(name)\n          super\n          @name = name\n        end\n\n        sig { returns(String) }\n        def message\n          keys = Color.available.map(&:inspect).join(',')\n          \"invalid color: #{@name.inspect} \" \\\n            \"-- must be one of CLI::UI::Color.available (#{keys})\"\n        end\n      end\n\n      class << self\n        extend T::Sig\n\n        # Looks up a color code by name\n        #\n        # ==== Raises\n        # Raises a InvalidColorName if the color is not available\n        # You likely need to add it to the +MAP+ or you made a typo\n        #\n        # ==== Returns\n        # Returns a color code\n        #\n        sig { params(name: T.any(Symbol, String)).returns(Color) }\n        def lookup(name)\n          MAP.fetch(name.to_sym)\n        rescue KeyError\n          raise InvalidColorName, name.to_sym\n        end\n\n        # All available colors by name\n        #\n        sig { returns(T::Array[Symbol]) }\n        def available\n          MAP.keys\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "formatter.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire('cli/ui')\nrequire('strscan')\n\nmodule CLI\n  module UI\n    class Formatter\n      extend T::Sig\n\n      # Available mappings of formattings\n      # To use any of them, you can use {{<key>:<string>}}\n      # There are presentational (colours and formatters)\n      # and semantic (error, info, command) formatters available\n      #\n      SGR_MAP = {\n        # presentational\n        'red' => '31',\n        'green' => '32',\n        'yellow' => '33',\n        # default blue is low-contrast against black in some default terminal color scheme\n        'blue' => '94', # 9x = high-intensity fg color x\n        'magenta' => '35',\n        'cyan' => '36',\n        'gray' => '38;5;244',\n        'orange' => '38;5;214',\n        'white' => '97',\n        'bold' => '1',\n        'italic' => '3',\n        'underline' => '4',\n        'strikethrough' => '9',\n        'reset' => '0',\n\n        # semantic\n        'error' => '31', # red\n        'success' => '32', # success\n        'warning' => '33', # yellow\n        'info' => '94', # bright blue\n        'command' => '36' # cyan\n      }.freeze\n\n      BEGIN_EXPR = '{{'\n      END_EXPR   = '}}'\n\n      SCAN_WIDGET   = %r[@widget/(?<handle>\\w+):(?<args>.*?)}}]\n      SCAN_FUNCNAME = /\\w+:/\n      SCAN_GLYPH    = /.}}/\n      SCAN_BODY     = /\n        .*?\n        (\n          #{BEGIN_EXPR} |\n          #{END_EXPR}   |\n          \\z\n        )\n      /mx\n\n      DISCARD_BRACES = 0..-3\n\n      LITERAL_BRACES = Class.new\n\n      Stack = T.type_alias { T::Array[T.any(String, LITERAL_BRACES)] }\n\n      class FormatError < StandardError\n        extend T::Sig\n\n        sig { returns(String) }\n        attr_accessor :input\n\n        sig { returns(Integer) }\n        attr_accessor :index\n\n        sig { params(message: String, input: String, index: Integer).void }\n        def initialize(message, input, index)\n          super(message)\n          @input = input\n          @index = index\n        end\n      end\n\n      # Initialize a formatter with text.\n      #\n      # ===== Attributes\n      #\n      # * +text+ - the text to format\n      #\n      sig { params(text: String).void }\n      def initialize(text)\n        @text = text\n        @nodes = T.let([], T::Array[[String, Stack]])\n      end\n\n      # Format the text using a map.\n      #\n      # ===== Attributes\n      #\n      # * +sgr_map+ - the mapping of the formattings. Defaults to +SGR_MAP+\n      #\n      # ===== Options\n      #\n      # * +:enable_color+ - enable color output? Default is true unless output is redirected\n      #\n      sig { params(sgr_map: T::Hash[String, String], enable_color: T::Boolean).returns(String) }\n      def format(sgr_map = SGR_MAP, enable_color: CLI::UI.enable_color?)\n        @nodes.replace([])\n        stack = parse_body(StringScanner.new(@text))\n        prev_fmt = T.let(nil, T.nilable(Stack))\n        content = @nodes.each_with_object(+'') do |(text, fmt), str|\n          text = apply_format(text, fmt, sgr_map) if prev_fmt != fmt && enable_color\n          str << text\n          prev_fmt = fmt\n        end\n\n        stack.reject! { |e| e.is_a?(LITERAL_BRACES) }\n\n        return content unless enable_color\n        return content if stack == prev_fmt\n\n        unless stack.empty? && (@nodes.empty? || T.must(@nodes.last)[1].empty?)\n          content << apply_format('', stack, sgr_map)\n        end\n        content\n      end\n\n      private\n\n      sig { params(text: String, fmt: Stack, sgr_map: T::Hash[String, String]).returns(String) }\n      def apply_format(text, fmt, sgr_map)\n        sgr = fmt.each_with_object(+'0') do |name, str|\n          next if name.is_a?(LITERAL_BRACES)\n\n          begin\n            str << ';' << sgr_map.fetch(name)\n          rescue KeyError\n            raise FormatError.new(\n              \"invalid format specifier: #{name}\",\n              @text,\n              -1\n            )\n          end\n        end\n        CLI::UI::ANSI.sgr(sgr) + text\n      end\n\n      sig { params(sc: StringScanner, stack: Stack).returns(Stack) }\n      def parse_expr(sc, stack)\n        if (match = sc.scan(SCAN_GLYPH))\n          glyph_handle = T.must(match[0])\n          begin\n            glyph = Glyph.lookup(glyph_handle)\n            emit(glyph.char, [glyph.color.name.to_s])\n          rescue Glyph::InvalidGlyphHandle\n            index = sc.pos - 2 # rewind past '}}'\n            raise FormatError.new(\n              \"invalid glyph handle at index #{index}: '#{glyph_handle}'\",\n              @text,\n              index\n            )\n          end\n        elsif (match = sc.scan(SCAN_WIDGET))\n          match_data = T.must(SCAN_WIDGET.match(match)) # Regexp.last_match doesn't work here\n          widget_handle = T.must(match_data['handle'])\n          begin\n            widget = Widgets.lookup(widget_handle)\n            emit(widget.call(T.must(match_data['args'])), stack)\n          rescue Widgets::InvalidWidgetHandle\n            index = sc.pos - 2 # rewind past '}}'\n            raise(FormatError.new(\n                    \"invalid widget handle at index #{index}: '#{widget_handle}'\",\n                    @text,\n                    index\n                  ))\n          end\n        elsif (match = sc.scan(SCAN_FUNCNAME))\n          funcname = match.chop\n          stack.push(funcname)\n        else\n          # We read a {{ but it's not apparently Formatter syntax.\n          # We could error, but it's nicer to just pass through as text.\n          # We do kind of assume that the text will probably have balanced\n          # pairs of {{ }} at least.\n          emit('{{', stack)\n          stack.push(LITERAL_BRACES.new)\n        end\n        parse_body(sc, stack)\n        stack\n      end\n\n      sig { params(sc: StringScanner, stack: Stack).returns(Stack) }\n      def parse_body(sc, stack = [])\n        match = sc.scan(SCAN_BODY)\n        if match&.end_with?(BEGIN_EXPR)\n          emit(T.must(match[DISCARD_BRACES]), stack)\n          parse_expr(sc, stack)\n        elsif match&.end_with?(END_EXPR)\n          emit(T.must(match[DISCARD_BRACES]), stack)\n          emit('}}', stack) if stack.pop.is_a?(LITERAL_BRACES)\n          parse_body(sc, stack)\n        elsif match\n          emit(match, stack)\n        else\n          emit(sc.rest, stack)\n        end\n        stack\n      end\n\n      sig { params(text: String, stack: Stack).void }\n      def emit(text, stack)\n        return if text.empty?\n\n        @nodes << [text, stack.reject { |n| n.is_a?(LITERAL_BRACES) }]\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "frame_stack.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    module Frame\n      module FrameStack\n        class StackItem\n          extend T::Sig\n\n          sig { returns(CLI::UI::Color) }\n          attr_reader :color\n\n          sig { returns(CLI::UI::Frame::FrameStyle) }\n          attr_reader :frame_style\n\n          sig do\n            params(color_name: CLI::UI::Colorable, style_name: FrameStylable)\n              .void\n          end\n          def initialize(color_name, style_name)\n            @color = CLI::UI.resolve_color(color_name)\n            @frame_style = CLI::UI.resolve_style(style_name)\n          end\n        end\n\n        class << self\n          extend T::Sig\n\n          # Fetch all items off the frame stack\n          sig { returns(T::Array[StackItem]) }\n          def items\n            Thread.current[:cliui_frame_stack] ||= []\n          end\n\n          # Push a new item onto the frame stack.\n          #\n          # Either an item or a :color/:style pair should be pushed onto the stack.\n          #\n          # ==== Attributes\n          #\n          # * +item+ a +StackItem+ to push onto the stack. Defaults to nil\n          #\n          # ==== Options\n          #\n          # * +:color+ the color of the new stack item. Defaults to nil\n          # * +:style+ the style of the new stack item. Defaults to nil\n          #\n          # ==== Raises\n          #\n          # If both an item and a color/style pair are given, raises an +ArgumentError+\n          # If the given item is not a +StackItem+, raises an +ArgumentError+\n          #\n          sig do\n            params(\n              item: T.nilable(StackItem),\n              color: T.nilable(CLI::UI::Color),\n              style: T.nilable(CLI::UI::Frame::FrameStyle)\n            )\n              .void\n          end\n          def push(item = nil, color: nil, style: nil)\n            if color.nil? != style.nil? || item.nil? == color.nil?\n              raise ArgumentError, 'Must give one of item or color: and style:'\n            end\n\n            items.push(item || StackItem.new(T.must(color), T.must(style)))\n          end\n\n          # Removes and returns the last stack item off the stack\n          sig { returns(T.nilable(StackItem)) }\n          def pop\n            items.pop\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/frame/"
    },
    {
      "filename": "box.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    module Frame\n      module FrameStyle\n        module Box\n          extend FrameStyle\n\n          VERTICAL    = '┃'\n          HORIZONTAL  = '━'\n          DIVIDER     = '┣'\n          TOP_LEFT    = '┏'\n          BOTTOM_LEFT = '┗'\n\n          class << self\n            extend T::Sig\n\n            sig { override.returns(Symbol) }\n            def style_name\n              :box\n            end\n\n            sig { override.returns(String) }\n            def prefix\n              VERTICAL\n            end\n\n            # Draws the \"Open\" line for this frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            #\n            # ==== Output:\n            #\n            #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            #\n            sig { override.params(text: String, color: CLI::UI::Color).returns(String) }\n            def start(text, color:)\n              edge(text, color: color, first: TOP_LEFT)\n            end\n\n            # Draws a \"divider\" line for the current frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            #\n            # ==== Output:\n            #\n            #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            #\n            sig { override.params(text: String, color: CLI::UI::Color).returns(String) }\n            def divider(text, color:)\n              edge(text, color: color, first: DIVIDER)\n            end\n\n            # Draws the \"Close\" line for this frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            # * +:right_text+ - Text to print at the right of the line. Defaults to nil\n            #\n            # ==== Output:\n            #\n            #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n            #\n            sig { override.params(text: String, color: CLI::UI::Color, right_text: T.nilable(String)).returns(String) }\n            def close(text, color:, right_text: nil)\n              edge(text, color: color, right_text: right_text, first: BOTTOM_LEFT)\n            end\n\n            private\n\n            sig do\n              params(text: String, color: CLI::UI::Color, first: String,\n                     right_text: T.nilable(String)).returns(String)\n            end\n            def edge(text, color:, first:, right_text: nil)\n              color = CLI::UI.resolve_color(color)\n\n              preamble = +''\n\n              preamble << color.code if CLI::UI.enable_color?\n              preamble << first << (HORIZONTAL * 2)\n\n              unless text.empty?\n                preamble << ' ' << CLI::UI.resolve_text(\"{{#{color.name}:#{text}}}\") << ' '\n              end\n\n              termwidth = CLI::UI::Terminal.width\n\n              suffix = +''\n\n              suffix << ' ' << right_text << ' ' if right_text\n\n              preamble_width = CLI::UI::ANSI.printing_width(preamble)\n              preamble_start = Frame.prefix_width\n              # If prefix_width is non-zero, we need to subtract the width of\n              # the final space, since we're going to write over it.\n              preamble_start -= 1 if preamble_start.nonzero?\n              preamble_end = preamble_start + preamble_width\n\n              suffix_width = CLI::UI::ANSI.printing_width(suffix)\n              suffix_end   = termwidth - 2\n              suffix_start = suffix_end - suffix_width\n\n              if preamble_end > suffix_start\n                suffix = ''\n                # if preamble_end > termwidth\n                # we *could* truncate it, but let's just let it overflow to the\n                # next line and call it poor usage of this API.\n              end\n\n              o = +''\n\n              unless CLI::UI.enable_cursor?\n                linewidth = [0, termwidth - (preamble_end + suffix_width + 1)].max\n\n                o << color.code if CLI::UI.enable_color?\n                o << preamble\n                o << color.code if CLI::UI.enable_color?\n                o << (HORIZONTAL * linewidth)\n                o << color.code if CLI::UI.enable_color?\n                o << suffix\n                o << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n                o << \"\\n\"\n                return o\n              end\n\n              # Jumping around the line can cause some unwanted flashes\n              o << CLI::UI::ANSI.hide_cursor\n\n              # reset to column 1 so that things like ^C don't ruin formatting\n              o << \"\\r\"\n\n              # This code will print out a full line with the given preamble and\n              # suffix, as exemplified below.\n              #\n              # preamble_start                         suffix_start\n              # |                 preamble_end         |            suffix_end\n              # |                 |                    |            | termwidth\n              # |                 |                    |            | |\n              # V                 V                    V            V V\n              # --- Preamble text --------------------- suffix text --\n              o << color.code if CLI::UI.enable_color?\n              o << print_at_x(preamble_start, HORIZONTAL * (termwidth - preamble_start)) # draw a full line\n              o << print_at_x(preamble_start, preamble)\n              o << color.code if CLI::UI.enable_color?\n              o << print_at_x(suffix_start, suffix)\n              o << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n              o << CLI::UI::ANSI.show_cursor\n              o << \"\\n\"\n\n              o\n            end\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/frame/frame_style/"
    },
    {
      "filename": "bracket.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    module Frame\n      module FrameStyle\n        module Bracket\n          extend FrameStyle\n\n          VERTICAL    = '┃'\n          HORIZONTAL  = '━'\n          DIVIDER     = '┣'\n          TOP_LEFT    = '┏'\n          BOTTOM_LEFT = '┗'\n\n          class << self\n            extend T::Sig\n\n            sig { override.returns(Symbol) }\n            def style_name\n              :bracket\n            end\n\n            sig { override.returns(String) }\n            def prefix\n              VERTICAL\n            end\n\n            # Draws the \"Open\" line for this frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            #\n            # ==== Output\n            #\n            #   ┏━━ Open\n            #\n            sig { override.params(text: String, color: CLI::UI::Color).returns(String) }\n            def start(text, color:)\n              edge(text, color: color, first: TOP_LEFT)\n            end\n\n            # Draws a \"divider\" line for the current frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            #\n            # ==== Output:\n            #\n            #   ┣━━ Divider\n            #\n            sig { override.params(text: String, color: CLI::UI::Color).returns(String) }\n            def divider(text, color:)\n              edge(text, color: color, first: DIVIDER)\n            end\n\n            # Draws the \"Close\" line for this frame style\n            #\n            # ==== Attributes\n            #\n            # * +text+ - (required) the text/title to output in the frame\n            #\n            # ==== Options\n            #\n            # * +:color+ - (required) The color of the frame.\n            # * +:right_text+ - Text to print at the right of the line. Defaults to nil\n            #\n            # ==== Output:\n            #\n            #   ┗━━ Close\n            #\n            sig { override.params(text: String, color: CLI::UI::Color, right_text: T.nilable(String)).returns(String) }\n            def close(text, color:, right_text: nil)\n              edge(text, color: color, right_text: right_text, first: BOTTOM_LEFT)\n            end\n\n            private\n\n            sig do\n              params(text: String, color: CLI::UI::Color, first: String,\n                     right_text: T.nilable(String)).returns(String)\n            end\n            def edge(text, color:, first:, right_text: nil)\n              color = CLI::UI.resolve_color(color)\n\n              preamble = +''\n\n              preamble << color.code if CLI::UI.enable_color?\n              preamble << first << (HORIZONTAL * 2)\n\n              unless text.empty?\n                preamble << ' ' << CLI::UI.resolve_text(\"{{#{color.name}:#{text}}}\") << ' '\n              end\n\n              suffix = +''\n\n              suffix << ' ' << right_text << ' ' if right_text\n\n              o = +''\n\n              unless CLI::UI.enable_cursor?\n                o << color.code if CLI::UI.enable_color?\n                o << preamble\n                o << color.code if CLI::UI.enable_color?\n                o << suffix\n                o << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n                o << \"\\n\"\n\n                return o\n              end\n\n              preamble_start = Frame.prefix_width\n\n              # If prefix_width is non-zero, we need to subtract the width of\n              # the final space, since we're going to write over it.\n              preamble_start -= 1 if preamble_start.nonzero?\n\n              # Jumping around the line can cause some unwanted flashes\n              o << CLI::UI::ANSI.hide_cursor\n\n              # reset to column 1 so that things like ^C don't ruin formatting\n              o << \"\\r\"\n\n              o << color.code if CLI::UI.enable_color?\n              o << print_at_x(preamble_start, preamble)\n              o << color.code if CLI::UI.enable_color?\n              o << suffix\n              o << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n              o << CLI::UI::ANSI.show_cursor\n              o << \"\\n\"\n\n              o\n            end\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/frame/frame_style/"
    },
    {
      "filename": "frame_style.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui/frame'\n\nmodule CLI\n  module UI\n    module Frame\n      module FrameStyle\n        include Kernel\n        extend T::Sig\n        extend T::Helpers\n        abstract!\n\n        autoload(:Box, 'cli/ui/frame/frame_style/box')\n        autoload(:Bracket, 'cli/ui/frame/frame_style/bracket')\n\n        MAP = {\n          box: -> { FrameStyle::Box },\n          bracket: -> { FrameStyle::Bracket }\n        }.freeze\n\n        class << self\n          extend T::Sig\n\n          # Lookup a frame style via its name\n          #\n          # ==== Attributes\n          #\n          # * +symbol+ - frame style name to lookup\n          sig { params(name: T.any(String, Symbol)).returns(FrameStyle) }\n          def lookup(name)\n            MAP.fetch(name.to_sym).call\n          rescue KeyError\n            raise(InvalidFrameStyleName, name)\n          end\n        end\n\n        sig { abstract.returns(Symbol) }\n        def style_name; end\n\n        # Returns the character(s) that should be printed at the beginning\n        # of lines inside this frame\n        sig { abstract.returns(String) }\n        def prefix; end\n\n        # Returns the printing width of the prefix\n        sig { returns(Integer) }\n        def prefix_width\n          CLI::UI::ANSI.printing_width(prefix)\n        end\n\n        # Draws the \"Open\" line for this frame style\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - (required) The color of the frame.\n        #\n        sig { abstract.params(text: String, color: CLI::UI::Color).returns(String) }\n        def start(text, color:); end\n\n        # Draws the \"Close\" line for this frame style\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - (required) The color of the frame.\n        # * +:right_text+ - Text to print at the right of the line. Defaults to nil\n        #\n        sig { abstract.params(text: String, color: CLI::UI::Color, right_text: T.nilable(String)).returns(String) }\n        def close(text, color:, right_text: nil); end\n\n        # Draws a \"divider\" line for the current frame style\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - (required) The color of the frame.\n        #\n        sig { abstract.params(text: String, color: CLI::UI::Color).returns(String) }\n        def divider(text, color:); end\n\n        sig { params(x: Integer, str: String).returns(String) }\n        def print_at_x(x, str)\n          CLI::UI::ANSI.cursor_horizontal_absolute(1 + x) + str\n        end\n\n        class InvalidFrameStyleName < ArgumentError\n          extend T::Sig\n\n          sig { params(name: T.any(String, Symbol)).void }\n          def initialize(name)\n            super\n            @name = name\n          end\n\n          sig { returns(String) }\n          def message\n            keys = FrameStyle::MAP.keys.map(&:inspect).join(', ')\n            \"invalid frame style: #{@name.inspect} \" \\\n              '-- must be one of CLI::UI::Frame::FrameStyle::MAP ' \\\n              \"(#{keys})\"\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/frame/"
    },
    {
      "filename": "frame.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\nrequire 'cli/ui/frame/frame_stack'\nrequire 'cli/ui/frame/frame_style'\n\nmodule CLI\n  module UI\n    module Frame\n      class UnnestedFrameException < StandardError; end\n      DEFAULT_FRAME_COLOR = CLI::UI.resolve_color(:cyan)\n\n      class << self\n        extend T::Sig\n\n        sig { returns(FrameStyle) }\n        def frame_style\n          @frame_style ||= FrameStyle::Box\n        end\n\n        # Set the default frame style.\n        #\n        # Raises ArgumentError if +frame_style+ is not valid\n        #\n        # ==== Attributes\n        #\n        # * +symbol+ or +FrameStyle+ - the default frame style to use for frames\n        #\n        sig { params(frame_style: FrameStylable).void }\n        def frame_style=(frame_style)\n          @frame_style = CLI::UI.resolve_style(frame_style)\n        end\n\n        # Opens a new frame. Can be nested\n        # Can be invoked in two ways: block and blockless\n        # * In block form, the frame is closed automatically when the block returns\n        # * In blockless form, caller MUST call +Frame.close+ when the frame is logically done\n        # * Blockless form is strongly discouraged in cases where block form can be made to work\n        #\n        # https://user-images.githubusercontent.com/3074765/33799861-cb5dcb5c-dd01-11e7-977e-6fad38cee08c.png\n        #\n        # The return value of the block determines if the block is a \"success\" or a \"failure\"\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+\n        # * +:failure_text+ - If the block failed, what do we output? Defaults to nil\n        # * +:success_text+ - If the block succeeds, what do we output? Defaults to nil\n        # * +:timing+ - How long did the frame content take? Invalid for blockless. Defaults to true for the block form\n        # * +frame_style+ - The frame style to use for this frame\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout.\n        #\n        # ==== Example\n        #\n        # ===== Block Form (Assumes +CLI::UI::StdoutRouter.enable+ has been called)\n        #\n        #   CLI::UI::Frame.open('Open') { puts 'hi' }\n        #\n        # Default Output:\n        #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #   ┃ hi\n        #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ (0.0s) ━━\n        #\n        # ===== Blockless Form\n        #\n        #   CLI::UI::Frame.open('Open')\n        #\n        # Default Output:\n        #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #\n        #\n        sig do\n          type_parameters(:T).params(\n            text: String,\n            color: Colorable,\n            failure_text: T.nilable(String),\n            success_text: T.nilable(String),\n            timing: T.any(T::Boolean, Numeric),\n            frame_style: FrameStylable,\n            to: IOLike,\n            block: T.nilable(T.proc.returns(T.type_parameter(:T)))\n          ).returns(T.nilable(T.type_parameter(:T)))\n        end\n        def open(\n          text,\n          color: DEFAULT_FRAME_COLOR,\n          failure_text: nil,\n          success_text: nil,\n          timing: block_given?,\n          frame_style: self.frame_style,\n          to: $stdout\n        )\n          frame_style = CLI::UI.resolve_style(frame_style)\n          color = CLI::UI.resolve_color(color)\n\n          unless block_given?\n            if failure_text\n              raise ArgumentError, 'failure_text is not compatible with blockless invocation'\n            elsif success_text\n              raise ArgumentError, 'success_text is not compatible with blockless invocation'\n            elsif timing\n              raise ArgumentError, 'timing is not compatible with blockless invocation'\n            end\n          end\n\n          t_start = Time.now\n          CLI::UI.raw do\n            to.print(prefix.chop)\n            to.puts(frame_style.start(text, color: color))\n          end\n          FrameStack.push(color: color, style: frame_style)\n\n          return unless block_given?\n\n          closed = false\n          begin\n            success = false\n            success = yield\n          rescue StandardError\n            closed = true\n            t_diff = elapsed(t_start, timing)\n            close(failure_text, color: :red, elapsed: t_diff, to: to)\n            raise\n          else\n            success\n          ensure\n            unless closed\n              t_diff = elapsed(t_start, timing)\n              if T.unsafe(success) == false\n                close(failure_text, color: :red, elapsed: t_diff, to: to)\n              else\n                close(success_text, color: color, elapsed: t_diff, to: to)\n              end\n            end\n          end\n        end\n\n        # Adds a divider in a frame\n        # Used to separate information within a single frame\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+\n        # * +frame_style+ - The frame style to use for this frame\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout.\n        #\n        # ==== Example\n        #\n        #   CLI::UI::Frame.open('Open') { CLI::UI::Frame.divider('Divider') }\n        #\n        # Default Output:\n        #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #\n        # ==== Raises\n        #\n        # MUST be inside an open frame or it raises a +UnnestedFrameException+\n        #\n        sig do\n          params(\n            text: T.nilable(String),\n            color: T.nilable(Colorable),\n            frame_style: T.nilable(FrameStylable),\n            to: IOLike\n          ).void\n        end\n        def divider(text, color: nil, frame_style: nil, to: $stdout)\n          fs_item = FrameStack.pop\n          raise UnnestedFrameException, 'No frame nesting to unnest' unless fs_item\n\n          divider_color = CLI::UI.resolve_color(color || fs_item.color)\n          frame_style = CLI::UI.resolve_style(frame_style || fs_item.frame_style)\n\n          CLI::UI.raw do\n            to.print(prefix.chop)\n            to.puts(frame_style.divider(text.to_s, color: divider_color))\n          end\n\n          FrameStack.push(fs_item)\n        end\n\n        # Closes a frame\n        # Automatically called for a block-form +open+\n        #\n        # ==== Attributes\n        #\n        # * +text+ - (required) the text/title to output in the frame\n        #\n        # ==== Options\n        #\n        # * +:color+ - The color of the frame. Defaults to nil\n        # * +:elapsed+ - How long did the frame take? Defaults to nil\n        # * +frame_style+ - The frame style to use for this frame.  Defaults to nil\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout.\n        #\n        # ==== Example\n        #\n        #   CLI::UI::Frame.close('Close')\n        #\n        # Default Output:\n        #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n        #\n        # ==== Raises\n        #\n        # MUST be inside an open frame or it raises a +UnnestedFrameException+\n        #\n        sig do\n          params(\n            text: T.nilable(String),\n            color: T.nilable(Colorable),\n            elapsed: T.nilable(Numeric),\n            frame_style: T.nilable(FrameStylable),\n            to: IOLike\n          ).void\n        end\n        def close(text, color: nil, elapsed: nil, frame_style: nil, to: $stdout)\n          fs_item = FrameStack.pop\n          raise UnnestedFrameException, 'No frame nesting to unnest' unless fs_item\n\n          close_color = CLI::UI.resolve_color(color || fs_item.color)\n          frame_style = CLI::UI.resolve_style(frame_style || fs_item.frame_style)\n          elapsed_string = elapsed ? \"(#{elapsed.round(2)}s)\" : nil\n\n          CLI::UI.raw do\n            to.print(prefix.chop)\n            to.puts(frame_style.close(text.to_s, color: close_color, right_text: elapsed_string))\n          end\n        end\n\n        # Determines the prefix of a frame entry taking multi-nested frames into account\n        #\n        # ==== Options\n        #\n        # * +:color+ - The color of the prefix. Defaults to +Thread.current[:cliui_frame_color_override]+\n        #\n        sig { params(color: T.nilable(Colorable)).returns(String) }\n        def prefix(color: Thread.current[:cliui_frame_color_override])\n          (+'').tap do |output|\n            items = FrameStack.items\n\n            items[0..-2].to_a.each do |item|\n              output << item.color.code if CLI::UI.enable_color?\n              output << item.frame_style.prefix\n              output << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n            end\n\n            if (item = items.last)\n              final_color = color || item.color\n              output << CLI::UI.resolve_color(final_color).code if CLI::UI.enable_color?\n              output << item.frame_style.prefix\n              output << CLI::UI::Color::RESET.code if CLI::UI.enable_color?\n              output << ' '\n            end\n          end\n        end\n\n        # The width of a prefix given the number of Frames in the stack\n        sig { returns(Integer) }\n        def prefix_width\n          w = FrameStack.items.reduce(0) do |width, item|\n            width + item.frame_style.prefix_width\n          end\n\n          w.zero? ? w : w + 1\n        end\n\n        # Override a color for a given thread.\n        #\n        # ==== Attributes\n        #\n        # * +color+ - The color to override to\n        #\n        sig do\n          type_parameters(:T)\n            .params(color: Colorable, block: T.proc.returns(T.type_parameter(:T)))\n            .returns(T.type_parameter(:T))\n        end\n        def with_frame_color_override(color)\n          prev = Thread.current[:cliui_frame_color_override]\n          Thread.current[:cliui_frame_color_override] = color\n          yield\n        ensure\n          Thread.current[:cliui_frame_color_override] = prev\n        end\n\n        private\n\n        # If timing is:\n        #   Numeric: return it\n        #   false: return nil\n        #   true: defaults to Time.new\n        sig { params(start: Time, timing: T.any(Numeric, T::Boolean)).returns(T.nilable(Numeric)) }\n        def elapsed(start, timing)\n          return timing if timing.is_a?(Numeric)\n          return if timing.is_a?(FalseClass)\n\n          timing = Time.new\n          timing - start\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "glyph.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    class Glyph\n      extend T::Sig\n\n      class InvalidGlyphHandle < ArgumentError\n        extend T::Sig\n\n        sig { params(handle: String).void }\n        def initialize(handle)\n          super\n          @handle = handle\n        end\n\n        sig { returns(String) }\n        def message\n          keys = Glyph.available.join(',')\n          \"invalid glyph handle: #{@handle} \" \\\n            \"-- must be one of CLI::UI::Glyph.available (#{keys})\"\n        end\n      end\n\n      sig { returns(String) }\n      attr_reader :handle, :to_s, :fmt, :char\n\n      sig { returns(T.any(Integer, T::Array[Integer])) }\n      attr_reader :codepoint\n\n      sig { returns(Color) }\n      attr_reader :color\n\n      # Creates a new glyph\n      #\n      # ==== Attributes\n      #\n      # * +handle+ - The handle in the +MAP+ constant\n      # * +codepoint+ - The codepoint used to create the glyph (e.g. +0x2717+ for a ballot X)\n      # * +plain+ - A fallback plain string to be used in case glyphs are disabled\n      # * +color+ - What color to output the glyph. Check +CLI::UI::Color+ for options.\n      #\n      sig { params(handle: String, codepoint: T.any(Integer, T::Array[Integer]), plain: String, color: Color).void }\n      def initialize(handle, codepoint, plain, color)\n        @handle    = handle\n        @codepoint = codepoint\n        @color     = color\n        @char      = CLI::UI::OS.current.use_emoji? ? Array(codepoint).pack('U*') : plain\n        @to_s      = color.code + @char + Color::RESET.code\n        @fmt       = \"{{#{color.name}:#{@char}}}\"\n\n        MAP[handle] = self\n      end\n\n      # Mapping of glyphs to terminal output\n      MAP = {}.freeze\n      STAR      = new('*', 0x2b51,           '*', Color::YELLOW) # YELLOW SMALL STAR (⭑)\n      INFO      = new('i', 0x1d4be,          'i', Color::BLUE)   # BLUE MATHEMATICAL SCRIPT SMALL i (𝒾)\n      QUESTION  = new('?', 0x003f,           '?', Color::BLUE)   # BLUE QUESTION MARK (?)\n      CHECK     = new('v', 0x2713,           '√', Color::GREEN)  # GREEN CHECK MARK (✓)\n      X         = new('x', 0x2717,           'X', Color::RED)    # RED BALLOT X (✗)\n      BUG       = new('b', 0x1f41b,          '!', Color::WHITE)  # Bug emoji (🐛)\n      CHEVRON   = new('>', 0xbb,             '»', Color::YELLOW) # RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (»)\n      HOURGLASS = new('H', 0x29d6,           'H', Color::ORANGE) # HOURGLASS (⧖)\n      WARNING   = new('!', [0x26a0, 0xfe0f], '!', Color::YELLOW) # WARNING SIGN + VARIATION SELECTOR 16 (⚠️ )\n\n      class << self\n        extend T::Sig\n\n        # Looks up a glyph by name\n        #\n        # ==== Raises\n        # Raises a InvalidGlyphHandle if the glyph is not available\n        # You likely need to create it with +.new+ or you made a typo\n        #\n        # ==== Returns\n        # Returns a terminal output-capable string\n        #\n        sig { params(name: String).returns(Glyph) }\n        def lookup(name)\n          MAP.fetch(name.to_s)\n        rescue KeyError\n          raise InvalidGlyphHandle, name\n        end\n\n        # All available glyphs by name\n        #\n        sig { returns(T::Array[String]) }\n        def available\n          MAP.keys\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "os.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'rbconfig'\n\nmodule CLI\n  module UI\n    class OS\n      extend T::Sig\n\n      sig do\n        params(emoji: T::Boolean, color_prompt: T::Boolean, arrow_keys: T::Boolean,\n               shift_cursor: T::Boolean).void\n      end\n      def initialize(emoji: true, color_prompt: true, arrow_keys: true, shift_cursor: false)\n        @emoji = emoji\n        @color_prompt = color_prompt\n        @arrow_keys = arrow_keys\n        @shift_cursor = shift_cursor\n      end\n\n      sig { returns(T::Boolean) }\n      def use_emoji?\n        @emoji\n      end\n\n      sig { returns(T::Boolean) }\n      def use_color_prompt?\n        @color_prompt\n      end\n\n      sig { returns(T::Boolean) }\n      def suggest_arrow_keys?\n        @arrow_keys\n      end\n\n      sig { returns(T::Boolean) }\n      def shift_cursor_back_on_horizontal_absolute?\n        @shift_cursor\n      end\n\n      class << self\n        extend T::Sig\n\n        sig { returns(OS) }\n        def current\n          @current ||= case RbConfig::CONFIG['host_os']\n                       when /darwin/\n                         MAC\n                       when /linux/\n                         LINUX\n                       else\n                         unless !RUBY_PLATFORM.include?('cygwin') && ENV['OS'] == 'Windows_NT'\n                           raise \"Could not determine OS from host_os #{RbConfig::CONFIG['host_os']}\"\n                         end\n\n                         WINDOWS\n\n                       end\n        end\n      end\n\n      MAC = OS.new\n      LINUX = OS.new\n      WINDOWS = OS.new(emoji: false, color_prompt: false, arrow_keys: false, shift_cursor: true)\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "printer.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    class Printer\n      extend T::Sig\n\n      class << self\n        extend T::Sig\n\n        # Print a message to a stream with common utilities.\n        # Allows overriding the color, encoding, and target stream.\n        # By default, it formats the string using CLI:UI and rescues common stream errors.\n        #\n        # ==== Attributes\n        #\n        # * +msg+ - (required) the string to output. Can be frozen.\n        #\n        # ==== Options\n        #\n        # * +:frame_color+ - Override the frame color. Defaults to nil.\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with a puts method. Defaults to $stdout.\n        # * +:encoding+ - Force the output to be in a certain encoding. Defaults to UTF-8.\n        # * +:format+ - Whether to format the string using CLI::UI.fmt. Defaults to true.\n        # * +:graceful+ - Whether to gracefully ignore common I/O errors. Defaults to true.\n        # * +:wrap+ - Whether to wrap text at word boundaries to terminal width. Defaults to true.\n        #\n        # ==== Returns\n        # Returns whether the message was successfully printed,\n        # which can be useful if +:graceful+ is set to true.\n        #\n        # ==== Example\n        #\n        #   CLI::UI::Printer.puts('{{x}} Ouch', to: $stderr)\n        #\n        sig do\n          params(\n            msg: String,\n            frame_color: T.nilable(Colorable),\n            to: IOLike,\n            encoding: T.nilable(Encoding),\n            format: T::Boolean,\n            graceful: T::Boolean,\n            wrap: T::Boolean\n          ).returns(T::Boolean)\n        end\n        def puts(\n          msg,\n          frame_color: nil,\n          to: $stdout,\n          encoding: Encoding::UTF_8,\n          format: true,\n          graceful: true,\n          wrap: true\n        )\n          msg = (+msg).force_encoding(encoding) if encoding\n          msg = CLI::UI.fmt(msg) if format\n          msg = CLI::UI.wrap(msg) if wrap\n\n          if frame_color\n            CLI::UI::Frame.with_frame_color_override(frame_color) { to.puts(msg) }\n          else\n            to.puts(msg)\n          end\n\n          true\n        rescue Errno::EIO, Errno::EPIPE, IOError => e\n          raise(e) unless graceful\n\n          false\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "progress.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    class Progress\n      extend T::Sig\n\n      # A Cyan filled block\n      FILLED_BAR = \"\\e[46m\"\n      # A bright white block\n      UNFILLED_BAR = \"\\e[1;47m\"\n\n      class << self\n        extend T::Sig\n\n        # Add a progress bar to the terminal output\n        #\n        # https://user-images.githubusercontent.com/3074765/33799794-cc4c940e-dd00-11e7-9bdc-90f77ec9167c.gif\n        #\n        # ==== Example Usage:\n        #\n        # Set the percent to X\n        #   CLI::UI::Progress.progress do |bar|\n        #     bar.tick(set_percent: percent)\n        #   end\n        #\n        # Increase the percent by 1 percent\n        #   CLI::UI::Progress.progress do |bar|\n        #     bar.tick\n        #   end\n        #\n        # Increase the percent by X\n        #   CLI::UI::Progress.progress do |bar|\n        #     bar.tick(percent: 0.05)\n        #   end\n        #\n        # Update the title\n        #   CLI::UI::Progress.progress('Title') do |bar|\n        #     bar.tick(percent: 0.05)\n        #     bar.update_title('New title')\n        #   end\n        sig do\n          type_parameters(:T)\n            .params(\n              title: T.nilable(String),\n              width: Integer,\n              block: T.proc.params(bar: Progress).returns(T.type_parameter(:T))\n            )\n            .returns(T.type_parameter(:T))\n        end\n        def progress(title = nil, width: Terminal.width)\n          bar = Progress.new(title, width: width)\n          print(CLI::UI::ANSI.hide_cursor)\n          yield(bar)\n        ensure\n          puts(bar)\n          CLI::UI.raw do\n            print(ANSI.show_cursor)\n          end\n        end\n      end\n\n      # Initialize a progress bar. Typically used in a +Progress.progress+ block\n      #\n      # ==== Options\n      #\n      # * +:title+ - The title of the progress bar\n      # * +:width+ - The width of the terminal\n      #\n      sig { params(title: T.nilable(String), width: Integer).void }\n      def initialize(title = nil, width: Terminal.width)\n        @percent_done = T.let(0, Numeric)\n        @title = title\n        @max_width = width\n      end\n\n      # Set the progress of the bar. Typically used in a +Progress.progress+ block\n      #\n      # ==== Options\n      # One of the follow can be used, but not both together\n      #\n      # * +:percent+ - Increment progress by a specific percent amount\n      # * +:set_percent+ - Set progress to a specific percent\n      #\n      # *Note:* The +:percent+ and +:set_percent must be between 0.00 and 1.0\n      #\n      sig { params(percent: T.nilable(Numeric), set_percent: T.nilable(Numeric)).void }\n      def tick(percent: nil, set_percent: nil)\n        if percent && set_percent\n          raise ArgumentError,\n                'percent and set_percent cannot both be specified'\n        end\n\n        @percent_done += percent || 0.01\n        @percent_done = set_percent if set_percent\n        @percent_done = [@percent_done, 1.0].min # Make sure we can't go above 1.0\n\n        print(self)\n\n        printed_lines = @title ? 2 : 1\n        print(\"#{CLI::UI::ANSI.previous_lines(printed_lines)}\\n\")\n      end\n\n      # Update the progress bar title\n      #\n      # ==== Attributes\n      #\n      # * +new_title+ - title to change the progress bar to\n      #\n      sig { params(new_title: String).void }\n      def update_title(new_title)\n        @title = new_title\n      end\n\n      # Format the progress bar to be printed to terminal\n      #\n      sig { returns(String) }\n      def to_s\n        suffix = \" #{(@percent_done * 100).floor}%\".ljust(5)\n        workable_width = @max_width - Frame.prefix_width - suffix.size\n        filled = [(@percent_done * workable_width.to_f).ceil, 0].max\n        unfilled = [workable_width - filled, 0].max\n\n        title = CLI::UI.resolve_text(@title, truncate_to: @max_width - Frame.prefix_width) if @title\n        bar = CLI::UI.resolve_text([\n          FILLED_BAR + (' ' * filled),\n          UNFILLED_BAR + (' ' * unfilled),\n          CLI::UI::Color::RESET.code + suffix\n        ].join)\n\n        [title, bar].compact.join(\"\\n\")\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "interactive_options.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'io/console'\n\nmodule CLI\n  module UI\n    module Prompt\n      class InteractiveOptions\n        extend T::Sig\n\n        DONE = 'Done'\n        CHECKBOX_ICON = { false => '☐', true => '☑' }.freeze\n\n        class << self\n          extend T::Sig\n\n          # Prompts the user with options\n          # Uses an interactive session to allow the user to pick an answer\n          # Can use arrows, y/n, numbers (1/2), and vim bindings to control\n          # For more than 9 options, hitting 'e', ':', or 'G' will enter select\n          # mode allowing the user to type in longer numbers\n          # Pressing 'f' or '/' will allow the user to filter the results\n          #\n          # https://user-images.githubusercontent.com/3074765/33797984-0ebb5e64-dcdf-11e7-9e7e-7204f279cece.gif\n          #\n          # ==== Example Usage:\n          #\n          # Ask an interactive question\n          #   CLI::UI::Prompt::InteractiveOptions.call(%w(rails go python))\n          #\n          sig do\n            params(options: T::Array[String], multiple: T::Boolean,\n                   default: T.nilable(T.any(String, T::Array[String])))\n              .returns(T.any(String, T::Array[String]))\n          end\n          def call(options, multiple: false, default: nil)\n            list = new(options, multiple: multiple, default: default)\n            selected = list.call\n            case selected\n            when Array\n              selected.map { |s| T.must(options[s - 1]) }\n            else\n              T.must(options[selected - 1])\n            end\n          end\n        end\n\n        # Initializes a new +InteractiveOptions+\n        # Usually called from +self.call+\n        #\n        # ==== Example Usage:\n        #\n        #   CLI::UI::Prompt::InteractiveOptions.new(%w(rails go python))\n        #\n        sig do\n          params(options: T::Array[String], multiple: T::Boolean, default: T.nilable(T.any(String, T::Array[String])))\n            .void\n        end\n        def initialize(options, multiple: false, default: nil)\n          @options = options\n          @active = if default && (i = options.index(default))\n                      i + 1\n                    else\n                      1\n                    end\n          @marker = '>'\n          @answer = nil\n          @state = :root\n          @multiple = multiple\n          # Indicate that an extra line (the \"metadata\" line) is present and\n          # the terminal output should be drawn over when processing user input\n          @displaying_metadata = false\n          @filter = ''\n          # 0-indexed array representing if selected\n          # @options[0] is selected if @chosen[0]\n          if multiple\n            @chosen = if default\n                        @options.map { |option| default.include?(option) }\n                      else\n                        Array.new(@options.size) { false }\n                      end\n          end\n          @redraw = true\n          @presented_options = T.let([], T::Array[[String, T.nilable(Integer)]])\n        end\n\n        # Calls the +InteractiveOptions+ and asks the question\n        # Usually used from +self.call+\n        #\n        sig { returns(T.any(Integer, T::Array[Integer])) }\n        def call\n          calculate_option_line_lengths\n          CLI::UI.raw { print(ANSI.hide_cursor) }\n          while @answer.nil?\n            render_options\n            process_input_until_redraw_required\n            reset_position\n          end\n          clear_output\n\n          @answer\n        ensure\n          CLI::UI.raw do\n            print(ANSI.show_cursor)\n          end\n        end\n\n        private\n\n        sig { void }\n        def calculate_option_line_lengths\n          @terminal_width_at_calculation_time = CLI::UI::Terminal.width\n          # options will be an array of questions but each option can be multi-line\n          # so to get the # of lines, you need to join then split\n\n          # since lines may be longer than the terminal is wide, we need to\n          # determine how many extra lines would be taken up by them.\n          #\n          # To accomplish this we split the string by new lines and add the\n          # prefix to the first line. We use the options count as the number since\n          # it will be the widest number we will display, and we pad the others to\n          # align with it. Then we calculate how many lines would be needed to\n          # render the string based on the terminal width.\n          prefix = \"#{@marker} #{@options.count}. #{'☐ ' if @multiple}\"\n\n          @option_lengths = @options.map do |text|\n            next 1 if text.empty?\n\n            # Find the length of all the lines in this string\n            non_empty_line_lengths = \"#{prefix}#{text}\".split(\"\\n\").reject(&:empty?).map do |line|\n              CLI::UI.fmt(line, enable_color: false).length\n            end\n\n            # Finally, we need to calculate how many lines each one will take. We can do that by dividing each one\n            # by the width of the terminal, rounding up to the nearest natural number\n            non_empty_line_lengths.sum do |length|\n              (length.to_f / @terminal_width_at_calculation_time).ceil\n            end\n          end\n        end\n\n        sig { params(number_of_lines: Integer).void }\n        def reset_position(number_of_lines = num_lines)\n          # This will put us back at the beginning of the options\n          # When we redraw the options, they will be overwritten\n          CLI::UI.raw do\n            number_of_lines.times { print(ANSI.previous_line) }\n          end\n        end\n\n        sig { params(number_of_lines: Integer).void }\n        def clear_output(number_of_lines = num_lines)\n          CLI::UI.raw do\n            # Write over all lines with whitespace\n            number_of_lines.times { puts(' ' * CLI::UI::Terminal.width) }\n          end\n          reset_position(number_of_lines)\n\n          # Update if metadata is being displayed\n          # This must be done _after_ the output is cleared or it won't draw over\n          # the entire output\n          @displaying_metadata = display_metadata?\n        end\n\n        # Don't use this in place of +@displaying_metadata+, this updates too\n        # quickly to be useful when drawing to the screen.\n        sig { returns(T::Boolean) }\n        def display_metadata?\n          filtering? || selecting? || has_filter?\n        end\n\n        sig { returns(Integer) }\n        def num_lines\n          calculate_option_line_lengths if terminal_width_changed?\n\n          option_length = presented_options.reduce(0) do |total_length, (_, option_number)|\n            # Handle continuation markers and \"Done\" option when multiple is true\n            next total_length + 1 if option_number.nil? || option_number.zero?\n\n            total_length + @option_lengths[option_number - 1]\n          end\n\n          option_length + (@displaying_metadata ? 1 : 0)\n        end\n\n        sig { returns(T::Boolean) }\n        def terminal_width_changed?\n          @terminal_width_at_calculation_time != CLI::UI::Terminal.width\n        end\n\n        ESC = \"\\e\"\n        BACKSPACE = \"\\u007F\"\n        CTRL_C = \"\\u0003\"\n        CTRL_D = \"\\u0004\"\n\n        sig { void }\n        def up\n          active_index = @filtered_options.index { |_, num| num == @active } || 0\n\n          previous_visible = @filtered_options[active_index - 1]\n          previous_visible ||= @filtered_options.last\n\n          @active = previous_visible ? previous_visible.last : -1\n          @redraw = true\n        end\n\n        sig { void }\n        def down\n          active_index = @filtered_options.index { |_, num| num == @active } || 0\n\n          next_visible = @filtered_options[active_index + 1]\n          next_visible ||= @filtered_options.first\n\n          @active = next_visible ? next_visible.last : -1\n          @redraw = true\n        end\n\n        # n is 1-indexed selection\n        # n == 0 if \"Done\" was selected in @multiple mode\n        sig { params(n: Integer).void }\n        def select_n(n)\n          if @multiple\n            if n.zero?\n              @answer = []\n              @chosen.each_with_index do |selected, i|\n                @answer << (i + 1) if selected\n              end\n            else\n              @active = n\n              @chosen[n - 1] = !@chosen[n - 1]\n            end\n          elsif n.zero?\n            # Ignore pressing \"0\" when not in multiple mode\n          elsif should_enter_select_mode?(n)\n            # When we have more than 9 options, we need to enter select mode\n            # to avoid pre-selecting (e.g) 1 when the user wanted 10.\n            # This also applies to 2 and 20+ options, 3/30+, etc.\n            start_line_select\n            @active = n\n          else\n            @active = n\n            @answer = n\n          end\n          @redraw = true\n        end\n\n        sig { params(n: Integer).returns(T::Boolean) }\n        def should_enter_select_mode?(n)\n          # If we have less than 10 options, we don't need to enter select mode\n          # and we can just select the option directly. This just keeps the code easier\n          # by making the cases simpler to understand\n          return false if @options.length <= 9\n\n          # At this point we have 10+ options so always need to check if we should run.\n          # This can be simplified to checking if the length of options is >= to the option selected * 10:\n          # n == 1 && options.length >= 10 (1 * 10), n == 2 && options.length >= 20 (2 * 10), etc.\n          # which can be further simplified to just:\n          @options.length >= (n * 10)\n        end\n\n        sig { params(char: String).void }\n        def select_bool(char)\n          return unless (@options - %w[yes no]).empty?\n\n          index = T.must(@options.index { |o| o.start_with?(char) })\n          @active = index + 1\n          @answer = index + 1\n          @redraw = true\n        end\n\n        sig { params(char: String).void }\n        def build_selection(char)\n          @active = (@active.to_s + char).to_i\n          @redraw = true\n        end\n\n        sig { void }\n        def chop_selection\n          @active = @active.to_s.chop.to_i\n          @redraw = true\n        end\n\n        sig { params(char: String).void }\n        def update_search(char)\n          @redraw = true\n\n          # Control+D or Backspace on empty search closes search\n          if (char == CTRL_D) || (@filter.empty? && (char == BACKSPACE))\n            @filter = ''\n            @state = :root\n            return\n          end\n\n          if char == BACKSPACE\n            @filter.chop!\n          else\n            @filter += char\n          end\n        end\n\n        sig { void }\n        def select_current\n          # Prevent selection of invisible options\n          return unless presented_options.any? { |_, num| num == @active }\n\n          select_n(@active)\n        end\n\n        sig { void }\n        def process_input_until_redraw_required\n          @redraw = false\n          wait_for_user_input until @redraw\n        end\n\n        # rubocop:disable Style/WhenThen,Layout/SpaceBeforeSemicolon,Style/Semicolon\n        sig { void }\n        def wait_for_user_input\n          char = Prompt.read_char\n          @last_char = char\n\n          case char\n          when CTRL_C, nil ; raise Interrupt\n          end\n\n          max_digit = [@options.size, 9].min.to_s\n          case @state\n          when :root\n            case char\n            when ESC              ; @state = :esc\n            when 'k'              ; up\n            when 'j'              ; down\n            when 'e', ':', 'G'    ; start_line_select\n            when 'f', '/'         ; start_filter\n            when ('0'..max_digit) ; select_n(char.to_i)\n            when 'y', 'n'         ; select_bool(char)\n            when ' ', \"\\r\", \"\\n\"  ; select_current # <enter>\n            end\n          when :filter\n            case char\n            when ESC        ; @state = :esc\n            when \"\\r\", \"\\n\" ; select_current\n            when \"\\b\"       ; update_search(BACKSPACE) # Happens on Windows\n            else            ; update_search(char)\n            end\n          when :line_select\n            case char\n            when ESC             ; @state = :esc\n            when 'k'             ; up   ; @state = :root\n            when 'j'             ; down ; @state = :root\n            when 'e', ':', 'G', 'q' ; stop_line_select\n            when '0'..'9'        ; build_selection(char)\n            when BACKSPACE       ; chop_selection # Pop last input on backspace\n            when ' ', \"\\r\", \"\\n\" ; select_current\n            end\n          when :esc\n            case char\n            when '['      ; @state = :esc_bracket\n            else          ; raise Interrupt # unhandled escape sequence.\n            end\n          when :esc_bracket\n            @state = has_filter? ? :filter : :root\n            case char\n            when 'A'      ; up\n            when 'B'      ; down\n            when 'C'      ; # Ignore right key\n            when 'D'      ; # Ignore left key\n            else          ; raise Interrupt # unhandled escape sequence.\n            end\n          end\n        end\n        # rubocop:enable Style/WhenThen,Layout/SpaceBeforeSemicolon,Style/Semicolon\n\n        sig { returns(T::Boolean) }\n        def selecting?\n          @state == :line_select\n        end\n\n        sig { returns(T::Boolean) }\n        def filtering?\n          @state == :filter\n        end\n\n        sig { returns(T::Boolean) }\n        def has_filter?\n          !@filter.empty?\n        end\n\n        sig { void }\n        def start_filter\n          @state = :filter\n          @redraw = true\n        end\n\n        sig { void }\n        def start_line_select\n          @state  = :line_select\n          @active = 0\n          @redraw = true\n        end\n\n        sig { void }\n        def stop_line_select\n          @state = :root\n          @active = 1 if @active.zero?\n          @redraw = true\n        end\n\n        sig { params(recalculate: T::Boolean).returns(T::Array[[String, T.nilable(Integer)]]) }\n        def presented_options(recalculate: false)\n          return @presented_options unless recalculate\n\n          @presented_options = @options.zip(1..)\n          if has_filter?\n            @presented_options.select! { |option, _| option.downcase.include?(@filter.downcase) }\n          end\n\n          # Used for selection purposes\n          @presented_options.push([DONE, 0]) if @multiple\n          @filtered_options = @presented_options.dup\n\n          ensure_visible_is_active if has_filter?\n\n          # Must have more lines before the selection than we can display\n          if distance_from_start_to_selection > max_lines\n            @presented_options.shift(distance_from_start_to_selection - max_lines)\n            ensure_first_item_is_continuation_marker\n          end\n\n          # Must have more lines after the selection than we can display\n          if distance_from_selection_to_end > max_lines\n            @presented_options.pop(distance_from_selection_to_end - max_lines)\n            ensure_last_item_is_continuation_marker\n          end\n\n          while num_lines > max_lines\n            # try to keep the selection centered in the window:\n            if distance_from_selection_to_end > distance_from_start_to_selection\n              # selection is closer to top than bottom, so trim a row from the bottom\n              ensure_last_item_is_continuation_marker\n              @presented_options.delete_at(-2)\n            else\n              # selection is closer to bottom than top, so trim a row from the top\n              ensure_first_item_is_continuation_marker\n              @presented_options.delete_at(1)\n            end\n          end\n\n          @presented_options\n        end\n\n        sig { void }\n        def ensure_visible_is_active\n          return if presented_options.any? { |_, num| num == @active }\n\n          @active = presented_options.first&.last.to_i\n        end\n\n        sig { returns(Integer) }\n        def distance_from_selection_to_end\n          @presented_options.count - index_of_active_option\n        end\n\n        sig { returns(Integer) }\n        def distance_from_start_to_selection\n          index_of_active_option\n        end\n\n        sig { returns(Integer) }\n        def index_of_active_option\n          @presented_options.index { |_, num| num == @active }.to_i\n        end\n\n        sig { void }\n        def ensure_last_item_is_continuation_marker\n          @presented_options.push(['...', nil]) if @presented_options.last&.last\n        end\n\n        sig { void }\n        def ensure_first_item_is_continuation_marker\n          @presented_options.unshift(['...', nil]) if @presented_options.first&.last\n        end\n\n        sig { returns(Integer) }\n        def max_lines\n          CLI::UI::Terminal.height - (@displaying_metadata ? 3 : 2) # Keeps a one line question visible\n        end\n\n        sig { void }\n        def render_options\n          previously_displayed_lines = num_lines\n\n          @displaying_metadata = display_metadata?\n\n          options = presented_options(recalculate: true)\n\n          clear_output(previously_displayed_lines) if previously_displayed_lines > num_lines\n\n          max_num_length = (@options.size + 1).to_s.length\n\n          metadata_text = if selecting?\n                            select_text = @active\n                            if @active.zero?\n                              select_text = '{{info:e, q, or up/down anytime to exit}}'\n                            end\n                            \"Select: #{select_text}\"\n                          elsif filtering? || has_filter?\n                            filter_text = @filter\n                            if @filter.empty?\n                              filter_text = '{{info:Ctrl-D anytime or Backspace now to exit}}'\n                            end\n                            \"Filter: #{filter_text}\"\n                          end\n\n          if metadata_text\n            puts CLI::UI.fmt(\"  {{green:#{metadata_text}}}#{ANSI.clear_to_end_of_line}\")\n          end\n\n          options.each do |choice, num|\n            is_chosen = @multiple && num && @chosen[num - 1] && num != 0\n\n            padding = ' ' * (max_num_length - num.to_s.length)\n            message = \"  #{num}#{num ? '.' : ' '}#{padding}\"\n\n            format = '%s'\n            # If multiple, bold selected. If not multiple, do not bold any options.\n            # Bolding options can cause confusion as some users may perceive bold white (default color) as selected\n            # rather than the actual selected color.\n            format = \"{{bold:#{format}}}\" if @multiple && is_chosen\n            format = \"{{cyan:#{format}}}\" if @multiple && is_chosen && num != @active\n            format = \" #{format}\"\n\n            message += format(format, CHECKBOX_ICON[is_chosen]) if @multiple && num && num.positive?\n            message += format_choice(format, choice)\n\n            if num == @active\n\n              color = filtering? || selecting? ? 'green' : 'blue'\n              message = message.split(\"\\n\").map do |l|\n                \"{{#{color}:#{@marker} #{l.strip}}}\"\n              end.join(\"\\n\")\n            end\n\n            puts CLI::UI.fmt(message)\n          end\n        end\n\n        sig { params(format: String, choice: String).returns(String) }\n        def format_choice(format, choice)\n          eol = CLI::UI::ANSI.clear_to_end_of_line\n          lines = choice.split(\"\\n\")\n\n          return eol if lines.empty? # Handle blank options\n\n          lines.map! { |l| format(format, l) + eol }\n          lines.join(\"\\n\")\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/prompt/"
    },
    {
      "filename": "options_handler.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    module Prompt\n      # A class that handles the various options of an InteractivePrompt and their callbacks\n      class OptionsHandler\n        extend T::Sig\n\n        sig { void }\n        def initialize\n          @options = {}\n        end\n\n        sig { returns(T::Array[String]) }\n        def options\n          @options.keys\n        end\n\n        sig { params(option: String, handler: T.proc.params(option: String).returns(String)).void }\n        def option(option, &handler)\n          @options[option] = handler\n        end\n\n        sig { params(options: T.any(T::Array[String], String)).returns(String) }\n        def call(options)\n          case options\n          when Array\n            options.map { |option| @options[option].call(options) }\n          else\n            @options[options].call(options)\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/prompt/"
    },
    {
      "filename": "prompt.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\nbegin\n  require 'reline' # For 2.7+\nrescue LoadError\n  require 'readline' # For 2.6\n  Object.const_set(:Reline, Readline)\nend\n\nmodule CLI\n  module UI\n    module Prompt\n      autoload :InteractiveOptions,  'cli/ui/prompt/interactive_options'\n      autoload :OptionsHandler,      'cli/ui/prompt/options_handler'\n\n      class << self\n        extend T::Sig\n\n        sig { returns(Color) }\n        def instructions_color\n          @instructions_color ||= Color::YELLOW\n        end\n\n        # Set the instructions color.\n        #\n        # ==== Attributes\n        #\n        # * +color+ - the color to use for prompt instructions\n        #\n        sig { params(color: Colorable).void }\n        def instructions_color=(color)\n          @instructions_color = CLI::UI.resolve_color(color)\n        end\n\n        # Ask a user a question with either free form answer or a set of answers (multiple choice)\n        # Can use arrows, y/n, numbers (1/2), and vim bindings to control multiple choice selection\n        # Do not use this method for yes/no questions. Use +confirm+\n        #\n        # * Handles free form answers (options are nil)\n        # * Handles default answers for free form text\n        # * Handles file auto completion for file input\n        # * Handles interactively choosing answers using +InteractiveOptions+\n        #\n        # https://user-images.githubusercontent.com/3074765/33799822-47f23302-dd01-11e7-82f3-9072a5a5f611.png\n        #\n        # ==== Attributes\n        #\n        # * +question+ - (required) The question to ask the user\n        #\n        # ==== Options\n        #\n        # * +:options+ - Options that the user may select from. Will use +InteractiveOptions+ to do so.\n        # * +:default+ - The default answer to the question (e.g. they just press enter and don't input anything)\n        # * +:is_file+ - Tells the input to use file auto-completion (tab completion)\n        # * +:allow_empty+ - Allows the answer to be empty\n        # * +:multiple+ - Allow multiple options to be selected\n        # * +:filter_ui+ - Enable option filtering (default: true)\n        # * +:select_ui+ - Enable long-form option selection (default: true)\n        #\n        # Note:\n        # * +:options+ or providing a +Block+ conflicts with +:default+ and +:is_file+,\n        #              you cannot set options with either of these keywords\n        # * +:default+ conflicts with +:allow_empty:, you cannot set these together\n        # * +:options+ conflicts with providing a +Block+ , you may only set one\n        # * +:multiple+ can only be used with +:options+ or a +Block+; it is ignored, otherwise.\n        #\n        # ==== Block (optional)\n        #\n        # * A Proc that provides a +OptionsHandler+ and uses the public +:option+ method to add options and their\n        #   respective handlers\n        #\n        # ==== Return Value\n        #\n        # * If a +Block+ was not provided, the selected option or response to the free form question will be returned\n        # * If a +Block+ was provided, the evaluated value of the +Block+ will be returned\n        #\n        # ==== Example Usage:\n        #\n        # Free form question\n        #   CLI::UI::Prompt.ask('What color is the sky?')\n        #\n        # Free form question with a file answer\n        #   CLI::UI::Prompt.ask('Where is your Gemfile located?', is_file: true)\n        #\n        # Free form question with a default answer\n        #   CLI::UI::Prompt.ask('What color is the sky?', default: 'blue')\n        #\n        # Free form question when the answer can be empty\n        #   CLI::UI::Prompt.ask('What is your opinion on this question?', allow_empty: true)\n        #\n        # Interactive (multiple choice) question\n        #   CLI::UI::Prompt.ask('What kind of project is this?', options: %w(rails go ruby python))\n        #\n        # Interactive (multiple choice) question with defined handlers\n        #   CLI::UI::Prompt.ask('What kind of project is this?') do |handler|\n        #     handler.option('rails')  { |selection| selection }\n        #     handler.option('go')     { |selection| selection }\n        #     handler.option('ruby')   { |selection| selection }\n        #     handler.option('python') { |selection| selection }\n        #   end\n        #\n        sig do\n          params(\n            question: String,\n            options: T.nilable(T::Array[String]),\n            default: T.nilable(T.any(String, T::Array[String])),\n            is_file: T::Boolean,\n            allow_empty: T::Boolean,\n            multiple: T::Boolean,\n            filter_ui: T::Boolean,\n            select_ui: T::Boolean,\n            options_proc: T.nilable(T.proc.params(handler: OptionsHandler).void)\n          ).returns(T.any(String, T::Array[String]))\n        end\n        def ask(\n          question,\n          options: nil,\n          default: nil,\n          is_file: false,\n          allow_empty: true,\n          multiple: false,\n          filter_ui: true,\n          select_ui: true,\n          &options_proc\n        )\n          has_options = !(options || block_given?).nil?\n          if has_options && is_file\n            raise(ArgumentError,\n                  'conflicting arguments: is_file is only useful when options are not provided')\n          end\n\n          if options && multiple && default && !(Array(default) - options).empty?\n            raise(ArgumentError,\n                  'conflicting arguments: default should only include elements present in options')\n          end\n\n          if multiple && !has_options\n            raise(ArgumentError,\n                  'conflicting arguments: options must be provided when multiple is true')\n          end\n\n          if !multiple && default.is_a?(Array)\n            raise(ArgumentError,\n                  'conflicting arguments: multiple defaults may only be provided when multiple is true')\n          end\n\n          if has_options\n            ask_interactive(\n              question,\n              options,\n              multiple: multiple,\n              default: default,\n              filter_ui: filter_ui,\n              select_ui: select_ui,\n              &options_proc\n            )\n          else\n            ask_free_form(question, T.cast(default, T.nilable(String)), is_file, allow_empty)\n          end\n        end\n\n        # Asks the user for a single-line answer, without displaying the characters while typing.\n        # Typically used for password prompts\n        #\n        # ==== Return Value\n        #\n        # The password, without a trailing newline.\n        # If the user simply presses \"Enter\" without typing any password, this will return an empty string.\n        sig { params(question: String).returns(String) }\n        def ask_password(question)\n          require 'io/console'\n\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            $stdout.print(CLI::UI.fmt(\"{{?}} #{question}\")) # Do not use puts_question to avoid the new line.\n\n            # noecho interacts poorly with Readline under system Ruby, so do a manual `gets` here.\n            # No fancy Readline integration (like echoing back) is required for a password prompt anyway.\n            password = $stdin.noecho do\n              # Chomp will remove the one new line character added by `gets`, without touching potential extra spaces:\n              # \" 123 \\n\".chomp => \" 123 \"\n              $stdin.gets.to_s.chomp\n            end\n\n            $stdout.puts # Complete the line\n\n            password\n          end\n        end\n\n        # Asks the user a yes/no question.\n        # Can use arrows, y/n, numbers (1/2), and vim bindings to control\n        #\n        # ==== Example Usage:\n        #\n        # Confirmation question\n        #   CLI::UI::Prompt.confirm('Is the sky blue?')\n        #\n        #   CLI::UI::Prompt.confirm('Do a dangerous thing?', default: false)\n        #\n        sig { params(question: String, default: T::Boolean).returns(T::Boolean) }\n        def confirm(question, default: true)\n          ask_interactive(question, default ? %w[yes no] : %w[no yes],\n                          filter_ui: false) == 'yes'\n        end\n\n        # Present the user with a message and wait for any key to be pressed, returning the pressed key.\n        #\n        # ==== Example Usage:\n        #\n        #   CLI::UI::Prompt.any_key # Press any key to continue...\n        #\n        #   CLI::UI::Prompt.any_key('Press RETURN to continue...') # Then check if that's what they pressed\n        sig { params(prompt: String).returns(T.nilable(String)) }\n        def any_key(prompt = 'Press any key to continue...')\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            puts_question(prompt)\n            read_char\n          end\n        end\n\n        # Wait for any key to be pressed, returning the pressed key.\n        sig { returns(T.nilable(String)) }\n        def read_char\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            if $stdin.tty? && !ENV['TEST']\n              require 'io/console'\n              $stdin.getch # raw mode for tty\n            else\n              $stdin.getc # returns nil at end of input\n            end\n          end\n        rescue Errno::EIO, Errno::EPIPE, IOError\n          \"\\e\"\n        end\n\n        private\n\n        sig do\n          params(question: String, default: T.nilable(String), is_file: T::Boolean, allow_empty: T::Boolean)\n            .returns(String)\n        end\n        def ask_free_form(question, default, is_file, allow_empty)\n          if default && !allow_empty\n            raise(ArgumentError, 'conflicting arguments: default enabled but allow_empty is false')\n          end\n\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            if default\n              puts_question(\"#{question} (empty = #{default})\")\n            else\n              puts_question(question)\n            end\n\n            # Ask a free form question\n            loop do\n              line = readline(is_file: is_file)\n\n              if line.empty? && default\n                write_default_over_empty_input(default)\n                return default\n              end\n\n              return line if !line.empty? || allow_empty\n            end\n          end\n        end\n\n        sig do\n          params(\n            question: String,\n            options: T.nilable(T::Array[String]),\n            multiple: T::Boolean,\n            default: T.nilable(T.any(String, T::Array[String])),\n            filter_ui: T::Boolean,\n            select_ui: T::Boolean\n          ).returns(T.any(String, T::Array[String]))\n        end\n        def ask_interactive(question, options = nil, multiple: false, default: nil,\n                            filter_ui: true, select_ui: true)\n          if options && block_given?\n            raise(ArgumentError,\n                  'conflicting arguments: options and block given')\n          end\n\n          options ||= if block_given?\n                        handler = OptionsHandler.new\n                        yield handler\n                        handler.options\n                      end\n\n          raise(ArgumentError, 'insufficient options') if options.nil? || options.empty?\n\n          navigate_text = if CLI::UI::OS.current.suggest_arrow_keys?\n                            'Choose with ↑ ↓ ⏎'\n                          else\n                            \"Navigate up with 'k' and down with 'j', press Enter to select\"\n                          end\n\n          instructions = (multiple ? 'Toggle options. ' : '') + navigate_text\n          instructions += \", filter with 'f'\" if filter_ui\n          instructions += \", enter option with 'e'\" if select_ui && (options.size > 9)\n\n          resp = T.let([], T.any(String, T::Array[String]))\n\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            puts_question(\"#{question} \" + instructions_color.code + \"(#{instructions})\" + Color::RESET.code)\n            resp = interactive_prompt(options, multiple: multiple, default: default)\n\n            # Clear the line\n            print(ANSI.previous_line + ANSI.clear_to_end_of_line)\n            # Force StdoutRouter to prefix\n            print(\"#{ANSI.previous_line}\\n\")\n\n            # reset the question to include the answer\n            resp_text = case resp\n                        when Array\n                          case resp.size\n                          when 0\n                            '<nothing>'\n                          when 1..2\n                            resp.join(' and ')\n                          else\n                            \"#{resp.size} items\"\n                          end\n                        else\n                          resp\n                        end\n            puts_question(\"#{question} (You chose: {{italic:#{resp_text}}})\")\n          end\n\n          if block_given?\n            T.must(handler).call(resp)\n          else\n            resp\n          end\n        end\n\n        # Useful for stubbing in tests\n        sig do\n          params(options: T::Array[String], multiple: T::Boolean,\n                 default: T.nilable(T.any(T::Array[String], String)))\n            .returns(T.any(T::Array[String], String))\n        end\n        def interactive_prompt(options, multiple: false, default: nil)\n          CLI::UI::StdoutRouter::Capture.in_alternate_screen do\n            InteractiveOptions.call(options, multiple: multiple, default: default)\n          end\n        end\n\n        sig { params(default: String).void }\n        def write_default_over_empty_input(default)\n          CLI::UI.raw do\n            warn(\n              \"#{CLI::UI::ANSI.cursor_up(1)}\\r#{CLI::UI::ANSI.cursor_forward(4)}#{default}#{CLI::UI::Color::RESET.code}\"\n            )\n          end\n        end\n\n        sig { params(str: String).void }\n        def puts_question(str)\n          $stdout.puts(CLI::UI.fmt(\"{{?}} #{str}\"))\n        end\n\n        sig { params(is_file: T::Boolean).returns(String) }\n        def readline(is_file: false)\n          if is_file\n            Reline.completion_proc = proc do |input|\n              directory = input[-1] == '/' ? input : File.dirname(input)\n              filename = input[-1] == '/' ? '' : File.basename(input)\n\n              (Dir.entries(directory).select do |fp|\n                fp.start_with?(filename)\n              end - (input[-1] == '.' ? [] : ['.', '..'])).map do |fp|\n                File.join(directory, fp).delete_prefix('./')\n              end\n            end\n            Reline.completion_append_character = ''\n          else\n            Reline.completion_proc = proc {}\n            Reline.completion_append_character = ' '\n          end\n\n          # because Readline is a C library, CLI::UI's hooks into $stdout don't\n          # work. We could work around this by having CLI::UI use a pipe and a\n          # thread to manage output, but the current strategy feels like a\n          # better tradeoff.\n          prefix = CLI::UI::Frame.prefix\n          # If a prompt is interrupted on Windows it locks the colour of the terminal from that point on, so we should\n          # not change the colour here.\n          prompt = prefix + CLI::UI.fmt('{{blue:> }}')\n          prompt += CLI::UI::Color::YELLOW.code if CLI::UI::OS.current.use_color_prompt?\n\n          begin\n            line = Reline.readline(prompt, true)\n            print(CLI::UI::Color::RESET.code)\n            line.to_s.chomp\n          rescue Interrupt\n            CLI::UI.raw { warn(\"^C#{CLI::UI::Color::RESET.code}\") }\n            raise\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "reentrant_mutex.rb",
      "content": "# frozen_string_literal: true\n\n# Copyright (c) 2014 Boris Bera\n#\n# MIT License\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n# Sourced from https://github.com/dotboris/reentrant_mutex\nmodule CLI\n  module UI\n    class ReentrantMutex < Mutex\n      def initialize\n        @count_mutex = Mutex.new\n        @counts = Hash.new(0)\n\n        super\n      end\n\n      def synchronize\n        raise ThreadError, 'Must be called with a block' unless block_given?\n\n        begin\n          lock\n          yield\n        ensure\n          unlock\n        end\n      end\n\n      def lock\n        c = increase_count Thread.current\n        super if c <= 1\n      end\n\n      def unlock\n        c = decrease_count Thread.current\n        return unless c <= 0\n\n        super\n        delete_count Thread.current\n      end\n\n      def count\n        @count_mutex.synchronize { @counts[Thread.current] }\n      end\n\n      private\n\n      def increase_count(thread)\n        @count_mutex.synchronize { @counts[thread] += 1 }\n      end\n\n      def decrease_count(thread)\n        @count_mutex.synchronize { @counts[thread] -= 1 }\n      end\n\n      def delete_count(thread)\n        @count_mutex.synchronize { @counts.delete(thread) }\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "sorbet_runtime_stub.rb",
      "content": "# typed: ignore\n# frozen_string_literal: true\n\nmodule T\n  class << self\n    def absurd(value); end\n    def all(type_a, type_b, *types); end\n    def any(type_a, type_b, *types); end\n    def attached_class; end\n    def class_of(klass); end\n    def enum(values); end\n    def nilable(type); end\n    def noreturn; end\n    def self_type; end\n    def type_alias(type = nil, &); end\n    def type_parameter(name); end\n    def untyped; end\n\n    def assert_type!(value, _type, _checked: true)\n      value\n    end\n\n    def cast(value, _type, _checked: true)\n      value\n    end\n\n    def let(value, _type, _checked: true)\n      value\n    end\n\n    def must(arg, _msg = nil)\n      arg\n    end\n\n    def proc\n      T::Proc.new\n    end\n\n    def reveal_type(value)\n      value\n    end\n\n    def unsafe(value)\n      value\n    end\n  end\n\n  module Sig\n    def sig(arg0 = nil, &); end\n  end\n\n  module Helpers\n    def abstract!;  end\n    def interface!; end\n    def final!; end\n    def sealed!; end\n    def mixes_in_class_methods(mod); end\n  end\n\n  module Generic\n    include(T::Helpers)\n\n    def type_parameters(*params); end\n    def type_member(variance = :invariant, fixed: nil, lower: nil, upper: BasicObject); end\n    def type_template(variance = :invariant, fixed: nil, lower: nil, upper: BasicObject); end\n\n    def [](*_types)\n      self\n    end\n  end\n\n  module Array\n    class << self\n      def [](type); end\n    end\n  end\n\n  Boolean = Object.new.freeze\n\n  module Configuration\n    class << self\n      def call_validation_error_handler(signature, opts); end\n      def call_validation_error_handler=(value); end\n      def default_checked_level=(default_checked_level); end\n      def enable_checking_for_sigs_marked_checked_tests; end\n      def enable_final_checks_on_hooks; end\n      def enable_legacy_t_enum_migration_mode; end\n      def reset_final_checks_on_hooks; end\n      def hard_assert_handler(str, extra); end\n      def hard_assert_handler=(value); end\n      def inline_type_error_handler(error); end\n      def inline_type_error_handler=(value); end\n      def log_info_handler(str, extra); end\n      def log_info_handler=(value); end\n      def scalar_types; end\n      def scalar_types=(values); end\n      # rubocop:disable Naming/InclusiveLanguage\n      def sealed_violation_whitelist; end\n      def sealed_violation_whitelist=(sealed_violation_whitelist); end\n      # rubocop:enable Naming/InclusiveLanguage\n      def sig_builder_error_handler(error, location); end\n      def sig_builder_error_handler=(value); end\n      def sig_validation_error_handler(error, opts); end\n      def sig_validation_error_handler=(value); end\n      def soft_assert_handler(str, extra); end\n      def soft_assert_handler=(value); end\n    end\n  end\n\n  module Enumerable\n    class << self\n      def [](type); end\n    end\n  end\n\n  module Enumerator\n    class << self\n      def [](type); end\n    end\n  end\n\n  module Hash\n    class << self\n      def [](keys, values); end\n    end\n  end\n\n  class Proc\n    def bind(*_)\n      self\n    end\n\n    def params(*_param)\n      self\n    end\n\n    def void\n      self\n    end\n\n    def returns(_type)\n      self\n    end\n  end\n\n  module Range\n    class << self\n      def [](type); end\n    end\n  end\n\n  module Set\n    class << self\n      def [](type); end\n    end\n  end\n\n  class << self\n    def const_added(name)\n      super\n      raise 'When using both cli-ui and sorbet, you must require sorbet before cli-ui'\n    end\n\n    def method_added(name)\n      super\n      raise 'When using both cli-ui and sorbet, you must require sorbet before cli-ui'\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "async.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    module Spinner\n      class Async\n        extend T::Sig\n\n        class << self\n          extend T::Sig\n\n          # Convenience method for +initialize+\n          #\n          sig { params(title: String).returns(Async) }\n          def start(title)\n            new(title)\n          end\n        end\n\n        # Initializes a new asynchronous spinner with no specific end.\n        # Must call +.stop+ to end the spinner\n        #\n        # ==== Attributes\n        #\n        # * +title+ - Title of the spinner to use\n        #\n        # ==== Example Usage:\n        #\n        #   CLI::UI::Spinner::Async.new('Title')\n        #\n        sig { params(title: String).void }\n        def initialize(title)\n          sg = CLI::UI::Spinner::SpinGroup.new\n          @m = Mutex.new\n          @cv = ConditionVariable.new\n          sg.add(title) { @m.synchronize { @cv.wait(@m) } }\n          @t = Thread.new { sg.wait }\n        end\n\n        # Stops an asynchronous spinner\n        #\n        sig { returns(T::Boolean) }\n        def stop\n          @m.synchronize { @cv.signal }\n          @t.value\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/spinner/"
    },
    {
      "filename": "spin_group.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire_relative '../work_queue'\n\nmodule CLI\n  module UI\n    module Spinner\n      class SpinGroup\n        DEFAULT_FINAL_GLYPH = ->(success) { success ? CLI::UI::Glyph::CHECK : CLI::UI::Glyph::X }\n\n        class << self\n          extend T::Sig\n\n          sig { returns(Mutex) }\n          attr_reader :pause_mutex\n\n          sig { returns(T::Boolean) }\n          def paused?\n            @paused\n          end\n\n          sig do\n            type_parameters(:T)\n              .params(block: T.proc.returns(T.type_parameter(:T)))\n              .returns(T.type_parameter(:T))\n          end\n          def pause_spinners(&)\n            previous_paused = T.let(nil, T.nilable(T::Boolean))\n            @pause_mutex.synchronize do\n              previous_paused = @paused\n              @paused = true\n            end\n            yield\n          ensure\n            @pause_mutex.synchronize do\n              @paused = previous_paused\n            end\n          end\n        end\n\n        @pause_mutex = Mutex.new\n        @paused = false\n\n        extend T::Sig\n\n        # Initializes a new spin group\n        # This lets you add +Task+ objects to the group to multi-thread work\n        #\n        # ==== Options\n        #\n        # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true\n        # * +:interrupt_debrief+ - Automatically debrief on interrupt. Default to false\n        # * +:max_concurrent+ - Maximum number of concurrent tasks. Default is 0 (effectively unlimited)\n        # * +:work_queue+ - Custom WorkQueue instance. If not provided, a new one will be created\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout\n        #\n        # ==== Example Usage\n        #\n        #  CLI::UI::SpinGroup.new do |spin_group|\n        #    spin_group.add('Title')   { |spinner| sleep 3.0 }\n        #    spin_group.add('Title 2') { |spinner| sleep 3.0; spinner.update_title('New Title'); sleep 3.0 }\n        #  end\n        #\n        # Output:\n        #\n        # https://user-images.githubusercontent.com/3074765/33798558-c452fa26-dce8-11e7-9e90-b4b34df21a46.gif\n        #\n        sig do\n          params(\n            auto_debrief: T::Boolean,\n            interrupt_debrief: T::Boolean,\n            max_concurrent: Integer,\n            work_queue: T.nilable(WorkQueue),\n            to: IOLike\n          ).void\n        end\n        def initialize(auto_debrief: true, interrupt_debrief: false, max_concurrent: 0,\n                       work_queue: nil, to: $stdout)\n          @m = Mutex.new\n          @tasks = []\n          @puts_above = []\n          @auto_debrief = auto_debrief\n          @interrupt_debrief = interrupt_debrief\n          @start = Time.new\n          @stopped = false\n          @internal_work_queue = work_queue.nil?\n          @work_queue = T.let(\n            work_queue || WorkQueue.new(max_concurrent.zero? ? 1024 : max_concurrent),\n            WorkQueue\n          )\n          return unless block_given?\n\n          yield self\n          wait(to: to)\n        end\n\n        class Task\n          extend T::Sig\n\n          sig { returns(String) }\n          attr_reader :title, :stdout, :stderr\n\n          sig { returns(T::Boolean) }\n          attr_reader :success\n\n          sig { returns(T::Boolean) }\n          attr_reader :done\n\n          sig { returns(T.nilable(Exception)) }\n          attr_reader :exception\n\n          # Initializes a new Task\n          # This is managed entirely internally by +SpinGroup+\n          #\n          # ==== Attributes\n          #\n          # * +title+ - Title of the task\n          # * +block+ - Block for the task, will be provided with an instance of the spinner\n          #\n          sig do\n            params(\n              title: String,\n              final_glyph: T.proc.params(success: T::Boolean).returns(T.any(Glyph, String)),\n              merged_output: T::Boolean,\n              duplicate_output_to: IO,\n              work_queue: WorkQueue,\n              block: T.proc.params(task: Task).returns(T.untyped)\n            ).void\n          end\n          def initialize(title, final_glyph:, merged_output:, duplicate_output_to:, work_queue:)\n            @title = title\n            @final_glyph = final_glyph\n            @always_full_render = title =~ Formatter::SCAN_WIDGET\n            @future = work_queue.enqueue do\n              cap = CLI::UI::StdoutRouter::Capture.new(\n                merged_output: merged_output, duplicate_output_to: duplicate_output_to\n              ) { yield(self) }\n              begin\n                cap.run\n              ensure\n                @stdout = cap.stdout\n                @stderr = cap.stderr\n              end\n            end\n\n            @m = Mutex.new\n            @force_full_render = false\n            @done = false\n            @exception = nil\n            @success = false\n          end\n\n          sig { params(block: T.proc.params(task: Task).void).void }\n          def on_done(&block)\n            @on_done = block\n          end\n\n          # Checks if a task is finished\n          #\n          sig { returns(T::Boolean) }\n          def check\n            return true if @done\n            return false unless @future.completed?\n\n            @done = true\n            begin\n              result = @future.value\n              @success = true\n              @success = false if result == TASK_FAILED\n            rescue StandardError => e\n              @exception = e\n              @success = false\n            end\n\n            @on_done&.call(self)\n\n            @done\n          end\n\n          # Re-renders the task if required:\n          #\n          # We try to be as lazy as possible in re-rendering the full line. The\n          # spinner rune will change on each render for the most part, but the\n          # body text will rarely have changed. If the body text *has* changed,\n          # we set @force_full_render.\n          #\n          # Further, if the title string includes any CLI::UI::Widgets, we\n          # assume that it may change from render to render, since those\n          # evaluate more dynamically than the rest of our format codes, which\n          # are just text formatters. This is controlled by @always_full_render.\n          #\n          # ==== Attributes\n          #\n          # * +index+ - index of the task\n          # * +force+ - force rerender of the task\n          # * +width+ - current terminal width to format for\n          #\n          sig { params(index: Integer, force: T::Boolean, width: Integer).returns(String) }\n          def render(index, force = true, width: CLI::UI::Terminal.width)\n            @m.synchronize do\n              if !CLI::UI.enable_cursor? || force || @always_full_render || @force_full_render\n                full_render(index, width)\n              else\n                partial_render(index)\n              end\n            ensure\n              @force_full_render = false\n            end\n          end\n\n          # Update the spinner title\n          #\n          # ==== Attributes\n          #\n          # * +title+ - title to change the spinner to\n          #\n          sig { params(new_title: String).void }\n          def update_title(new_title)\n            @m.synchronize do\n              @always_full_render = new_title =~ Formatter::SCAN_WIDGET\n              @title = new_title\n              @force_full_render = true\n            end\n          end\n\n          private\n\n          sig { params(index: Integer, terminal_width: Integer).returns(String) }\n          def full_render(index, terminal_width)\n            o = +''\n\n            o << inset\n            o << glyph(index)\n            o << ' '\n\n            truncation_width = terminal_width - CLI::UI::ANSI.printing_width(o)\n\n            o << CLI::UI.resolve_text(title, truncate_to: truncation_width)\n            o << ANSI.clear_to_end_of_line if CLI::UI.enable_cursor?\n\n            o\n          end\n\n          sig { params(index: Integer).returns(String) }\n          def partial_render(index)\n            o = +''\n\n            o << CLI::UI::ANSI.cursor_forward(inset_width)\n            o << glyph(index)\n\n            o\n          end\n\n          sig { params(index: Integer).returns(String) }\n          def glyph(index)\n            if @done\n              final_glyph = @final_glyph.call(@success)\n              if final_glyph.is_a?(Glyph)\n                CLI::UI.enable_color? ? final_glyph.to_s : final_glyph.char\n              else\n                final_glyph\n              end\n            elsif CLI::UI.enable_cursor?\n              if @future.started?\n                CLI::UI.enable_color? ? GLYPHS[index] : RUNES[index]\n              else\n                CLI::UI.enable_color? ? Glyph::HOURGLASS.to_s : Glyph::HOURGLASS.char\n              end\n            else\n              Glyph::HOURGLASS.char\n            end\n          end\n\n          sig { returns(String) }\n          def inset\n            @inset ||= CLI::UI::Frame.prefix\n          end\n\n          sig { returns(Integer) }\n          def inset_width\n            @inset_width ||= CLI::UI::ANSI.printing_width(inset)\n          end\n        end\n\n        # Add a new task\n        #\n        # ==== Attributes\n        #\n        # * +title+ - Title of the task\n        # * +block+ - Block for the task, will be provided with an instance of the spinner\n        #\n        # ==== Example Usage:\n        #   spin_group = CLI::UI::SpinGroup.new\n        #   spin_group.add('Title') { |spinner| sleep 1.0 }\n        #   spin_group.wait\n        #\n        sig do\n          params(\n            title: String,\n            final_glyph: T.proc.params(success: T::Boolean).returns(T.any(Glyph, String)),\n            merged_output: T::Boolean,\n            duplicate_output_to: IO,\n            block: T.proc.params(task: Task).void\n          ).void\n        end\n        def add(\n          title,\n          final_glyph: DEFAULT_FINAL_GLYPH,\n          merged_output: false,\n          duplicate_output_to: File.new(File::NULL, 'w'),\n          &block\n        )\n          @m.synchronize do\n            @tasks << Task.new(\n              title,\n              final_glyph: final_glyph,\n              merged_output: merged_output,\n              duplicate_output_to: duplicate_output_to,\n              work_queue: @work_queue,\n              &block\n            )\n          end\n        end\n\n        sig { void }\n        def stop\n          # If we already own the mutex (called from within another synchronized block),\n          # set stopped directly to avoid deadlock\n          if @m.owned?\n            return if @stopped\n\n            @stopped = true\n          else\n            @m.synchronize do\n              return if @stopped\n\n              @stopped = true\n            end\n          end\n          # Interrupt is thread-safe on its own, so we can call it outside the mutex\n          @work_queue.interrupt\n        end\n\n        sig { returns(T::Boolean) }\n        def stopped?\n          if @m.owned?\n            @stopped\n          else\n            @m.synchronize { @stopped }\n          end\n        end\n\n        # Tells the group you're done adding tasks and to wait for all of them to finish\n        #\n        # ==== Options\n        #\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout\n        #\n        # ==== Example Usage:\n        #   spin_group = CLI::UI::SpinGroup.new\n        #   spin_group.add('Title') { |spinner| sleep 1.0 }\n        #   spin_group.wait\n        #\n        sig { params(to: IOLike).returns(T::Boolean) }\n        def wait(to: $stdout)\n          idx = 0\n\n          consumed_lines = 0\n\n          @work_queue.close if @internal_work_queue\n\n          tasks_seen = @tasks.map { false }\n          tasks_seen_done = @tasks.map { false }\n\n          loop do\n            break if stopped?\n\n            done_count = 0\n\n            width = CLI::UI::Terminal.width\n\n            self.class.pause_mutex.synchronize do\n              next if self.class.paused?\n\n              @m.synchronize do\n                CLI::UI.raw do\n                  force_full_render = false\n\n                  unless @puts_above.empty?\n                    to.print(CLI::UI::ANSI.cursor_up(consumed_lines)) if CLI::UI.enable_cursor?\n                    while (message = @puts_above.shift)\n                      if CLI::UI.enable_cursor?\n                        to.print(CLI::UI::ANSI.insert_lines(message.lines.count))\n                      end\n                      message.lines.each do |line|\n                        to.print(CLI::UI::Frame.prefix + CLI::UI.fmt(line))\n                      end\n                      to.print(\"\\n\")\n                    end\n                    # we descend with newlines rather than ANSI.cursor_down as the inserted lines may've\n                    # pushed the spinner off the front of the buffer, so we can't move back down below it\n                    to.print(\"\\n\" * consumed_lines) if CLI::UI.enable_cursor?\n\n                    force_full_render = true\n                  end\n\n                  @tasks.each.with_index do |task, int_index|\n                    nat_index = int_index + 1\n                    task_done = task.check\n                    done_count += 1 if task_done\n\n                    if CLI::UI.enable_cursor?\n                      if nat_index > consumed_lines\n                        to.print(\"#{task.render(idx, true, width: width)}\\n\")\n                        consumed_lines += 1\n                      else\n                        offset = consumed_lines - int_index\n                        move_to = \"#{CLI::UI::ANSI.cursor_up(offset)}\\r\"\n                        move_from = \"\\r#{CLI::UI::ANSI.cursor_down(offset)}\"\n\n                        to.print(move_to + task.render(idx, idx.zero? || force_full_render,\n                                                       width: width) + move_from)\n                      end\n                    elsif !tasks_seen[int_index] || (task_done && !tasks_seen_done[int_index])\n                      to.print(\"#{task.render(idx, true, width: width)}\\n\")\n                    end\n\n                    tasks_seen[int_index] = true\n                    tasks_seen_done[int_index] ||= task_done\n                  end\n                end\n              end\n            end\n\n            break if done_count == @tasks.size\n\n            idx = (idx + 1) % GLYPHS.size\n            Spinner.index = idx\n            sleep(PERIOD)\n          end\n\n          if @auto_debrief\n            debrief(to: to)\n          else\n            all_succeeded?\n          end\n        rescue Interrupt\n          @work_queue.interrupt\n          debrief(to: to) if @interrupt_debrief\n          stopped? ? false : raise\n        end\n\n        sig { params(message: String).void }\n        def puts_above(message)\n          @m.synchronize do\n            @puts_above << message\n          end\n        end\n\n        # Provide an alternative debriefing for failed tasks\n        sig do\n          params(\n            block: T.proc.params(title: String, exception: T.nilable(Exception), out: String,\n                                 err: String).void\n          ).void\n        end\n        def failure_debrief(&block)\n          @failure_debrief = block\n        end\n\n        # Provide a debriefing for successful tasks\n        sig do\n          params(\n            block: T.proc.params(title: String, out: String, err: String).void\n          ).void\n        end\n        def success_debrief(&block)\n          @success_debrief = block\n        end\n\n        sig { returns(T::Boolean) }\n        def all_succeeded?\n          @m.synchronize do\n            @tasks.all?(&:success)\n          end\n        end\n\n        # Debriefs failed tasks is +auto_debrief+ is true\n        #\n        # ==== Options\n        #\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout\n        #\n        sig { params(to: IOLike).returns(T::Boolean) }\n        def debrief(to: $stdout)\n          @m.synchronize do\n            @tasks.each do |task|\n              next unless task.done\n\n              title = task.title\n              out = task.stdout\n              err = task.stderr\n\n              next @success_debrief&.call(title, out, err) if task.success\n\n              # exception will not be set if the wait loop is stopped before the task is checked\n              e = task.exception\n              next @failure_debrief.call(title, e, out, err) if @failure_debrief\n\n              CLI::UI::Frame.open(\"Task Failed: #{title}\", color: :red,\n                                                           timing: Time.new - @start) do\n                if e\n                  to.puts(\"#{e.class}: #{e.message}\")\n                  to.puts(\"\\tfrom #{e.backtrace.join(\"\\n\\tfrom \")}\")\n                end\n\n                CLI::UI::Frame.divider('STDOUT')\n                out = '(empty)' if out.nil? || out.strip.empty?\n                to.puts(out)\n\n                CLI::UI::Frame.divider('STDERR')\n                err = '(empty)' if err.nil? || err.strip.empty?\n                to.puts(err)\n              end\n            end\n            @tasks.all?(&:success)\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/spinner/"
    },
    {
      "filename": "spinner.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    module Spinner\n      extend T::Sig\n\n      autoload :Async,      'cli/ui/spinner/async'\n      autoload :SpinGroup,  'cli/ui/spinner/spin_group'\n\n      PERIOD = 0.1 # seconds\n      TASK_FAILED = :task_failed\n\n      RUNES = if CLI::UI::OS.current.use_emoji?\n                ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'].freeze\n              else\n                ['\\\\', '|', '/', '-', '\\\\', '|', '/', '-'].freeze\n              end\n\n      colors = ([CLI::UI::Color::CYAN.code] * (RUNES.size / 2).ceil) +\n               ([CLI::UI::Color::MAGENTA.code] * (RUNES.size / 2).to_i)\n      GLYPHS = colors.zip(RUNES).map { |c, r| c + r + CLI::UI::Color::RESET.code }.freeze\n\n      class << self\n        extend T::Sig\n\n        sig { returns(T.nilable(Integer)) }\n        attr_accessor(:index)\n\n        # We use this from CLI::UI::Widgets::Status to render an additional\n        # spinner next to the \"working\" element. While this global state looks\n        # a bit repulsive at first, it's worth realizing that:\n        #\n        # * It's managed by the SpinGroup#wait method, not individual tasks; and\n        # * It would be complete insanity to run two separate but concurrent SpinGroups.\n        #\n        # While it would be possible to stitch through some connection between\n        # the SpinGroup and the Widgets included in its title, this is simpler\n        # in practice and seems unlikely to cause issues in practice.\n        sig { returns(String) }\n        def current_rune\n          RUNES[index || 0]\n        end\n      end\n\n      class << self\n        extend T::Sig\n\n        # Adds a single spinner\n        # Uses an interactive session to allow the user to pick an answer\n        # Can use arrows, y/n, numbers (1/2), and vim bindings to control\n        #\n        # https://user-images.githubusercontent.com/3074765/33798295-d94fd822-dce3-11e7-819b-43e5502d490e.gif\n        #\n        # ==== Attributes\n        #\n        # * +title+ - Title of the spinner to use\n        #\n        # ==== Options\n        #\n        # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout.\n        #\n        # ==== Block\n        #\n        # * *spinner+ - Instance of the spinner. Can call +update_title+ to update the user of changes\n        #\n        # ==== Example Usage:\n        #\n        #   CLI::UI::Spinner.spin('Title') { sleep 1.0 }\n        #\n        sig do\n          params(\n            title: String,\n            auto_debrief: T::Boolean,\n            to: IOLike,\n            block: T.proc.params(task: SpinGroup::Task).void\n          ).returns(T::Boolean)\n        end\n        def spin(title, auto_debrief: true, to: $stdout, &block)\n          sg = SpinGroup.new(auto_debrief: auto_debrief)\n          sg.add(title, &block)\n          sg.wait(to: to)\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "stdout_router.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\nrequire 'stringio'\nrequire_relative 'reentrant_mutex'\n\nmodule CLI\n  module UI\n    module StdoutRouter\n      class Writer\n        extend T::Sig\n\n        sig { params(stream: IOLike, name: Symbol).void }\n        def initialize(stream, name)\n          @stream = stream\n          @name = name\n        end\n\n        sig { params(args: Object).returns(Integer) }\n        def write(*args)\n          strs = args.map do |obj|\n            str = obj.to_s\n            if auto_frame_inset?\n              str = str.dup # unfreeze\n              str = str.to_s.force_encoding(Encoding::UTF_8)\n              apply_line_prefix(str, CLI::UI::Frame.prefix)\n            else\n              @pending_newline = false\n              str\n            end\n          end\n\n          # hook return of false suppresses output.\n          if (hook = Thread.current[:cliui_output_hook]) && (hook.call(strs.join, @name) == false)\n            return 0\n          end\n\n          ret = T.unsafe(@stream).write_without_cli_ui(*prepend_id(@stream, strs))\n          if (dup = StdoutRouter.duplicate_output_to)\n            begin\n              T.unsafe(dup).write(*prepend_id(dup, strs))\n            rescue IOError\n              # Ignore\n            end\n          end\n          ret\n        end\n\n        private\n\n        sig { params(stream: IOLike, args: T::Array[String]).returns(T::Array[String]) }\n        def prepend_id(stream, args)\n          return args unless prepend_id_for_stream(stream)\n\n          args.map do |a|\n            next a if a.chomp.empty? # allow new lines to be new lines\n\n            \"[#{Thread.current[:cliui_output_id][:id]}] #{a}\"\n          end\n        end\n\n        sig { params(stream: IOLike).returns(T::Boolean) }\n        def prepend_id_for_stream(stream)\n          return false unless Thread.current[:cliui_output_id]\n          return true if Thread.current[:cliui_output_id][:streams].include?(stream)\n\n          false\n        end\n\n        sig { returns(T::Boolean) }\n        def auto_frame_inset?\n          !Thread.current[:no_cliui_frame_inset]\n        end\n\n        sig { params(str: String, prefix: String).returns(String) }\n        def apply_line_prefix(str, prefix)\n          return '' if str.empty?\n\n          prefixed = +''\n          str.force_encoding(Encoding::UTF_8).lines.each do |line|\n            if @pending_newline\n              prefixed << line\n              @pending_newline = false\n            else\n              prefixed << prefix << line\n            end\n          end\n          @pending_newline = !str.end_with?(\"\\n\")\n          prefixed\n        end\n      end\n\n      class Capture\n        extend T::Sig\n\n        @capture_mutex = Mutex.new\n        @stdin_mutex = CLI::UI::ReentrantMutex.new\n        @active_captures = 0\n        @saved_stdin = nil\n\n        class << self\n          extend T::Sig\n\n          sig { returns(T.nilable(Capture)) }\n          def current_capture\n            Thread.current[:cliui_current_capture]\n          end\n\n          sig { returns(Capture) }\n          def current_capture!\n            T.must(current_capture)\n          end\n\n          sig do\n            type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n          end\n          def in_alternate_screen\n            stdin_synchronize do\n              previous_print_captured_output = current_capture&.print_captured_output\n              current_capture&.print_captured_output = true\n              Spinner::SpinGroup.pause_spinners do\n                if outermost_uncaptured?\n                  begin\n                    prev_hook = Thread.current[:cliui_output_hook]\n                    Thread.current[:cliui_output_hook] = nil\n                    replay = current_capture!.stdout.gsub(ANSI.match_alternate_screen, '')\n                    CLI::UI.raw do\n                      print(\"#{ANSI.enter_alternate_screen}#{replay}\")\n                    end\n                  ensure\n                    Thread.current[:cliui_output_hook] = prev_hook\n                  end\n                end\n                yield\n              ensure\n                print(ANSI.exit_alternate_screen) if outermost_uncaptured?\n              end\n            ensure\n              current_capture&.print_captured_output = !!previous_print_captured_output\n            end\n          end\n\n          sig do\n            type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n          end\n          def stdin_synchronize(&block)\n            @stdin_mutex.synchronize do\n              case $stdin\n              when BlockingInput\n                $stdin.synchronize(&block)\n              else\n                yield\n              end\n            end\n          end\n\n          sig do\n            type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n          end\n          def with_stdin_masked\n            @capture_mutex.synchronize do\n              if @active_captures.zero?\n                @stdin_mutex.synchronize do\n                  @saved_stdin = $stdin\n                  $stdin = BlockingInput.new(@saved_stdin)\n                end\n              end\n              @active_captures += 1\n            end\n\n            yield\n          ensure\n            @capture_mutex.synchronize do\n              @active_captures -= 1\n              if @active_captures.zero?\n                @stdin_mutex.synchronize do\n                  $stdin = @saved_stdin\n                end\n              end\n            end\n          end\n\n          private\n\n          sig { returns(T::Boolean) }\n          def outermost_uncaptured?\n            @stdin_mutex.one? && $stdin.is_a?(BlockingInput)\n          end\n        end\n\n        sig do\n          params(\n            with_frame_inset: T::Boolean,\n            merged_output: T::Boolean,\n            duplicate_output_to: IO,\n            block: T.proc.void\n          ).void\n        end\n        def initialize(\n          with_frame_inset: true,\n          merged_output: false,\n          duplicate_output_to: File.open(File::NULL, 'w'),\n          &block\n        )\n          @with_frame_inset = with_frame_inset\n          @merged_output = merged_output\n          @duplicate_output_to = duplicate_output_to\n          @block = block\n          @print_captured_output = false\n          @out = StringIO.new\n          @err = StringIO.new\n        end\n\n        sig { returns(T::Boolean) }\n        attr_accessor :print_captured_output\n\n        sig { returns(T.untyped) }\n        def run\n          require 'stringio'\n\n          StdoutRouter.assert_enabled!\n\n          Thread.current[:cliui_current_capture] = self\n\n          prev_frame_inset = Thread.current[:no_cliui_frame_inset]\n          prev_hook = Thread.current[:cliui_output_hook]\n\n          if Thread.current.respond_to?(:report_on_exception)\n            Thread.current.report_on_exception = false\n          end\n\n          self.class.with_stdin_masked do\n            Thread.current[:no_cliui_frame_inset] = !@with_frame_inset\n            Thread.current[:cliui_output_hook] = lambda { |data, stream|\n              stream = :stdout if @merged_output\n              case stream\n              when :stdout\n                @out.write(data)\n                @duplicate_output_to.write(data)\n              when :stderr\n                @err.write(data)\n              else raise\n              end\n              print_captured_output # suppress writing to terminal by default\n            }\n\n            @block.call\n          end\n        ensure\n          Thread.current[:cliui_output_hook] = prev_hook\n          Thread.current[:no_cliui_frame_inset] = prev_frame_inset\n          Thread.current[:cliui_current_capture] = nil\n        end\n\n        sig { returns(String) }\n        def stdout\n          @out.string\n        end\n\n        sig { returns(String) }\n        def stderr\n          @err.string\n        end\n\n        class BlockingInput\n          extend T::Sig\n\n          sig { params(stream: IO).void }\n          def initialize(stream)\n            @stream = stream\n            @m = CLI::UI::ReentrantMutex.new\n          end\n\n          sig do\n            type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n          end\n          def synchronize\n            @m.synchronize do\n              previous_allowed_to_read = Thread.current[:cliui_allowed_to_read]\n              Thread.current[:cliui_allowed_to_read] = true\n              yield\n            ensure\n              Thread.current[:cliui_allowed_to_read] = previous_allowed_to_read\n            end\n          end\n\n          READING_METHODS = %i[\n            each\n            each_byte\n            each_char\n            each_codepoint\n            each_line\n            getbyte\n            getc\n            getch\n            gets\n            read\n            read_nonblock\n            readbyte\n            readchar\n            readline\n            readlines\n            readpartial\n          ].freeze\n\n          NON_READING_METHODS = IO.instance_methods(false) - READING_METHODS\n\n          READING_METHODS.each do |method|\n            define_method(method) do |*args, **kwargs, &block|\n              raise(IOError, 'closed stream') unless Thread.current[:cliui_allowed_to_read]\n\n              @stream.send(method, *args, **kwargs, &block)\n            end\n          end\n\n          NON_READING_METHODS.each do |method|\n            define_method(method) do |*args, **kwargs, &block|\n              @stream.send(method, *args, **kwargs, &block)\n            end\n          end\n        end\n      end\n\n      class << self\n        extend T::Sig\n\n        WRITE_WITHOUT_CLI_UI = :write_without_cli_ui\n\n        NotEnabled = Class.new(StandardError)\n\n        sig { returns(T.nilable(IOLike)) }\n        attr_accessor :duplicate_output_to\n\n        sig do\n          type_parameters(:T)\n            .params(on_streams: T::Array[IOLike], block: T.proc.params(id: String).returns(T.type_parameter(:T)))\n            .returns(T.type_parameter(:T))\n        end\n        def with_id(on_streams:)\n          require 'securerandom'\n          id = format('%05d', rand(10**5))\n          Thread.current[:cliui_output_id] = {\n            id: id,\n            streams: on_streams.map { |stream| T.cast(stream, IOLike) }\n          }\n          yield(id)\n        ensure\n          Thread.current[:cliui_output_id] = nil\n        end\n\n        sig { returns(T.nilable(T::Hash[Symbol, T.any(String, IOLike)])) }\n        def current_id\n          Thread.current[:cliui_output_id]\n        end\n\n        sig { void }\n        def assert_enabled!\n          raise NotEnabled unless enabled?\n        end\n\n        sig do\n          type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n        end\n        def with_enabled\n          enable\n          yield\n        ensure\n          disable\n        end\n\n        # TODO: remove this\n        sig { void }\n        def ensure_activated\n          enable unless enabled?\n        end\n\n        sig { returns(T::Boolean) }\n        def enable\n          return false if enabled?($stdout) || enabled?($stderr)\n\n          activate($stdout, :stdout)\n          activate($stderr, :stderr)\n          true\n        end\n\n        sig { params(stream: IOLike).returns(T::Boolean) }\n        def enabled?(stream = $stdout)\n          stream.respond_to?(WRITE_WITHOUT_CLI_UI)\n        end\n\n        sig { returns(T::Boolean) }\n        def disable\n          return false unless enabled?($stdout) && enabled?($stderr)\n\n          deactivate($stdout)\n          deactivate($stderr)\n          true\n        end\n\n        private\n\n        sig { params(stream: IOLike).void }\n        def deactivate(stream)\n          sc = stream.singleton_class\n          sc.send(:remove_method, :write)\n          sc.send(:alias_method, :write, WRITE_WITHOUT_CLI_UI)\n        end\n\n        sig { params(stream: IOLike, streamname: Symbol).void }\n        def activate(stream, streamname)\n          writer = StdoutRouter::Writer.new(stream, streamname)\n\n          raise if stream.respond_to?(WRITE_WITHOUT_CLI_UI)\n\n          stream.singleton_class.send(:alias_method, WRITE_WITHOUT_CLI_UI, :write)\n          stream.define_singleton_method(:write) do |*args|\n            writer.write(*args)\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "table.rb",
      "content": "# frozen_string_literal: true\n# typed: true\n\nmodule CLI\n  module UI\n    module Table\n      extend T::Sig\n\n      class << self\n        extend T::Sig\n\n        # Prints a formatted table to the specified output\n        # Automatically pads columns to align based on the longest cell in each column,\n        # ignoring the width of ANSI color codes.\n        #\n        # ==== Attributes\n        #\n        # * +table+ - (required) 2D array of strings representing the table data\n        #\n        # ==== Options\n        #\n        # * +:col_spacing+ - Number of spaces between columns. Defaults to 1\n        # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,\n        #   or under Sorbet, IO or StringIO. Defaults to $stdout\n        #\n        # ==== Example\n        #\n        #   CLI::UI::Table.puts_table([\n        #     [\"{{bold:header_1}}\", \"{{bold:header_2}}\"],\n        #     [\"really_long_cell\",  \"short\"],\n        #     [\"row2\",              \"row2\"]\n        #   ])\n        #\n        # Default Output:\n        #   header_1         header_2\n        #   really_long_cell short\n        #   row2             row2\n        #\n        sig { params(table: T::Array[T::Array[String]], col_spacing: Integer, to: IOLike).void }\n        def puts_table(table, col_spacing: 1, to: $stdout)\n          col_sizes = table.transpose.map do |col|\n            col.map { |cell| CLI::UI::ANSI.printing_width(CLI::UI.resolve_text(cell)) }.max\n          end\n\n          table.each do |row|\n            padded_row = row.each_with_index.map do |cell, i|\n              col_size = T.must(col_sizes[i]) # guaranteed to be non-nil\n              cell_size = CLI::UI::ANSI.printing_width(CLI::UI.resolve_text(cell))\n              padded_cell = cell + (' ' * (col_size - cell_size))\n              padded_cell\n            end\n            CLI::UI.puts(padded_row.join(' ' * col_spacing), to: to)\n          end\n        end\n\n        # Captures a table's output as an array of strings without printing to the terminal\n        # Can be used to further manipulate or format the table output\n        #\n        # ==== Attributes\n        #\n        # * +table+ - (required) 2D array of strings representing the table data\n        #\n        # ==== Options\n        #\n        # * +:col_spacing+ - Number of spaces between columns. Defaults to 1\n        #\n        # ==== Returns\n        #\n        # * +Array[String]+ - Array of strings, each representing a row of the formatted table\n        #\n        # ==== Example\n        #\n        #   CLI::UI::Table.capture_table([\n        #     [\"{{bold:header_1}}\", \"{{bold:header_2}}\"],\n        #     [\"really_long_cell\",  \"short\"],\n        #     [\"row2\",              \"row2\"]\n        #   ])\n        #\n        sig { params(table: T::Array[T::Array[String]], col_spacing: Integer).returns(T::Array[String]) }\n        def capture_table(table, col_spacing: 1)\n          strio = StringIO.new\n          puts_table(table, col_spacing: col_spacing, to: strio)\n          strio.string.lines.map(&:chomp)\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "terminal.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\nrequire 'io/console'\n\nmodule CLI\n  module UI\n    module Terminal\n      extend T::Sig\n\n      DEFAULT_WIDTH = 80\n      DEFAULT_HEIGHT = 24\n\n      class << self\n        extend T::Sig\n\n        # Returns the width of the terminal, if possible\n        # Otherwise will return DEFAULT_WIDTH\n        #\n        sig { returns(Integer) }\n        def width\n          winsize[1]\n        end\n\n        # Returns the width of the terminal, if possible\n        # Otherwise, will return DEFAULT_HEIGHT\n        #\n        sig { returns(Integer) }\n        def height\n          winsize[0]\n        end\n\n        sig { returns([Integer, Integer]) }\n        def winsize\n          @winsize ||= begin\n            winsize = IO.console.winsize\n            setup_winsize_trap\n\n            if winsize.any?(&:zero?)\n              [DEFAULT_HEIGHT, DEFAULT_WIDTH]\n            else\n              winsize\n            end\n          rescue StandardError\n            [DEFAULT_HEIGHT, DEFAULT_WIDTH]\n          end\n        end\n\n        sig { void }\n        def setup_winsize_trap\n          @setup_winsize_trap ||= Signal.trap('WINCH') do\n            @winsize = nil\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "truncater.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\n\nmodule CLI\n  module UI\n    # Truncater truncates a string to a provided printable width.\n    module Truncater\n      PARSE_ROOT = :root\n      PARSE_ANSI = :ansi\n      PARSE_ESC  = :esc\n      PARSE_ZWJ  = :zwj\n\n      ESC                 = 0x1b\n      LEFT_SQUARE_BRACKET = 0x5b\n      ZWJ                 = 0x200d # emojipedia.org/emoji-zwj-sequences\n      SEMICOLON           = 0x3b\n\n      # EMOJI_RANGE in particular is super inaccurate. This is best-effort.\n      # If you need this to be more accurate, we'll almost certainly accept a\n      # PR improving it.\n      EMOJI_RANGE    = 0x1f300..0x1f5ff\n      NUMERIC_RANGE  = 0x30..0x39\n      LC_ALPHA_RANGE = 0x40..0x5a\n      UC_ALPHA_RANGE = 0x60..0x71\n\n      TRUNCATED = \"\\x1b[0m…\"\n\n      class << self\n        extend T::Sig\n\n        sig { params(text: String, printing_width: Integer).returns(String) }\n        def call(text, printing_width)\n          return text if text.size <= printing_width\n\n          width            = 0\n          mode             = PARSE_ROOT\n          truncation_index = T.let(nil, T.nilable(Integer))\n\n          codepoints = text.codepoints\n          codepoints.each.with_index do |cp, index|\n            case mode\n            when PARSE_ROOT\n              case cp\n              when ESC # non-printable, followed by some more non-printables.\n                mode = PARSE_ESC\n              when ZWJ # non-printable, followed by another non-printable.\n                mode = PARSE_ZWJ\n              else\n                width += width(cp)\n                if width >= printing_width\n                  truncation_index ||= index\n                  # it looks like we could break here but we still want the\n                  # width calculation for the rest of the characters.\n                end\n              end\n            when PARSE_ESC\n              mode = case cp\n                     when LEFT_SQUARE_BRACKET\n                       PARSE_ANSI\n                     else\n                       PARSE_ROOT\n                     end\n            when PARSE_ANSI\n              # ANSI escape codes preeeetty much have the format of:\n              # \\x1b[0-9;]+[A-Za-z]\n              case cp\n              when NUMERIC_RANGE, SEMICOLON\n              when LC_ALPHA_RANGE, UC_ALPHA_RANGE\n                mode = PARSE_ROOT\n              else\n                # unexpected. let's just go back to the root state I guess?\n                mode = PARSE_ROOT\n              end\n            when PARSE_ZWJ\n              # consume any character and consider it as having no width\n              # width(x+ZWJ+y) = width(x).\n              mode = PARSE_ROOT\n            end\n          end\n\n          # Without the `width <= printing_width` check, we truncate\n          # \"foo\\x1b[0m\" for a width of 3, but it should not be truncated.\n          # It's specifically for the case where we decided \"Yes, this is the\n          # point at which we'd have to add a truncation!\" but it's actually\n          # the end of the string.\n          return text if !truncation_index || width <= printing_width\n\n          T.must(codepoints[0...truncation_index]).pack('U*') + TRUNCATED\n        end\n\n        private\n\n        sig { params(printable_codepoint: Integer).returns(Integer) }\n        def width(printable_codepoint)\n          case printable_codepoint\n          when EMOJI_RANGE\n            2\n          else\n            1\n          end\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "version.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    VERSION = '2.3.1'\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "base.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire('cli/ui')\n\nmodule CLI\n  module UI\n    module Widgets\n      class Base\n        extend T::Sig\n        extend T::Helpers\n        abstract!\n\n        class << self\n          extend T::Sig\n\n          sig { params(argstring: String).returns(String) }\n          def call(argstring)\n            new(argstring).render\n          end\n        end\n\n        sig { params(argstring: String).void }\n        def initialize(argstring)\n          pat = self.class.argparse_pattern\n          unless (@match_data = pat.match(argstring))\n            raise(Widgets::InvalidWidgetArguments.new(argstring, pat))\n          end\n\n          @match_data.names.each do |name|\n            instance_variable_set(:\"@#{name}\", @match_data[name])\n          end\n        end\n\n        class << self\n          extend T::Sig\n\n          sig { abstract.returns(Regexp) }\n          def argparse_pattern; end\n        end\n\n        sig { abstract.returns(String) }\n        def render; end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/widgets/"
    },
    {
      "filename": "status.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire('cli/ui')\n\nmodule CLI\n  module UI\n    module Widgets\n      class Status < Widgets::Base\n        ARGPARSE_PATTERN = /\n          \\A (?<succeeded> \\d+)\n          :  (?<failed>    \\d+)\n          :  (?<working>   \\d+)\n          :  (?<pending>   \\d+) \\z\n        /x # e.g. \"1:23:3:404\"\n        OPEN  = \"#{Color::RESET.code}#{Color::BOLD.code}[#{Color::RESET.code}\".freeze\n        CLOSE = \"#{Color::RESET.code}#{Color::BOLD.code}]#{Color::RESET.code}\".freeze\n        ARROW = \"#{Color::RESET.code}#{Color::GRAY.code}◂#{Color::RESET.code}\".freeze\n        COMMA = \"#{Color::RESET.code}#{Color::GRAY.code},#{Color::RESET.code}\".freeze\n\n        SPINNER_STOPPED = '⠿'\n        EMPTY_SET = '∅'\n\n        class << self\n          extend T::Sig\n\n          sig { override.returns(Regexp) }\n          def argparse_pattern\n            ARGPARSE_PATTERN\n          end\n        end\n\n        sig { override.returns(String) }\n        def render\n          if zero?(@succeeded) && zero?(@failed) && zero?(@working) && zero?(@pending)\n            Color::RESET.code + Color::BOLD.code + EMPTY_SET + Color::RESET.code\n          else\n            #   [          0✓            ,         2✗          ◂         3⠼           ◂         4⌛︎           ]\n            \"#{OPEN}#{succeeded_part}#{COMMA}#{failed_part}#{ARROW}#{working_part}#{ARROW}#{pending_part}#{CLOSE}\"\n          end\n        end\n\n        private\n\n        sig { params(num_str: String).returns(T::Boolean) }\n        def zero?(num_str)\n          num_str == '0'\n        end\n\n        sig { params(num_str: String, rune: String, color: Color).returns(String) }\n        def colorize_if_nonzero(num_str, rune, color)\n          color = Color::GRAY if zero?(num_str)\n          color.code + num_str + rune\n        end\n\n        sig { returns(String) }\n        def succeeded_part\n          colorize_if_nonzero(@succeeded, Glyph::CHECK.char, Color::GREEN)\n        end\n\n        sig { returns(String) }\n        def failed_part\n          colorize_if_nonzero(@failed, Glyph::X.char, Color::RED)\n        end\n\n        sig { returns(String) }\n        def working_part\n          rune = zero?(@working) ? SPINNER_STOPPED : Spinner.current_rune\n          colorize_if_nonzero(@working, rune, Color::BLUE)\n        end\n\n        sig { returns(String) }\n        def pending_part\n          colorize_if_nonzero(@pending, Glyph::HOURGLASS.char, Color::WHITE)\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/widgets/"
    },
    {
      "filename": "widgets.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire('cli/ui')\n\nmodule CLI\n  module UI\n    # Widgets are formatter objects with more custom implementations than the\n    # other features, which all center around formatting text with colours,\n    # etc.\n    #\n    # If you want to extend CLI::UI with your own widgets, you may want to do\n    # something like this:\n    #\n    #   require('cli/ui')\n    #   class MyWidget < CLI::UI::Widgets::Base\n    #     # ...\n    #   end\n    #   CLI::UI::Widgets.register('my-widget') { MyWidget }\n    #   puts(CLI::UI.fmt(\"{{@widget/my-widget:args}}\"))\n    module Widgets\n      extend T::Sig\n\n      MAP = {}.freeze\n\n      autoload(:Base, 'cli/ui/widgets/base')\n      autoload(:Status, 'cli/ui/widgets/status')\n\n      class << self\n        extend T::Sig\n\n        sig { params(name: String, cb: T.proc.returns(T.class_of(Widgets::Base))).void }\n        def register(name, &cb)\n          MAP[name] = cb\n        end\n\n        # Looks up a widget by handle\n        #\n        # ==== Raises\n        # Raises InvalidWidgetHandle if the widget is not available.\n        #\n        # ==== Returns\n        # A callable widget, to be invoked like `.call(argstring)`\n        #\n        sig { params(handle: String).returns(T.class_of(Widgets::Base)) }\n        def lookup(handle)\n          MAP.fetch(handle).call\n        rescue KeyError, NameError\n          raise(InvalidWidgetHandle, handle)\n        end\n\n        # All available widgets by name\n        #\n        sig { returns(T::Array[String]) }\n        def available\n          MAP.keys\n        end\n      end\n\n      register('status') { Widgets::Status }\n\n      class InvalidWidgetHandle < ArgumentError\n        extend T::Sig\n\n        sig { params(handle: String).void }\n        def initialize(handle)\n          super\n          @handle = handle\n        end\n\n        sig { returns(String) }\n        def message\n          keys = Widgets.available.join(',')\n          \"invalid widget handle: #{@handle} \" \\\n            \"-- must be one of CLI::UI::Widgets.available (#{keys})\"\n        end\n      end\n\n      class InvalidWidgetArguments < ArgumentError\n        extend T::Sig\n\n        sig { params(argstring: String, pattern: Regexp).void }\n        def initialize(argstring, pattern)\n          super(nil)\n          @argstring = argstring\n          @pattern   = pattern\n        end\n\n        sig { returns(String) }\n        def message\n          \"invalid widget arguments: #{@argstring} \" \\\n            \"-- must match pattern: #{@pattern.inspect}\"\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "work_queue.rb",
      "content": "# typed: strict\n# frozen_string_literal: true\n\nmodule CLI\n  module UI\n    class WorkQueue\n      extend T::Sig\n\n      class Future\n        extend T::Sig\n\n        sig { void }\n        def initialize\n          @mutex = T.let(Mutex.new, Mutex)\n          @condition = T.let(ConditionVariable.new, ConditionVariable)\n          @completed = T.let(false, T::Boolean)\n          @started = T.let(false, T::Boolean)\n          @result = T.let(nil, T.untyped)\n          @error = T.let(nil, T.nilable(Exception))\n        end\n\n        sig { params(result: T.untyped).void }\n        def complete(result)\n          @mutex.synchronize do\n            @completed = true\n            @result = result\n            @condition.broadcast\n          end\n        end\n\n        sig { params(error: Exception).void }\n        def fail(error)\n          @mutex.synchronize do\n            return if @completed\n\n            @completed = true\n            @error = error\n            @condition.broadcast\n          end\n        end\n\n        sig { returns(T.untyped) }\n        def value\n          @mutex.synchronize do\n            @condition.wait(@mutex) until @completed\n            raise @error if @error\n\n            @result\n          end\n        end\n\n        sig { returns(T::Boolean) }\n        def completed?\n          @mutex.synchronize { @completed }\n        end\n\n        sig { returns(T::Boolean) }\n        def started?\n          @mutex.synchronize { @started }\n        end\n\n        sig { void }\n        def start\n          @mutex.synchronize do\n            @started = true\n            @condition.broadcast\n          end\n        end\n      end\n\n      sig { params(max_concurrent: Integer).void }\n      def initialize(max_concurrent)\n        @max_concurrent = max_concurrent\n        @queue = T.let(Queue.new, Queue)\n        @mutex = T.let(Mutex.new, Mutex)\n        @condition = T.let(ConditionVariable.new, ConditionVariable)\n        @workers = T.let([], T::Array[Thread])\n      end\n\n      sig { params(block: T.proc.returns(T.untyped)).returns(Future) }\n      def enqueue(&block)\n        future = Future.new\n        @mutex.synchronize do\n          start_worker if @workers.size < @max_concurrent\n        end\n        @queue.push([future, block])\n        future\n      end\n\n      sig { void }\n      def close\n        @queue.close\n      end\n\n      sig { void }\n      def wait\n        @queue.close\n        @workers.each(&:join)\n      end\n\n      sig { void }\n      def interrupt\n        @mutex.synchronize do\n          @queue.close\n          # Fail any remaining tasks in the queue\n          until @queue.empty?\n            future, _block = @queue.pop(true)\n            future&.fail(Interrupt.new)\n          end\n          # Interrupt all worker threads\n          @workers.each { |worker| worker.raise(Interrupt) if worker.alive? }\n          @workers.each(&:join)\n          @workers.clear\n        end\n      end\n\n      private\n\n      sig { void }\n      def start_worker\n        @workers << Thread.new do\n          loop do\n            work = @queue.pop\n            break if work.nil?\n\n            future, block = work\n\n            begin\n              future.start\n              result = block.call\n              future.complete(result)\n            rescue Interrupt => e\n              future.fail(e)\n              raise # Always re-raise interrupts to terminate the worker\n            rescue StandardError => e\n              future.fail(e)\n              # Don't re-raise standard errors - allow worker to continue\n            end\n          end\n        rescue Interrupt\n          # Clean exit on interrupt\n        end\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "wrap.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire 'cli/ui'\nrequire 'cli/ui/frame/frame_stack'\nrequire 'cli/ui/frame/frame_style'\n\nmodule CLI\n  module UI\n    class Wrap\n      extend T::Sig\n\n      sig { params(input: String).void }\n      def initialize(input)\n        @input = input\n      end\n\n      sig { params(total_width: Integer).returns(String) }\n      def wrap(total_width = Terminal.width)\n        max_width = total_width - Frame.prefix_width\n        width = T.let(0, Integer)\n        final = []\n        # Create an alternation of format codes of parameter lengths 1-20, since + and {1,n} not allowed in lookbehind\n        format_codes = (1..20).map { |n| /\\x1b\\[[\\d;]{#{n}}m/ }.join('|')\n        codes = ''\n        @input.split(/(?=\\s|\\x1b\\[[\\d;]+m|\\r)|(?<=\\s|#{format_codes})/).each do |token|\n          case token\n          when '\\x1B[0?m'\n            codes = ''\n            final << token\n          when /\\x1b\\[[\\d;]+m/\n            codes += token # Track in use format codes so that they are resent after frame coloring\n            final << token\n          when \"\\n\"\n            final << \"\\n#{codes}\"\n            width = 0\n          when /\\s/\n            token_width = ANSI.printing_width(token)\n            if width + token_width <= max_width\n              final << token\n              width += token_width\n            else\n              final << \"\\n#{codes}\"\n              width = 0\n            end\n          else\n            token_width = ANSI.printing_width(token)\n            if width + token_width <= max_width\n              final << token\n              width += token_width\n            else\n              final << \"\\n#{codes}\"\n              final << token\n              width = token_width\n            end\n          end\n        end\n        final.join\n      end\n    end\n  end\nend\n",
      "path": "/lib/cli/ui/"
    },
    {
      "filename": "ui.rb",
      "content": "# typed: true\n# frozen_string_literal: true\n\nrequire('cli/ui/sorbet_runtime_stub') unless defined?(T)\n\nmodule CLI\n  module UI\n    extend T::Sig\n\n    autoload :ANSI,      'cli/ui/ansi'\n    autoload :Glyph,     'cli/ui/glyph'\n    autoload :Color,     'cli/ui/color'\n    autoload :Frame,     'cli/ui/frame'\n    autoload :OS,        'cli/ui/os'\n    autoload :Printer,   'cli/ui/printer'\n    autoload :Progress,  'cli/ui/progress'\n    autoload :Prompt,    'cli/ui/prompt'\n    autoload :Table,     'cli/ui/table'\n    autoload :Terminal,  'cli/ui/terminal'\n    autoload :Truncater, 'cli/ui/truncater'\n    autoload :Formatter, 'cli/ui/formatter'\n    autoload :Spinner,   'cli/ui/spinner'\n    autoload :Widgets,   'cli/ui/widgets'\n    autoload :Wrap,      'cli/ui/wrap'\n\n    # Convenience accessor to +CLI::UI::Spinner::SpinGroup+\n    SpinGroup = Spinner::SpinGroup\n\n    Colorable = T.type_alias { T.any(Symbol, String, CLI::UI::Color) }\n    FrameStylable = T.type_alias { T.any(Symbol, String, CLI::UI::Frame::FrameStyle) }\n    IOLike = T.type_alias { T.any(IO, StringIO) }\n\n    class << self\n      extend T::Sig\n\n      # Glyph resolution using +CLI::UI::Glyph.lookup+\n      # Look at the method signature for +Glyph.lookup+ for more details\n      #\n      # ==== Attributes\n      #\n      # * +handle+ - handle of the glyph to resolve\n      #\n      sig { params(handle: String).returns(Glyph) }\n      def glyph(handle)\n        CLI::UI::Glyph.lookup(handle)\n      end\n\n      # Color resolution using +CLI::UI::Color.lookup+\n      # Will lookup using +Color.lookup+ unless it's already a CLI::UI::Color (or nil)\n      #\n      # ==== Attributes\n      #\n      # * +input+ - color to resolve\n      #\n      sig { params(input: Colorable).returns(CLI::UI::Color) }\n      def resolve_color(input)\n        case input\n        when CLI::UI::Color\n          input\n        else\n          CLI::UI::Color.lookup(input)\n        end\n      end\n\n      # Frame style resolution using +CLI::UI::Frame::FrameStyle.lookup+.\n      # Will lookup using +FrameStyle.lookup+ unless it's already a CLI::UI::Frame::FrameStyle(or nil)\n      #\n      # ==== Attributes\n      #\n      # * +input+ - frame style to resolve\n      sig { params(input: FrameStylable).returns(CLI::UI::Frame::FrameStyle) }\n      def resolve_style(input)\n        case input\n        when CLI::UI::Frame::FrameStyle\n          input\n        else\n          CLI::UI::Frame::FrameStyle.lookup(input.to_s)\n        end\n      end\n\n      # Convenience Method for +CLI::UI::Prompt.confirm+\n      #\n      # ==== Attributes\n      #\n      # * +question+ - question to confirm\n      #\n      sig { params(question: String, default: T::Boolean).returns(T::Boolean) }\n      def confirm(question, default: true)\n        CLI::UI::Prompt.confirm(question, default: default)\n      end\n\n      # Convenience Method for +CLI::UI::Prompt.any_key+\n      #\n      # ==== Attributes\n      #\n      # * +prompt+ - prompt to present\n      #\n      sig { params(prompt: String).returns(T.nilable(String)) }\n      def any_key(prompt = 'Press any key to continue')\n        CLI::UI::Prompt.any_key(prompt)\n      end\n\n      # Convenience Method for +CLI::UI::Prompt.ask+\n      sig do\n        params(\n          question: String,\n          options: T.nilable(T::Array[String]),\n          default: T.nilable(T.any(String, T::Array[String])),\n          is_file: T::Boolean,\n          allow_empty: T::Boolean,\n          multiple: T::Boolean,\n          filter_ui: T::Boolean,\n          select_ui: T::Boolean,\n          options_proc: T.nilable(T.proc.params(handler: Prompt::OptionsHandler).void)\n        ).returns(T.any(String, T::Array[String]))\n      end\n      def ask(\n        question,\n        options: nil,\n        default: nil,\n        is_file: false,\n        allow_empty: true,\n        multiple: false,\n        filter_ui: true,\n        select_ui: true,\n        &options_proc\n      )\n        CLI::UI::Prompt.ask(\n          question,\n          options: options,\n          default: default,\n          is_file: is_file,\n          allow_empty: allow_empty,\n          multiple: multiple,\n          filter_ui: filter_ui,\n          select_ui: select_ui,\n          &options_proc\n        )\n      end\n\n      # Convenience Method to resolve text using +CLI::UI::Formatter.format+\n      # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options\n      #\n      # ==== Attributes\n      #\n      # * +input+ - input to format\n      # * +truncate_to+ - number of characters to truncate the string to (or nil)\n      # * +enable_color+ - should color be used? default to true unless output is redirected.\n      #\n      sig { params(input: String, truncate_to: T.nilable(Integer), enable_color: T::Boolean).returns(String) }\n      def resolve_text(input, truncate_to: nil, enable_color: enable_color?)\n        formatted = CLI::UI::Formatter.new(input).format(enable_color: enable_color)\n        return formatted unless truncate_to\n\n        CLI::UI::Truncater.call(formatted, truncate_to)\n      end\n\n      # Convenience Method to format text using +CLI::UI::Formatter.format+\n      # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options\n      #\n      # https://user-images.githubusercontent.com/3074765/33799827-6d0721a2-dd01-11e7-9ab5-c3d455264afe.png\n      # https://user-images.githubusercontent.com/3074765/33799847-9ec03fd0-dd01-11e7-93f7-5f5cc540e61e.png\n      #\n      # ==== Attributes\n      #\n      # * +input+ - input to format\n      #\n      # ==== Options\n      #\n      # * +enable_color+ - should color be used? default to true unless output is redirected.\n      #\n      sig { params(input: String, enable_color: T::Boolean).returns(String) }\n      def fmt(input, enable_color: enable_color?)\n        CLI::UI::Formatter.new(input).format(enable_color: enable_color)\n      end\n\n      sig { params(input: String).returns(String) }\n      def wrap(input)\n        CLI::UI::Wrap.new(input).wrap\n      end\n\n      # Convenience Method for +CLI::UI::Printer.puts+\n      #\n      # ==== Attributes\n      #\n      # * +msg+ - Message to print\n      # * +kwargs+ - keyword arguments for +Printer.puts+\n      #\n      sig do\n        params(\n          msg: String,\n          frame_color: T.nilable(Colorable),\n          to: IOLike,\n          encoding: Encoding,\n          format: T::Boolean,\n          graceful: T::Boolean,\n          wrap: T::Boolean\n        ).void\n      end\n      def puts(\n        msg,\n        frame_color: nil,\n        to: $stdout,\n        encoding: Encoding::UTF_8,\n        format: true,\n        graceful: true,\n        wrap: true\n      )\n        CLI::UI::Printer.puts(\n          msg,\n          frame_color: frame_color,\n          to: to,\n          encoding: encoding,\n          format: format,\n          graceful: graceful,\n          wrap: wrap\n        )\n      end\n\n      # Convenience Method for +CLI::UI::Frame.open+\n      #\n      # ==== Attributes\n      #\n      # * +args+ - arguments for +Frame.open+\n      # * +block+ - block for +Frame.open+\n      #\n      sig do\n        type_parameters(:T).params(\n          text: String,\n          color: T.nilable(Colorable),\n          failure_text: T.nilable(String),\n          success_text: T.nilable(String),\n          timing: T.any(T::Boolean, Numeric),\n          frame_style: FrameStylable,\n          to: IOLike,\n          block: T.nilable(T.proc.returns(T.type_parameter(:T)))\n        ).returns(T.nilable(T.type_parameter(:T)))\n      end\n      def frame(\n        text,\n        color: Frame::DEFAULT_FRAME_COLOR,\n        failure_text: nil,\n        success_text: nil,\n        timing: block_given?,\n        frame_style: Frame.frame_style,\n        to: $stdout,\n        &block\n      )\n        CLI::UI::Frame.open(\n          text,\n          color: color,\n          failure_text: failure_text,\n          success_text: success_text,\n          timing: timing,\n          frame_style: frame_style,\n          to: to,\n          &block\n        )\n      end\n\n      # Convenience Method for +CLI::UI::Spinner.spin+\n      #\n      # ==== Attributes\n      #\n      # * +args+ - arguments for +Spinner.open+\n      # * +block+ - block for +Spinner.open+\n      #\n      sig do\n        params(\n          title: String,\n          auto_debrief: T::Boolean,\n          to: IOLike,\n          block: T.proc.params(task: Spinner::SpinGroup::Task).void\n        ).returns(T::Boolean)\n      end\n      def spinner(title, auto_debrief: true, to: $stdout, &block)\n        CLI::UI::Spinner.spin(title, auto_debrief: auto_debrief, to: to, &block)\n      end\n\n      # Convenience Method to override frame color using +CLI::UI::Frame.with_frame_color+\n      #\n      # ==== Attributes\n      #\n      # * +color+ - color to override to\n      # * +block+ - block for +Frame.with_frame_color_override+\n      #\n      sig do\n        type_parameters(:T)\n          .params(color: Colorable, block: T.proc.returns(T.type_parameter(:T)))\n          .returns(T.type_parameter(:T))\n      end\n      def with_frame_color(color, &)\n        CLI::UI::Frame.with_frame_color_override(color, &)\n      end\n\n      # Duplicate output to a file path\n      #\n      # ==== Attributes\n      #\n      # * +path+ - path to duplicate output to\n      #\n      sig do\n        type_parameters(:T)\n          .params(path: String, block: T.proc.returns(T.type_parameter(:T)))\n          .returns(T.type_parameter(:T))\n      end\n      def log_output_to(path)\n        raise 'multiple logs not allowed' if CLI::UI::StdoutRouter.duplicate_output_to\n\n        CLI::UI::StdoutRouter.duplicate_output_to = File.open(path, 'w')\n        yield\n      ensure\n        if (file_descriptor = CLI::UI::StdoutRouter.duplicate_output_to)\n          begin\n            file_descriptor.close\n          rescue IOError\n            nil\n          end\n          CLI::UI::StdoutRouter.duplicate_output_to = nil\n        end\n      end\n\n      # Disable all framing within a block\n      #\n      # ==== Attributes\n      #\n      # * +block+ - block in which to disable frames\n      #\n      sig do\n        type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T))\n      end\n      def raw\n        prev = Thread.current[:no_cliui_frame_inset]\n        Thread.current[:no_cliui_frame_inset] = true\n        yield\n      ensure\n        Thread.current[:no_cliui_frame_inset] = prev\n      end\n\n      # Check whether colour is enabled in Formatter, Frame, and Spinner output.\n      # By default, colour is enabled when STDOUT is a TTY; that is, when output\n      # has not been directed to another program or to a file.\n      #\n      sig { returns(T::Boolean) }\n      def enable_color?\n        @enable_color\n      end\n\n      # Turn colour in Formatter, Frame, and Spinner output on or off.\n      #\n      # ==== Attributes\n      #\n      # * +bool+ - true or false; enable or disable colour.\n      #\n      sig { params(bool: T::Boolean).void }\n      def enable_color=(bool)\n        @enable_color = !!bool\n      end\n\n      # Check whether cursor control is enabled in Formatter, Frame, and Spinner output.\n      # By default, cursor control is enabled when STDOUT is a TTY; that is, when output\n      # has not been directed to another program or to a file.\n      #\n      sig { returns(T::Boolean) }\n      def enable_cursor?\n        @enable_cursor\n      end\n\n      # Turn cursor control in Formatter, Frame, and Spinner output on or off.\n      #\n      # ==== Attributes\n      #\n      # * +bool+ - true or false; enable or disable cursor control.\n      #\n      sig { params(bool: T::Boolean).void }\n      def enable_cursor=(bool)\n        @enable_cursor = !!bool\n      end\n\n      # Set the default frame style.\n      # Convenience method for setting the default frame style with +CLI::UI::Frame.frame_style=+\n      #\n      # Raises ArgumentError if +frame_style+ is not valid\n      #\n      # ==== Attributes\n      #\n      # * +symbol+ - the default frame style to use for frames\n      #\n      sig { params(frame_style: FrameStylable).void }\n      def frame_style=(frame_style)\n        Frame.frame_style = frame_style\n      end\n\n      # Create a terminal link\n      sig { params(url: String, text: String, format: T::Boolean, blue_underline: T::Boolean).returns(String) }\n      def link(url, text, format: true, blue_underline: format)\n        raise 'cannot use blue_underline without format' if blue_underline && !format\n\n        text = \"{{blue:{{underline:#{text}}}}}\" if blue_underline\n        text = CLI::UI.fmt(text) if format\n        \"\\x1b]8;;#{url}\\x1b\\\\#{text}\\x1b]8;;\\x1b\\\\\"\n      end\n    end\n\n    self.enable_color = $stdout.tty?\n\n    # Shopify's CI system supports color, but not cursor control\n    self.enable_cursor = T.must($stdout.tty? && ENV['CI'].nil? && ENV['JOURNAL_STREAM'].nil?)\n  end\nend\n\nrequire 'cli/ui/stdout_router'\n",
      "path": "/lib/cli/"
    },
    {
      "filename": "markdown_content_section_splitter_8.rb",
      "content": "# frozen_string_literal: true\n\nmodule Processors\n  module Text\n    # Processes markdown content and splits it into structured sections\n    class Markdown < Base\n      # Data structures for sections\n      Section = Struct.new(:title, :content_lines, :start_line, :end_line, :subsections)\n      Subsection = Struct.new(:type, :title, :content, :start_line, :end_line, :parent_title)\n\n      MAX_SLUG_LENGTH = 50\n\n      def process(input)\n        if File.exist?(input)\n          content = File.read(input, encoding: 'UTF-8')\n          filename = File.basename(input)\n        else\n          content = input\n          filename = 'unknown.md'\n        end\n\n        split_markdown_content(content, filename)\n      rescue StandardError => e\n        log_error(\"Failed to process markdown: #{e.message}\")\n        []\n      end\n\n      private\n\n      def split_markdown_content(content, original_filename)\n        lines = content.lines\n        sections = extract_level2_sections(lines)\n\n        return [] if sections.empty?\n\n        sections.map.with_index do |section, section_idx|\n          subsections = extract_subsections(section, section_idx + 1, original_filename)\n          {\n            section_info: {\n              title: section.title,\n              start_line: section.start_line,\n              end_line: section.end_line,\n              original_file: original_filename\n            },\n            subsections: subsections\n          }\n        end\n      end\n\n      def extract_level2_sections(lines)\n        sections = []\n        buffer = []\n        current_start_line = 1\n        current_title = 'Introduction'\n\n        lines.each_with_index do |line, zero_idx|\n          current_line_num = zero_idx + 1\n\n          if (match = line.match(/^## (.*)/))\n            add_section_if_buffer_present(sections, current_title, buffer, current_start_line)\n            buffer = [line]\n            current_title = match[1].strip\n            current_start_line = current_line_num\n          else\n            buffer << line\n          end\n        end\n\n        add_section_if_buffer_present(sections, current_title, buffer, current_start_line)\n        sections\n      end\n\n      def add_section_if_buffer_present(sections, title, buffer, start_line)\n        return if buffer.empty?\n\n        end_line = start_line + buffer.count - 1\n        sections << Section.new(title, buffer.dup, start_line, end_line, [])\n        buffer.clear\n      end\n\n      def extract_subsections(section, section_idx, original_filename)\n        extractor = SubsectionExtractor.new(\n          section.content_lines,\n          section.start_line,\n          section.title,\n          section_idx,\n          original_filename\n        )\n        extractor.extract\n      end\n\n      # Internal class for extracting subsections\n      class SubsectionExtractor\n        def initialize(lines, start_line, parent_title, section_idx, original_filename)\n          @lines = lines\n          @start_line = start_line\n          @parent_title = parent_title\n          @section_idx = section_idx\n          @original_filename = original_filename\n          @subsections = []\n          @text_buffer = []\n          @text_buffer_start = -1\n          @current_idx = 0\n        end\n\n        def extract\n          while @current_idx < @lines.length\n            line = @lines[@current_idx]\n            consumed = try_special_handlers(line)\n\n            if consumed.positive?\n              @current_idx += consumed\n            else\n              add_to_text_buffer(line)\n              @current_idx += 1\n            end\n          end\n\n          flush_text_buffer(@lines.length - 1)\n          @subsections\n        end\n\n        private\n\n        def add_to_text_buffer(line)\n          @text_buffer_start = @current_idx if @text_buffer.empty?\n          @text_buffer << line\n        end\n\n        def flush_text_buffer(last_idx)\n          return if @text_buffer.empty? || @text_buffer_start == -1\n\n          start_abs = @start_line + @text_buffer_start\n          end_abs = @start_line + last_idx\n\n          @subsections << create_subsection_data(\n            'text',\n            'Text Content',\n            @text_buffer.join,\n            start_abs,\n            end_abs\n          )\n\n          @text_buffer.clear\n          @text_buffer_start = -1\n        end\n\n        def create_subsection_data(type, title, content, start_line, end_line)\n          {\n            metadata: {\n              original_file: @original_filename,\n              parent_section_title: @parent_title,\n              subsection_type: type,\n              title: title,\n              start_line: start_line,\n              end_line: end_line,\n              filename: generate_filename(type, title)\n            },\n            content: content.strip\n          }\n        end\n\n        def generate_filename(_type, title)\n          section_num = format('%03d', @section_idx)\n          subsection_num = format('%03d', @subsections.length + 1)\n\n          parent_slug = slugify(@parent_title, 'section')\n          title_slug = slugify(title, 'content')\n\n          combined_slug = truncate_slug(\"#{parent_slug}-#{title_slug}\")\n          \"#{section_num}-#{subsection_num}-#{combined_slug}.md\"\n        end\n\n        def slugify(text, fallback = 'content')\n          slug = text.to_s.downcase\n                     .gsub(/\\s+/, '-')\n                     .gsub(/[^\\w.:()-]/, '')\n                     .gsub(/^-+|-+$/, '')\n          slug.empty? ? fallback : slug\n        end\n\n        def truncate_slug(slug)\n          if slug.length > MAX_SLUG_LENGTH\n            slug[0...MAX_SLUG_LENGTH].gsub(/-+$/, '')\n          else\n            slug\n          end\n        end\n\n        def try_special_handlers(line)\n          handlers = [\n            method(:handle_code_block),\n            method(:handle_blockquote),\n            method(:handle_table),\n            method(:handle_image),\n            method(:handle_link)\n          ]\n\n          handlers.each do |handler|\n            consumed = handler.call(line)\n            next unless consumed.positive?\n\n            if @current_idx > @text_buffer_start && @text_buffer_start != -1\n              flush_text_buffer(@current_idx - 1)\n            end\n            return consumed\n          end\n\n          0\n        end\n\n        def handle_code_block(line)\n          match = line.match(/^```(\\w*)$/) || line.match(/^~~~(\\w*)$/)\n          return 0 unless match\n\n          fence = match[0][0, 3]\n          lang = match[1]\n          lines = [line]\n          idx = @current_idx + 1\n\n          while idx < @lines.length\n            lines << @lines[idx]\n            break if @lines[idx].strip == fence\n\n            idx += 1\n          end\n\n          title = lang.empty? ? 'Code Block' : \"Code Block (#{lang})\"\n          start_abs = @start_line + @current_idx\n          end_abs = @start_line + (idx < @lines.length ? idx : @lines.length - 1)\n\n          @subsections << create_subsection_data(\n            'codeblock',\n            title,\n            lines.join,\n            start_abs,\n            end_abs\n          )\n\n          lines.length\n        end\n\n        def handle_blockquote(line)\n          return 0 unless line.strip.start_with?('>')\n\n          lines = []\n          idx = @current_idx\n\n          while idx < @lines.length && @lines[idx].strip.start_with?('>')\n            lines << @lines[idx]\n            idx += 1\n          end\n\n          return 0 if lines.empty?\n\n          start_abs = @start_line + @current_idx\n          end_abs = @start_line + idx - 1\n\n          @subsections << create_subsection_data(\n            'blockquote',\n            'Blockquote',\n            lines.join,\n            start_abs,\n            end_abs\n          )\n\n          lines.length\n        end\n\n        def handle_table(line)\n          return 0 unless line.strip.start_with?('|') && line.count('|') >= 2\n\n          lines = []\n          idx = @current_idx\n\n          while idx < @lines.length &&\n                @lines[idx].strip.start_with?('|') &&\n                @lines[idx].count('|') >= 2\n\n            lines << @lines[idx]\n            idx += 1\n          end\n\n          return 0 if lines.empty?\n\n          start_abs = @start_line + @current_idx\n          end_abs = @start_line + idx - 1\n\n          @subsections << create_subsection_data(\n            'table',\n            'Table',\n            lines.join,\n            start_abs,\n            end_abs\n          )\n\n          lines.length\n        end\n\n        def handle_image(line)\n          match = line.strip.match(/^!\\[([^\\]]*)\\]\\(([^\\)]+)\\)$/)\n          return 0 unless match\n\n          title = match[1].empty? ? 'Image' : \"Image: #{match[1]}\"\n          start_abs = @start_line + @current_idx\n\n          @subsections << create_subsection_data(\n            'image',\n            title,\n            line,\n            start_abs,\n            start_abs\n          )\n\n          1\n        end\n\n        def handle_link(line)\n          match = line.strip.match(/^\\[([^\\]]+)\\]\\(([^\\)]+)\\)$/)\n          return 0 unless match\n\n          title = match[1].empty? ? 'Link' : \"Link: #{match[1]}\"\n          start_abs = @start_line + @current_idx\n\n          @subsections << create_subsection_data(\n            'link',\n            title,\n            line,\n            start_abs,\n            start_abs\n          )\n\n          1\n        end\n      end\n    end\n  end\nend\n",
      "path": "/"
    }
  ]
}
